<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.7.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="本章内容 ： 语法   数据类型   流控制语句   函数  任何语言的核心都必然会描述这门语言基本的工作原理。而描述的内容通常都要涉及这门语 言的语法、操作符、数据类型、内置功能等用于构建复杂解决方案的基本概念。如前所述， ECMA-262通过叫做 ECMAScript的“伪语言”为我们描述了 JavaScript的所有这些基本概念。">
<meta property="og:type" content="article">
<meta property="og:title" content="第三章 基本概念">
<meta property="og:url" content="http://yoursite.com/2019/11/23/第三章-基本概念/index.html">
<meta property="og:site_name" content="天心天地生">
<meta property="og:description" content="本章内容 ： 语法   数据类型   流控制语句   函数  任何语言的核心都必然会描述这门语言基本的工作原理。而描述的内容通常都要涉及这门语 言的语法、操作符、数据类型、内置功能等用于构建复杂解决方案的基本概念。如前所述， ECMA-262通过叫做 ECMAScript的“伪语言”为我们描述了 JavaScript的所有这些基本概念。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-11-24T13:00:33.994Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第三章 基本概念">
<meta name="twitter:description" content="本章内容 ： 语法   数据类型   流控制语句   函数  任何语言的核心都必然会描述这门语言基本的工作原理。而描述的内容通常都要涉及这门语 言的语法、操作符、数据类型、内置功能等用于构建复杂解决方案的基本概念。如前所述， ECMA-262通过叫做 ECMAScript的“伪语言”为我们描述了 JavaScript的所有这些基本概念。">
  <link rel="canonical" href="http://yoursite.com/2019/11/23/第三章-基本概念/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>第三章 基本概念 | 天心天地生</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">天心天地生</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">死亡是一座永恒的灯塔</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
        
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      
    
      
      
        
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      
    
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">
          <i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/23/第三章-基本概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田迪生">
      <meta itemprop="description" content="田迪生的个人博客">
      <meta itemprop="image" content="/images/金凰儿.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天心天地生">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            第三章 基本概念
            

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-11-23 18:07:49" itemprop="dateCreated datePublished" datetime="2019-11-23T18:07:49+08:00">2019-11-23</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-24 21:00:33" itemprop="dateModified" datetime="2019-11-24T21:00:33+08:00">2019-11-24</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES5/" itemprop="url" rel="index">
                    <span itemprop="name">ES5</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
          
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>17k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>15 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本章内容 ：</p><ul>
<li><p>语法 </p>
</li>
<li><p>数据类型 </p>
</li>
<li><p>流控制语句 </p>
</li>
<li>函数 </li>
</ul><p>任何语言的核心都必然会描述这门语言基本的工作原理。而描述的内容通常都要涉及这门语 言的语法、操作符、数据类型、内置功能等用于构建复杂解决方案的基本概念。如前所述， ECMA-262通过叫做 ECMAScript的“伪语言”为我们描述了 JavaScript的所有这些基本概念。 </p><a id="more"></a>


<p>目前，ECMA-262 第 3 版中定义的 ECMAScript 是各浏览器实现多的一个版本。ECMA-262 第 5 版是浏览器接下来实现的版本，但截止到 2011 年底，还没有浏览器完全实现了这个版本。为此，本章 将主要按照第 3版定义的 ECMAScript介绍这门语言的基本概念，并就第 5版的变化给出说明。 </p>
<h1 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h1><p>ECMAScript的语法大量借鉴了 C及其他类 C语言（如 Java和 Perl）的语法。因此，熟悉这些语言 的开发人员在接受 ECMAScript更加宽松的语法时，一定会有一种轻松自在的感觉。 </p>
<h2 id="3-1-1-区分大小写"><a href="#3-1-1-区分大小写" class="headerlink" title="3.1.1 区分大小写"></a>3.1.1 区分大小写</h2><p>要理解的第一个概念就是 ECMAScript中的一切（变量、函数名和操作符）都区分大小写。这也就 意味着，变量名 test 和变量名 Test 分别表示两个不同的变量，而函数名不能使用 typeof，因为它 是一个关键字（3.2节介绍关键字），但 typeOf 则完全可以是一个有效的函数名。 </p>
<h2 id="3-1-2-标识符"><a href="#3-1-2-标识符" class="headerlink" title="3.1.2 标识符"></a>3.1.2 标识符</h2><p>所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。标识符可以是按照以下格式规则组合起来的一个或者多个字符：</p>
<ul>
<li>第一个字符必须是一个字母、下划线、或一个美元符号</li>
<li>其他字符可以是字母、下划线、美元符号或数字</li>
</ul>
<p>按照惯例，ECMAscript标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写。</p>
<h2 id="3-1-3-注释"><a href="#3-1-3-注释" class="headerlink" title="3.1.3 注释"></a>3.1.3 注释</h2><p>ECMAScript使用C风格的注释，包括单行注释和块级注释。</p>
<ol>
<li>单行注释以两个斜杠开头</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>块级注释以一个斜杠和一个星号（/<em>）开头，以一个星号和一个斜杠（</em>/）结尾。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这是一个多行</span></span><br><span class="line"><span class="comment">*（块级注释）</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="3-1-4-严格模式"><a href="#3-1-4-严格模式" class="headerlink" title="3.1.4 严格模式"></a>3.1.4 严格模式</h2><p>在顶部添加如下代码即可进入严格模式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br></pre></td></tr></table></figure></p>
<p>在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;      <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>严格模式下，JavaScript 的执行结果会有很大不同，因此本书将会随时指出严格模式下的区别。支 持严格模式的浏览器包括 IE10+、Firefox 4+、Safari 5.1+、Opera 12+和 Chrome。 </p>
<h2 id="3-1-5-语句"><a href="#3-1-5-语句" class="headerlink" title="3.1.5 语句"></a>3.1.5 语句</h2><p>ECMAScript中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = a + b            <span class="comment">// 即使没有分号也是有效的语句——不推荐 </span></span><br><span class="line"><span class="keyword">var</span> diff = a - b;          <span class="comment">// 有效的语句——推荐</span></span><br></pre></td></tr></table></figure>
<p>可以使用C风格的语法把多余的语句整合到一个代码块中，即代码块以左花括号<code>{</code>开头，以右花括号<code>}</code>结尾。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (test)</span><br><span class="line">   alert(test);  <span class="comment">//有效但容易出错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (test)&#123;</span><br><span class="line">   alert(test)</span><br><span class="line">&#125;;                   <span class="comment">//推荐使用</span></span><br></pre></td></tr></table></figure>
<h1 id="3-2-关键字和保留字"><a href="#3-2-关键字和保留字" class="headerlink" title="3.2 关键字和保留字"></a>3.2 关键字和保留字</h1><h2 id="3-2-1-关键字"><a href="#3-2-1-关键字" class="headerlink" title="3.2.1 关键字"></a>3.2.1 关键字</h2><p>ECMA-262描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或 者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。以下就是 ECMAScript 的全部关键字（带*号上标的是第 5版新增的关键字）</p>
<table>
<thead>
<tr>
<th>break</th>
<th>do</th>
<th>instanceof</th>
<th>typeof</th>
<th>case</th>
<th>else</th>
<th>new</th>
<th>var</th>
</tr>
</thead>
<tbody>
<tr>
<td>catch</td>
<td>finally</td>
<td>return</td>
<td>void</td>
<td>continue</td>
<td>for</td>
<td>switch</td>
<td>while</td>
</tr>
<tr>
<td>debugger*</td>
<td>function</td>
<td>this</td>
<td>with</td>
<td>default</td>
<td>if</td>
<td>throw</td>
<td>delete</td>
</tr>
<tr>
<td>in</td>
<td>try</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="3-2-2-保留字"><a href="#3-2-2-保留字" class="headerlink" title="3.2.2 保留字"></a>3.2.2 保留字</h2><p>以下是 ECMA-262第 3版定义的全部保留字：</p>
<table>
<thead>
<tr>
<th>abstract</th>
<th>short</th>
<th>boolean</th>
<th>export</th>
<th>interface</th>
<th>static</th>
<th>enum</th>
<th>int</th>
</tr>
</thead>
<tbody>
<tr>
<td>static</td>
<td>byte</td>
<td>extends</td>
<td>long</td>
<td>super</td>
<td>char</td>
<td>final</td>
<td>native</td>
</tr>
<tr>
<td>synchronized</td>
<td>class</td>
<td>float</td>
<td>package</td>
<td>throws</td>
<td>const</td>
<td>goto</td>
<td>private</td>
</tr>
<tr>
<td>transient</td>
<td>debugger</td>
<td>implements</td>
<td>protected</td>
<td>volatile</td>
<td>double</td>
<td>import</td>
<td>public</td>
</tr>
</tbody>
</table>
<p>第 5版把在非严格模式下运行时的保留字缩减为下列这些：</p>
<table>
<thead>
<tr>
<th>class</th>
<th>enum</th>
<th>extends</th>
</tr>
</thead>
<tbody>
<tr>
<td>super</td>
<td>const</td>
<td>export</td>
</tr>
<tr>
<td>import</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>第五版严格模式下：</strong></p>
<table>
<thead>
<tr>
<th>implements</th>
<th>package</th>
<th>public</th>
</tr>
</thead>
<tbody>
<tr>
<td>interface</td>
<td>private</td>
<td>static</td>
</tr>
<tr>
<td>let</td>
<td>protected</td>
<td>yield</td>
</tr>
</tbody>
</table>
<p><strong>第六版新增了let和const关键字</strong></p>
<p><strong>总结</strong>：</p>
<ol>
<li>使用保留字标识符可能会也可能不会出错，具体取决与特定的引擎。一般来说。最好不要使用关键字和保留字作为标识符和属性名，以便与将来的ECMAScript版本兼容。</li>
<li>ECMA-262第 5版对 eval 和 arguments 还施加了限制。在严格模式下，这两个名字也不能作为标识符或属性名，否则会抛出错误。</li>
</ol>
<p>#3.3 变量<br>ECMAScript的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。<br>定义变量时要用var操作符（var是一个关键字），后跟变量名（即一个标识符），<br>如下所示<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br></pre></td></tr></table></figure></p>
<p>这行代码定义了一个名为message的变量，该变量可以用来保存任何值（像这样未经初始化的变量，会保存一个特殊的值——undefined）。</p>
<p>注意：用var操作符定义的变量将成为定义变量作用域中的局部变量。</p>
<p>如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="string">"hi"</span>; <span class="comment">//局部变量</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">alert(message);  <span class="comment">//错误提示：message is not defined</span></span><br></pre></td></tr></table></figure>
<p>像下面这 样省略 var 操作符，从而创建一个全局变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    message = <span class="string">"hi"</span>; <span class="comment">//全局变量省略了 var 操作符，因而 message 就成了全局变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message);<span class="comment">//&gt; undefined</span></span><br><span class="line">test();<span class="comment">//只要调用过一次 test()函 数，这个变量就有了定义，就可以在函数外部的任何地方被访问到。</span></span><br><span class="line"><span class="built_in">console</span>.log(message);<span class="comment">//&gt; hi</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然省略 var 操作符可以定义全局变量，但这也不是我们推荐的做法。因为在局 部作用域中定义的全局变量很难维护，而且如果有意地忽略了 var 操作符，也会由于 相应变量不会马上就有定义而导致不必要的混乱。给未经声明的变量赋值在严格模式 下会导致抛出 ReferenceError 错误。 </p>
</blockquote>
<p>可以使用一条语句定义多个变量，只要像下面这样把每个变量（初始化或不初始化均可）用逗号分 隔开即可： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"hi"</span>, </span><br><span class="line">    found = <span class="literal">false</span>, </span><br><span class="line">    age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
<p> 这个例子定义并初始化了 3个变量。同样由于 ECMAScript是松散类型的，因而使用不同类型初始 化变量的操作可以放在一条语句中来完成。虽然代码里的换行和变量缩进不是必需的，但这样做可以提 高可读性。 </p>
<h1 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4 数据类型"></a>3.4 数据类型</h1><p>ECMAscript中有五种简单数据类型（也称基本数据类型）：Undefined、Null、Boolean、Number和String,还有一种复杂数据类型——Object，Object本质上是由一组无序的名值对组成的。</p>
<p><strong>ECMAscript不支持任何创建自定义类型的机制，而所有值最终都将是上述六种数据类型之一。</strong></p>
<h2 id="3-4-1-typeof操作符"><a href="#3-4-1-typeof操作符" class="headerlink" title="3.4.1 typeof操作符"></a>3.4.1 typeof操作符</h2><p>由于ECMASrcipt是松散类型的，因此需要有一种手段来检测给定变量的数据类型——typeof就是负责提供这方面信息的操作符。</p>
<p>对一个值使用typeof操作符可能返回下列某个字符串：</p>
<ul>
<li>undefined——如果这个值未定义；</li>
<li>boolean——如果这个值是布尔值；</li>
<li>string——如果这个值是字符串；</li>
<li>number——如果这个值是数值；</li>
<li>object——如果这个值是对象或者null；</li>
<li>function——如果这个值是函数。</li>
</ul>
<p>下面是几个使用 typeof 操作符的例子： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"some string"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message);     <span class="comment">//&gt; string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(message));    <span class="comment">//&gt; string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">95</span>);          <span class="comment">//&gt; number</span></span><br></pre></td></tr></table></figure>
<h2 id="3-4-2-Undefined类型"><a href="#3-4-2-Undefined类型" class="headerlink" title="3.4.2 Undefined类型"></a>3.4.2 Undefined类型</h2><p>Undefine类型只有一个值，即特殊的undefined。在使用 var 声明变量但未对其加以初始化时， 这个变量的值就是 undefined。</p>
<p><strong>第 3版引入这个值是为了正式区分空对象指针与未经初始化的变量。</strong> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// /undefined;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message); <span class="comment">//undefined;</span></span><br><span class="line"><span class="built_in">console</span>.log(message === <span class="literal">undefined</span>); <span class="comment">//true 未初始化的变量的值会默认为undefined；</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> age); <span class="comment">//undefined; 未声明的变量执行typeof也是返回undefined。</span></span><br><span class="line"><span class="built_in">console</span>.log(message === age); <span class="comment">//未声明的值会报错</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// 未声明的值会报错</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般而言，不存在需要显式地把一个变量设置为 undefined 值的情况。字面值 undefined 的主要目的是用于比较，而 ECMA-262第 3版之前的版本中并没有规定 这个值。<strong>第 3版引入这个值是为了正式区分空对象指针与未经初始化的变量。</strong> </p>
</blockquote>
<h2 id="3-4-3-Null类型"><a href="#3-4-3-Null类型" class="headerlink" title="3.4.3 Null类型"></a>3.4.3 Null类型</h2><p><strong>Null 类型是第二个只有一个值的数据类型</strong>，这个特殊的值是 null。从逻辑角度来看，null 值表 示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回”object”的原因，如下面 的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> car = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> car);     <span class="comment">//&gt;object</span></span><br><span class="line"><span class="built_in">console</span>.log(car === <span class="literal">null</span>);     <span class="comment">//&gt;true</span></span><br></pre></td></tr></table></figure>
<p>如果定义的变量准备在将来用于保存对象，那么好将该变量初始化为 null 而不是其他值。这样不仅可以体现null作为空对象指针的惯例，而且也有助于进一步<strong>区分null和undefined</strong>。这样 一来，只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用，如下面的例子 所示： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> car = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> car);     <span class="comment">// &gt;object</span></span><br><span class="line"><span class="built_in">console</span>.log(car === <span class="literal">null</span>);      <span class="comment">//&gt;false</span></span><br><span class="line"><span class="keyword">if</span> (car != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 对 car 对象执行某些操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"对 car 对象执行某些操作"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，undefined 值是派生自 null 值的，因此 ECMA-262规定对它们的相等性测试要返回 true：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>);    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> === <span class="literal">undefined</span>);    <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>尽管 null 和 undefined 有这样的关系，但它们的用途完全不同。如前所述，无论在什么情况下 都没有必要把一个变量的值显式地设置为 undefined，可是同样的规则对 null 却不适用。换句话说， 只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不仅可以 体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。</p>
<h2 id="3-4-4-Boolean类型"><a href="#3-4-4-Boolean类型" class="headerlink" title="3.4.4 Boolean类型"></a>3.4.4 Boolean类型</h2><p>Boolean 类型是 ECMAScript中使用得多的一种类型，该类型只有两个字面值：true 和 false。 </p>
<p>虽然Boolean类型的字面值只有两个，但是ECMAScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean()。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">var</span> messageAsBoolean = <span class="built_in">Boolean</span>(message); </span><br><span class="line"><span class="built_in">console</span>.log(messageAsBoolean);<span class="comment">//&gt;true</span></span><br></pre></td></tr></table></figure>
<p>下表给出了各种数据类型及其对 应的转换规则。 </p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为true的值</th>
<th>转换为false的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>“”（空字符串）</td>
</tr>
<tr>
<td>Number</td>
<td>任何非零数字值（包括无穷大）</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>n/a（not applicable）</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<p>这些转换规则对理解流控制语句（如 if 语句）<strong>自动执行相应的 Boolean 转换</strong>非常重要，请看下面 的代码： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">if</span> (message) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Value is true"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这个示例，控制台就会打印对应字符串，因为字符串 message 被自动转换成了对应的 Boolean 值 （true）。由于存在这种自动执行的 Boolean 转换，因此确切地知道在流控制语句中使用的是什么变量 至关重要。</p>
<p><strong>错误地使用一个对象而不是一个 Boolean 值，就有可能彻底改变应用程序的流程。</strong> </p>
<h2 id="3-4-5-Number类型"><a href="#3-4-5-Number类型" class="headerlink" title="3.4.5 Number类型"></a>3.4.5 Number类型</h2><p>这种类型使用 IEEE754格式来表示 整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。为支持各种数值类型，ECMA-262 定 义了不同的数值字面量格式。</p>
<ul>
<li>十进制</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intNum = <span class="number">55</span>; <span class="comment">//整数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>八进制：</li>
</ul>
<p>字面值的第一位必须为零0；然后八进制数字序列（0~7），如果超出范围，那么将解析为十进制。八进制在严格模式下会无效，会导致支持的JavaScript引擎抛出错误；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> octalNum1 = <span class="number">070</span>; <span class="comment">//八进制的56</span></span><br><span class="line"><span class="keyword">var</span> octalNum2 = <span class="number">079</span>; <span class="comment">//无效的八进制 79</span></span><br><span class="line"><span class="keyword">var</span> octalNum3 = <span class="number">08</span>; <span class="comment">//无效的八进制 8</span></span><br></pre></td></tr></table></figure>
<ul>
<li>十六进制</li>
</ul>
<p>十六进制的字面值的前两位必须时0x，后跟任何十六进制的数字（09及AF）。其中A~F可以大写也可以小写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hexNum1 = <span class="number">0xA</span>; <span class="comment">// 十六进制的10</span></span><br><span class="line"><span class="keyword">var</span> hexNum2 = <span class="number">0x1f</span>; <span class="comment">//十六进制的31</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：在算数计算时。所有以八进制和十六进制表示的数值最终都将被换成十进制数值；可以保存+0和-0，正零和负零被认为时相等的。</p>
<h3 id="浮点数值"><a href="#浮点数值" class="headerlink" title="浮点数值"></a>浮点数值</h3><p>所为浮点数值，就是该数值中必须包括一个小数点，并且小数点后面必须至少有一位数字。虽然小 数点前面可以没有整数，但我们不推荐这种写法。以下是浮点数值的几个例子： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> floatNum1 = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">var</span> floatNum2 = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">var</span> floatNum3 = <span class="number">.1</span>; <span class="comment">// 有效但是不推荐</span></span><br></pre></td></tr></table></figure>
<p>由于保存浮点数值需要的内存空间时保存整数的两倍，因此ECMAScript会不失时机地将浮点数值转换为整数值。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> floatNum1 = <span class="number">1.</span>; <span class="comment">//小数点后面数字所以解析为1</span></span><br><span class="line"><span class="keyword">var</span> floatNum2 = <span class="number">10.0</span>; <span class="comment">//整数 ；解析为10</span></span><br><span class="line"><span class="built_in">console</span>.log(floatNum1);<span class="comment">//&gt;1</span></span><br><span class="line"><span class="built_in">console</span>.log(floatNum2);<span class="comment">//&gt;10</span></span><br></pre></td></tr></table></figure>
<p>对于极大或极小的数值，可以用e表示法（即科学记数法）表示的浮点数值表示法，用e表示法表示的数值等于e前面的数值乘以10的指数次幂： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> floatNum = <span class="number">3.12e7</span>; <span class="comment">// 等于31200000</span></span><br><span class="line"><span class="keyword">var</span> floatNum2 = <span class="number">3.1e-7</span>; <span class="comment">// 等于0.00000031</span></span><br><span class="line"><span class="keyword">var</span> floatNum3  = <span class="number">0.000000006</span>; <span class="comment">//在默认情况下，ECMASctipt 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示法 表示的数值</span></span><br><span class="line"><span class="built_in">console</span>.log(floatNum3);<span class="comment">//&gt;6e-9</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>浮点数的最高精度是17位小数，但在进行算数计算时其精确度远远不如整数。列如，0.1加0.2的结果不是0.3，而是 0.30000000000000004.这个小小的舍入误差会导致无法测试特定的浮点数值，所以<strong>永远不要测试某个特定的浮点数；</strong> </p>
<p>关于浮点数值计算会产生舍入误差的问题，有一点需要明确：这是使用基于 IEEE754 数值的浮点计算的通病，ECMAScript 并非独此一家；其他使用相同数值格 式的语言也存在这个问题。 </p>
</blockquote>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>由于内存的限制，ECMAScript并不能保存世界上所有的数值。ECMAScript能够表示的小数值保 存在 Number.MIN_VALUE 中——在大多数浏览器中，这个值是 5e-324；能够表示的大数值保存在 Number.MAX_VALUE 中——在大多数浏览器中，这个值是 1.7976931348623157e+308。如果某次计算的 结果得到了一个超出 JavaScript数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。具 体来说，如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转 换成 Infinity（正无穷）。</p>
<p>如上所述，如果某次计算返回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算， 因为 Infinity 不是能够参与计算的数值。要想确定一个数值是不是有穷的（换句话说，是不是位于 小和大的数值之间），可以使用 <code>isFinite()</code>函数。这个函数在参数位于小与大数值之间时会返 回 true，如下面的例子所示： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxNumber = <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line"><span class="keyword">var</span> result = maxNumber + maxNumber;</span><br><span class="line"><span class="keyword">var</span> result1 = maxNumber + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> result2 = maxNumber + <span class="number">1e292</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(maxNumber);<span class="comment">//&gt;1.7976931348623157e+308</span></span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(result));  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(result1));  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(result2));  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>IEEE 754 标准规定: 只有大于等于1.797693134862315<strong>8</strong>e+308的数才会被 round 到 Infinity. 而 Number.MAX_VALUE 才是1.7976931348623157e+308, 加上 1 还远远不到 Infinity. </p>
</blockquote>
<p>尽管在计算中很少出现某些值超出表示范围的情况，但在执行极小或极大数值的计算时，检测监控 这些值是可能的，也是必需的。</p>
<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>NaN，即非数值（Not a Number）是一个特殊数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误）。例如，在其他编程语言中，任何数值除以 0都会导致错误， 从而停止代码执行。但在 ECMAScript中，任何数值除以 0会返回 NaN①，因此不会影响其他代码的执行。 </p>
<p>NaN有两个特点：</p>
<ol>
<li>首先，任何涉及NaN的操作都会返回NaN。</li>
<li>其次，NaN与任何值都不相等，包括NaN本身。</li>
</ol>
<p>针对这两个特点，ECMAScript定义了<code>isNaN</code>函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。</p>
<p><code>isNaN()</code>在接收到一个值之后，会尝试 将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串”10”或 Boolean 值。而任何 不能被转换为数值的值都会导致这个函数返回 true。请看下面的例子： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>));         <span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">10</span>));          <span class="comment">//false（10 是一个数值） </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">"10"</span>));        <span class="comment">//false（可以被转换成数值 10） </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">"blue"</span>));      <span class="comment">//true（不能转换成数值） </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">true</span>));        <span class="comment">//false（可以被转换成数值 1）</span></span><br></pre></td></tr></table></figure>
<p>这个例子测试了 5个不同的值。测试的第一个值是 NaN 本身，结果当然会返回 true。然后分别测 试了数值 10和字符串”10”，结果这两个测试都返回了 false，因为前者本身就是数值，而后者可以被 转换成数值。但是，字符串”blue”不能被转换成数值，因此函数返回了 true。由于 Boolean 值 true 可以转换成数值 1，因此函数返回 false。 </p>
<blockquote>
<p>尽管有点儿不可思议，但 <code>isNaN()</code>确实也适用于对象。在基于对象调用<code>isNaN()</code> 函数时，会首先调用对象的 <code>valueOf()</code>方法，然后确定该方法返回的值是否可以转 换为数值。如果不能，则基于这个返回值再调用 <code>toString()</code>方法，再测试返回值。 而这个过程也是 ECMAScript中内置函数和操作符的一般执行流程，更详细的内容请 参见 3.5节。 </p>
</blockquote>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p>有三个函数可以把非数值转换为数值：Number()，parseInt()和parseFloat()。第一个函数， 即转型函数 Number()可以用于<strong>任何数据类型</strong>，而另两个函数则专门用于把<strong>字符串</strong>转换成数值。这 3个 函数对于同样的输入会有返回不同的结果。 </p>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h4><p>Number()函数的转换规则如下：</p>
<ul>
<li>如果是 Boolean 值，true 和 false 将分别被转换为 1和 0。</li>
<li>如果是数字值，只是简单的传入和返回。</li>
<li>如果是 null 值，返回 0。</li>
<li>如果是 undefined，返回 NaN。</li>
<li><p>如果是字符串，遵循下列规则：</p>
<ul>
<li>如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即”1” 会变成 1，“123”会变成 123，而”011”会变成 11（注意：前导的零被忽略了）；</li>
<li>如果字符串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值（同样，也会忽 略前导零）；</li>
<li>如果字符串中包含有效的十六进制格式，例如”0xf”，则将其转换为相同大小的十进制整 数值；</li>
<li>如果字符串是空的（不包含任何字符），则将其转换为 0；</li>
<li>如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。</li>
</ul>
</li>
<li><p>如果是对象，则调用对象的<code>valueOf()</code>方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的<code>toString()</code>方法，然后再次依照前面的规则转换返回的字符串值。</p>
</li>
</ul>
<p>根据这么多的规则使用 Number()把各种数据类型转换为数值确实有点复杂。下面还是给出几个具 体的例子吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">Number</span>(<span class="string">"Hello world!"</span>);      <span class="comment">//NaN </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">Number</span>(<span class="string">""</span>);                  <span class="comment">//0 </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">Number</span>(<span class="string">"000011"</span>);          <span class="comment">//11 </span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">Number</span>(<span class="literal">true</span>);              <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>首先，字符串”Hello world!”会被转换为 NaN，因为其中不包含任何有意义的数字值。空字符串 会被转换为 0。字符串”000011”会被转换为 11，因为忽略了其前导的零。后，true 值被转换为 1。</p>
<blockquote>
<p>一元加操作符（3.5.1节将介绍）的操作与 Number()函数相同。 </p>
</blockquote>
<h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h4><p>由于 Number()函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是 parseInt()函数。parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字 符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt() 就会返回 NaN；也就是说，用 parseInt()转换空字符串会返回 NaN（Number()对空字符返回 0）。如 果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了 一个非数字字符。例如，”1234blue”会被转换为 1234，因为”blue”会被完全忽略。类似地，”22.5” 会被转换为 22，因为小数点并不是有效的数字字符。 </p>
<p>如果字符串中的第一个字符是数字字符，parseInt()也能够识别出各种整数格式（即前面讨论的 十进制、八进制和十六进制数）。也就是说，如果字符串以”0x”开头且后跟数字字符，就会将其当作一 个十六进制整数；如果字符串以”0”开头且后跟数字字符，则会将其当作一个八进制数来解析。 为了更好地理解 parseInt()函数的转换规则，下面给出一些例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"1234blue"</span>);    <span class="comment">// 1234 </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">""</span>);            <span class="comment">// NaN </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">"0xA"</span>);         <span class="comment">// 10（十六进制数） </span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>);          <span class="comment">// 22 </span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseInt</span>(<span class="string">"070"</span>);         <span class="comment">// 56（八进制数） </span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseInt</span>(<span class="string">"70"</span>);         <span class="comment">// 70（十进制数） </span></span><br><span class="line"><span class="keyword">var</span> num7 = <span class="built_in">parseInt</span>(<span class="string">"0xf"</span>);         <span class="comment">// 15（十六进制数）</span></span><br></pre></td></tr></table></figure>
<p>为了消除在使用 parseInt()函数时可能导致的进制转换分歧，可以为这个函数提供第二个参数：转换 时使用的基数（即多少进制）。如果知道要解析的值是十六进制格式的字符串，那么指定基数 16作为第 二个参数，可以保证得到正确的结果，例如： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(<span class="string">"0xAF"</span>, <span class="number">16</span>);  <span class="comment">//175</span></span><br></pre></td></tr></table></figure>
<p>实际上，如果指定了 16作为第二个参数，字符串可以不带前面的”0x”，如下所示： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"AF"</span>, <span class="number">16</span>);  <span class="comment">//175 </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">"AF"</span>);   <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的第一个转换成功了，而第二个则失败了。差别在于第一个转换传入了基数，明确告诉 parseInt()要解析一个十六进制格式的字符串；而第二个转换发现第一个字符不是数字字符，因此就 自动终止了。 </p>
<p><strong>不指定基数意味着让 parseInt()决定如何解析输入的字符串，因此为了避免错误的解析，我们建 议无论在什么情况下都明确指定基数。</strong> </p>
<blockquote>
<p>多数情况下，我们要解析的都是十进制数值，因此始终将 10 作为第二个参数是 非常必要的。 </p>
</blockquote>
<h4 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h4><p>parseFloat()也是从第一个字符（位置 0）开始解析每个字符。而且 也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第 一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。举例来说， “22.34.5”将会被转换为 22.34。 </p>
<p>除了第一个小数点有效之外，parseFloat()与 parseInt()的第二个区别在于它始终都会忽略前导 的零。parseFloat()可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格 式的字符串则始终会被转换成 0。由于 parseFloat()只解析十进制值，因此它没有用第二个参数指定基 数的用法。后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后 都是零），parseFloat()会返回整数。以下是使用 parseFloat()转换数值的几个典型示例。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">"1234blue"</span>);        <span class="comment">//1234 （整数） </span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">"0xA"</span>);              <span class="comment">//0 </span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">"22.5"</span>);             <span class="comment">//22.5 </span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">"22.34.5"</span>);          <span class="comment">//22.34 </span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">"0908.5"</span>);          <span class="comment">//908.5 </span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">"3.125e7"</span>);          <span class="comment">//31250000</span></span><br></pre></td></tr></table></figure>
<h2 id="3-4-6-String类型"><a href="#3-4-6-String类型" class="headerlink" title="3.4.6 String类型"></a>3.4.6 String类型</h2><p>String 类型用于表示由零或多个 16位 Unicode字符组成的字符序列，即字符串。字符串可以由双 引号（”）或单引号（’）表示，因此下面两种字符串的写法都是有效的： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstName = <span class="string">"天"</span>; </span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'地生'</span>;</span><br></pre></td></tr></table></figure>
<p>与 PHP中的双引号和单引号会影响对字符串的解释方式不同，ECMAScript中的这两种语法形式没 有什么区别。用双引号表示的字符串和用单引号表示的字符串完全相同。不过，以双引号开头的字符串也必须以双引号结尾，而以单引号开头的字符串必须以单引号结尾。</p>
<h3 id="字符表面量"><a href="#字符表面量" class="headerlink" title="字符表面量"></a>字符表面量</h3><p>String数据类型包含一些特殊的字符表面量，也叫转义序列，用于表示非打印字符，或者具有其他作用的字符。这些字符字面量如下表所示： </p>
<table>
<thead>
<tr>
<th style="text-align:center">字面量</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\n</code></td>
<td style="text-align:center">换行</td>
</tr>
<tr>
<td style="text-align:center"><code>\t</code></td>
<td style="text-align:center">制表</td>
</tr>
<tr>
<td style="text-align:center"><code>\b</code></td>
<td style="text-align:center">空格</td>
</tr>
<tr>
<td style="text-align:center"><code>\r</code></td>
<td style="text-align:center">回车</td>
</tr>
<tr>
<td style="text-align:center"><code>\f</code></td>
<td style="text-align:center">进纸</td>
</tr>
<tr>
<td style="text-align:center"><code>\\</code></td>
<td style="text-align:center">斜杠</td>
</tr>
<tr>
<td style="text-align:center"><code>\&#39;</code></td>
<td style="text-align:center">单引号（’），在用单引号表示的字符串中使用。例如：’He said, \’hey.\’’</td>
</tr>
<tr>
<td style="text-align:center"><code>\&quot;</code></td>
<td style="text-align:center">双引号（”），在用双引号表示的字符串中使用。例如：”He said, \”hey.\””</td>
</tr>
<tr>
<td style="text-align:center"><code>\xnn</code></td>
<td style="text-align:center">以十六进制代码nn表示的一个字符（其中n为0～F）。例如，\x41表示”A”</td>
</tr>
<tr>
<td style="text-align:center"><code>\unnn</code></td>
<td style="text-align:center">以十六进制代码nnnn表示的一个Unicode字符（其中n为0～F）。例如，\u03a3表示希腊字符Σ</td>
</tr>
</tbody>
</table>
<p>这些字符字面量可以出现在字符串中的任意位置，而且也将被作为一个字符来解析，如下面的例子 所示： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"This is the letter sigma: \u03a3."</span>;</span><br><span class="line"><span class="built_in">console</span>.log(text); <span class="comment">// &gt;This is the letter sigma: Σ.</span></span><br><span class="line"><span class="built_in">console</span>.log(text.length); <span class="comment">// &gt;28</span></span><br></pre></td></tr></table></figure>
<p> 这个例子中的变量 text 有 28个字符，其中 6个字符长的转义序列表示 1个字符。 任何字符串的长度都可以通过访问其 length 属性取得，例如： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"This is the letter sigma: \u03a3."</span>;</span><br><span class="line"><span class="built_in">console</span>.log(text.length); <span class="comment">// &gt;28</span></span><br></pre></td></tr></table></figure>
<p> 这个属性返回的字符数包括 16 位字符的数目。如果字符串中包含双字节字符，那么 length 属性 可能不会精确地返回字符串中的字符数目。 </p>
<h3 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h3><p>ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，他们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用一个包含新值的字符串填充该变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lang = <span class="string">"Java"</span>; </span><br><span class="line">lang = lang + <span class="string">"Script"</span>;</span><br></pre></td></tr></table></figure>
<p>以上示例中的变量lang 开始时包含字符串”Java”。而第二行代码把lang 的值重新定义为”Java” 与”Script”的组合，即”JavaScript”。实现这个操作的过程如下：首先创建一个能容纳 10个字符的 新字符串，然后在这个字符串中填充”Java”和”Script”，后一步是销毁原来的字符串”Java”和字 符串”Script”，因为这两个字符串已经没用了。这个过程是在后台发生的，而这也是在某些旧版本的浏览器（例如版本低于 1.0 的 Firefox、IE6等）中拼接字符串时速度很慢的原因所在。但这些浏览器后 来的版本已经解决了这个低效率问题。 </p>
<h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><p>要把一个值转换为一个字符串有两种方式。</p>
<ol>
<li>使用几乎每个值都有的<code>tostring()</code>方法。</li>
<li>使用能够将任何类型的值转换为字符串的<code>String()</code>函数</li>
</ol>
<h4 id="tostring"><a href="#tostring" class="headerlink" title="tostring()"></a>tostring()</h4><p>要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的 toString()方法（第 5章将讨论这个方法的特点）。这个方法唯一要做的就是返回相应值的字符串表现。来看下面的例子： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">11</span>; </span><br><span class="line"><span class="keyword">var</span> ageAsString = age.toString();         <span class="comment">// 字符串"11" </span></span><br><span class="line"><span class="keyword">var</span> found = <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">var</span> foundAsString = found.toString();     <span class="comment">// 字符串"true"</span></span><br></pre></td></tr></table></figure>
<p>数值、布尔值、对象和字符串值（没错，每个字符串也都有一个 toString()方法，该方法返回字 符串的一个副本）都有 toString()方法。但 null 和 undefined 值没有这个方法。 </p>
<p>多数情况下，调用 toString()方法不必传递参数。但是，在调用数值的 toString()方法时，可 以传递一个参数：输出数值的基数。默认情况下，toString()方法以十进制格式返回数值的字符串表 示。而通过传递基数，toString()可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格 式表示的字符串值。下面给出几个例子： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num.toString());         <span class="comment">// &gt;"10" </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>));        <span class="comment">// &gt;"1010" </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">8</span>));        <span class="comment">// &gt;"12" </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">10</span>));       <span class="comment">// &gt;"10" </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">16</span>));       <span class="comment">// &gt;"a"</span></span><br></pre></td></tr></table></figure>
<h4 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h4><p>在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String()，这个函数能将任何类型的值转换为字符串。String()函数遵循下列转换规则： </p>
<ul>
<li>如果值有 toString()方法，则调用该方法（没有参数）并返回相应的结果； </li>
<li>如果值是 null，则返回”null”； </li>
<li>如果值是 undefined，则返回”undefined”。 </li>
</ul>
<p>下面再看几个例子： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> value2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> value3 = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> value4;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value1));     <span class="comment">//&gt; "10" </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value2));     <span class="comment">//&gt; "true" </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value3));     <span class="comment">//&gt; "null" </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(value4));     <span class="comment">//&gt; "undefined"</span></span><br></pre></td></tr></table></figure>
<p>这里先后转换了 4 个值：数值、布尔值、null 和 undefined。数值和布尔值的转换结果与调用 toString()方法得到的结果相同。因为 null 和 undefined 没有 toString()方法，所以 String() 函数就返回了这两个值的字面量。 </p>
<blockquote>
<p>要把某个值转换为字符串，可以使用加号操作符把它与一个字符串（“”）加在一起。</p>
</blockquote>
<h2 id="3-4-7-Object类型"><a href="#3-4-7-Object类型" class="headerlink" title="3.4.7 Object类型"></a>3.4.7 Object类型</h2><p>ECMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建 的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性和（或）方法，就可以创建自定 义对象，如下所示： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p>这个语法与 Java中创建对象的语法相似；但在 ECMAScript中，如果不给构造函数传递参数，则可 以省略后面的那一对圆括号。也就是说，在像前面这个示例一样不传递参数的情况下，完全可以省略那 对圆括号（但这不是推荐的做法）： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>; <span class="comment">// 有效，但不推荐省略圆括号</span></span><br></pre></td></tr></table></figure>
<p>仅仅创建 Object 的实例并没有什么用处，但关键是要理解一个重要的思想：即在 ECMAScript中， （就像 Java 中的<code>java.lang.Object</code>对象一样）Object 类型是所有它的实例的基础。换句话说， Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。 </p>
<p>object的每个实例都具有下列属性和方法：</p>
<ul>
<li><p>constructor 保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是 Object() 。</p>
</li>
<li><p>hasOwnProperty（propertyName）: 用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（ propertyName ）必须以字符串形式指定（例如o.hasOwnProperty(“name”) ）。</p>
</li>
<li><p>isPrototypeOf（object）: 用于检查传入的对象是否是传入对象的原型（第 5 章将讨论原型）。</p>
</li>
<li><p>propertyIsEnumerable(propertyName): 用于检查给定的属性是否能够使用 for-in 语句（本章后面将会讨论）来枚举。与 hasOwnProperty() 方法一样，作为参数的属性名必须以字符串形式指定。</p>
</li>
<li><p>toLocaleString(): 返回对象的字符串表示，该字符串与执行环境的地区对应。</p>
</li>
<li><p>toString(): 返回对象的字符串表示。</p>
</li>
<li><p>valueOf(): 返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值相同。</p>
</li>
</ul>
<blockquote>
<p>从技术角度讲，ECMA-262中对象的行为不一定适用于 JavaScript中的其他对象。 浏览器环境中的对象，比如 BOM 和 DOM 中的对象，都属于宿主对象，因为它们是 由宿主实现提供和定义的。ECMA-262不负责定义宿主对象，因此宿主对象可能会也 可能不会继承 Object。</p>
</blockquote>
<h1 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5 操作符"></a>3.5 操作符</h1><p>ECMA-262 描述了一组用于操作数据值的操作符，包括算术操作符（如加号和减号）、位操作符、 关系操作符和相等操作符。ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字 符串、数字值、布尔值，甚至对象。<strong>不过，在应用于对象时，相应的操作符通常都会调用对象的 valueOf() 和（或）toString()方法，以便取得可以操作的值。</strong> </p>
<h2 id="3-5-1-一元操作符"><a href="#3-5-1-一元操作符" class="headerlink" title="3.5.1 一元操作符"></a>3.5.1 一元操作符</h2><p>只能操作一个值的操作符叫做一元操作符。一元操作符是 ECMAScript中简单的操作符。 </p>
<h3 id="递增和递减操作符"><a href="#递增和递减操作符" class="headerlink" title="递增和递减操作符"></a>递增和递减操作符</h3><p>增和递减操作符直接借鉴自 C，而且各有两个版本：</p>
<ul>
<li>前置型：变量的值在语句被求值以前改变。</li>
<li>后置型：变量的值在语句被求值之后改变。 </li>
</ul>
<h4 id="前置型"><a href="#前置型" class="headerlink" title="前置型"></a>前置型</h4><p>顾名思义，前置型应该位 于要操作的变量之前，而后置型则应该位于要操作的变量之后。因此，在使用前置递增操作符给一个数 值加 1时，要把两个加号（++）放在这个数值变量前面，如下所示： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span>; </span><br><span class="line">++age;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，前置递增操作符把 age 的值变成了 30（为 29加上了 1）。实际上，执行这个前置递 增操作与执行以下操作的效果相同： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span>; </span><br><span class="line">age = age + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。（在计算机科学领域，这种 情况通常被称作副效应。）请看下面这个例子。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span>; </span><br><span class="line"><span class="keyword">var</span> anotherAge = --age + <span class="number">2</span>; </span><br><span class="line"> </span><br><span class="line">alert(age);          <span class="comment">// 输出 28 </span></span><br><span class="line">alert(anotherAge);    <span class="comment">// 输出 30</span></span><br></pre></td></tr></table></figure>
<h4 id="后置型"><a href="#后置型" class="headerlink" title="后置型"></a>后置型</h4><p>后置型递增和递减操作符的语法不变（仍然分别是++和–），只不过要放在变量的后面而不是前面。 后置递增和递减与前置递增和递减有一个非常重要的区别，即<strong>递增和递减操作是在包含它们的语句被求 值之后才执行的</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">2</span>; </span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">20</span>; </span><br><span class="line"><span class="keyword">var</span> num3 = num1-- + num2;     <span class="comment">// 等于 22 </span></span><br><span class="line"><span class="keyword">var</span> num4 = num1 + num2;      <span class="comment">// 等于 21</span></span><br></pre></td></tr></table></figure>
<h4 id="递增和递减操作符遵循规则"><a href="#递增和递减操作符遵循规则" class="headerlink" title="递增和递减操作符遵循规则"></a>递增和递减操作符遵循规则</h4><p>所有这 4个操作符对任何值都适用，也就是它们不仅适用于整数，还可以用于字符串、布尔值、浮 点数值和对象。在应用于不同的值时，递增和递减操作符遵循下列规则。 </p>
<ul>
<li><p>在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减 1 的操作。字 符串变量变成数值变量。 </p>
</li>
<li><p>在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN（第 4章将详细讨论）。 字符串变量变成数值变量。 </p>
</li>
<li><p>在应用于布尔值 false 时，先将其转换为 0再执行加减 1的操作。布尔值变量变成数值变量。 </p>
</li>
<li><p>在应用于布尔值 true 时，先将其转换为 1再执行加减 1的操作。布尔值变量变成数值变量。 </p>
</li>
<li><p>在应用于浮点数值时，执行加减 1的操作。 </p>
</li>
<li><p>在应用于对象时，先调用对象的 valueOf()方法（第 5章将详细讨论）以取得一个可供操作的 值。然后对该值应用前述规则。如果结果是 NaN，则在调用 toString()方法后再应用前述规 则。对象变量变成数值变量。 </p>
</li>
</ul>
<p>以下示例展示了上面的一些规则： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"2"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">"z"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">s1++;     <span class="comment">// 值变成数值 3 </span></span><br><span class="line">s2++;     <span class="comment">// 值变成 NaN </span></span><br><span class="line">b++;      <span class="comment">// 值变成数值 1 </span></span><br><span class="line">f--;      <span class="comment">// 值变成 0.10000000000000009（由于浮点舍入错误所致） </span></span><br><span class="line">o--;      <span class="comment">// 值变成数值-2</span></span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一元加和减操作符主要用于基本的算术运算，也可以像前面示例所展示的一样用于转换数据类型。 </p>

    </div>

    
    
    
        
      
        <div class="reward-container">
  <div>坚持技术分享，您的支持将鼓励我继续创作！</div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block;">
        <img src="/images/wx.png" alt="田迪生 微信支付">
        <p>微信支付</p>
      </div>
        
      
      <div style="display: inline-block;">
        <img src="/images/ant.jpg" alt="田迪生 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/11/22/工具使用/利用linux-vps-ShadowsocksR搭建梯子科学上网/" rel="next" title="利用linux vps+ShadowsocksR搭建梯子科学上网">
                  <i class="fa fa-chevron-left"></i> 利用linux vps+ShadowsocksR搭建梯子科学上网
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
            </div>
          </div>
        
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#3-1-语法"><span class="nav-number">1.</span> <span class="nav-text">3.1 语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-1-区分大小写"><span class="nav-number">1.1.</span> <span class="nav-text">3.1.1 区分大小写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-2-标识符"><span class="nav-number">1.2.</span> <span class="nav-text">3.1.2 标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-3-注释"><span class="nav-number">1.3.</span> <span class="nav-text">3.1.3 注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-4-严格模式"><span class="nav-number">1.4.</span> <span class="nav-text">3.1.4 严格模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-5-语句"><span class="nav-number">1.5.</span> <span class="nav-text">3.1.5 语句</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-2-关键字和保留字"><span class="nav-number">2.</span> <span class="nav-text">3.2 关键字和保留字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-1-关键字"><span class="nav-number">2.1.</span> <span class="nav-text">3.2.1 关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-2-保留字"><span class="nav-number">2.2.</span> <span class="nav-text">3.2.2 保留字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-4-数据类型"><span class="nav-number">3.</span> <span class="nav-text">3.4 数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-1-typeof操作符"><span class="nav-number">3.1.</span> <span class="nav-text">3.4.1 typeof操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-2-Undefined类型"><span class="nav-number">3.2.</span> <span class="nav-text">3.4.2 Undefined类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-3-Null类型"><span class="nav-number">3.3.</span> <span class="nav-text">3.4.3 Null类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-4-Boolean类型"><span class="nav-number">3.4.</span> <span class="nav-text">3.4.4 Boolean类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-5-Number类型"><span class="nav-number">3.5.</span> <span class="nav-text">3.4.5 Number类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#浮点数值"><span class="nav-number">3.5.1.</span> <span class="nav-text">浮点数值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数值范围"><span class="nav-number">3.5.2.</span> <span class="nav-text">数值范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NaN"><span class="nav-number">3.5.3.</span> <span class="nav-text">NaN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数值转换"><span class="nav-number">3.5.4.</span> <span class="nav-text">数值转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Number"><span class="nav-number">3.5.4.1.</span> <span class="nav-text">Number()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#parseInt"><span class="nav-number">3.5.4.2.</span> <span class="nav-text">parseInt()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#parseFloat"><span class="nav-number">3.5.4.3.</span> <span class="nav-text">parseFloat()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-6-String类型"><span class="nav-number">3.6.</span> <span class="nav-text">3.4.6 String类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符表面量"><span class="nav-number">3.6.1.</span> <span class="nav-text">字符表面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串的特点"><span class="nav-number">3.6.2.</span> <span class="nav-text">字符串的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转换为字符串"><span class="nav-number">3.6.3.</span> <span class="nav-text">转换为字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tostring"><span class="nav-number">3.6.3.1.</span> <span class="nav-text">tostring()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String"><span class="nav-number">3.6.3.2.</span> <span class="nav-text">String()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-7-Object类型"><span class="nav-number">3.7.</span> <span class="nav-text">3.4.7 Object类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-5-操作符"><span class="nav-number">4.</span> <span class="nav-text">3.5 操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-1-一元操作符"><span class="nav-number">4.1.</span> <span class="nav-text">3.5.1 一元操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递增和递减操作符"><span class="nav-number">4.1.1.</span> <span class="nav-text">递增和递减操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#前置型"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">前置型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#后置型"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">后置型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递增和递减操作符遵循规则"><span class="nav-number">4.1.1.3.</span> <span class="nav-text">递增和递减操作符遵循规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">4.1.1.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/金凰儿.png"
      alt="田迪生">
  <p class="site-author-name" itemprop="name">田迪生</p>
  <div class="site-description" itemprop="description">田迪生的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">170</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/tianxintiandisheng" title="GitHub &rarr; https://github.com/tianxintiandisheng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="/1455701196@qq.com" title="E-Mail &rarr; 1455701196@qq.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



      </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">田迪生</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">443k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:42</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.7.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">
      
    主题 – <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.1
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
  
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>
<script src="/js/next-boot.js?v=7.4.1"></script>



  








  <script src="/js/local-search.js?v=7.4.1"></script>














  

  

  

</body>
</html>
