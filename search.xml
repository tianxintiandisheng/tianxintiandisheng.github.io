<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[太吾绘卷大型攻略]]></title>
    <url>%2F2019%2F03%2F09%2F%E5%A4%AA%E5%90%BE%E7%BB%98%E5%8D%B7%E5%A4%A7%E5%9E%8B%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[一.相枢降世-人物创建处世立场（Attitude）决定角色在世界中待人处事的方式。 1.1处事立场概述每一个角色都拥有一种处世立场。玩家可以在创建自己的角色时选择立场，在人物面板中可以查看其处世立场，立场相差越大的角色越难以相处。 立场并不只有五个孤立的取值，而是连续的数轴，创建角色时可以拖动滑块来自定义更细的倾向；在游戏内选择不符合自身立场的选项时，角色的立场值会随着移动，表现出的立场类型可能改变。 1.2处事立场的改变与然山派青琅主互动（需好感达到或超过融洽），可消耗30点地区恩义，改变主角或同道的立场。 1.3处事立场的作用玩家角色立场作用 立场选项 被索要物品 清理外道巢穴 救助入魔人 刚正 大量降低好感；若对方名誉为负，则增加名誉 地区恩义额外+1、所在地图所有城镇安定+1 被救助者入魔值清零 仁善 好感无变化，根据对方名誉增减名誉 所在地图所有城镇文化+1 加大量好感度 中庸 少量降低好感 所在地图所有城镇文化+1、安定+1 被救助者名誉置中（默默无闻） 叛逆 大量降低好感，根据对方名誉反向增减名誉 获得银钱和威望 丢下失心人不管，失心人仍在原地 唯我 大量降低好感，根据对方名誉反向增减名誉 获得新的同道；该同道固定拥有被逼屈从特性，每年好感-60 杀掉失心人且不会被寻仇 立场相同对人物与NPC的关系有促进作用，对立立场容易结仇；刚正、仁善立场在对话时不太会与NPC结仇，也容易提升好感度，但是同样也不可以作恶；中庸立场与任何立场的人都不会结仇叛逆、唯我立场，虽然自身利益方面会有收益，但是极为容易与NPC结仇，带来后续关系链的麻烦； npc立场影响 立场影响闲聊行为的结果：立场相同的角色闲聊时增加大量好感，处世立场不合的角色闲聊时会增加少量好感。 玩家在门派内寻求支持时，不同立场的角色提出的要求不尽相同 立场 对应要求 刚正 接下五招：进行切磋，获胜，或在对方使用第五个攻击功法之后仍然未被击败 仁善 在较艺中获胜 中庸 赠送对银钱(身份越高,所需银钱越多) 叛逆 关系达到喜爱/亲密（视对方身份品级而定） 唯我 在切磋中获胜]]></content>
      <categories>
        <category>游戏攻略</category>
      </categories>
      <tags>
        <tag>太吾绘卷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo快速入门]]></title>
    <url>%2F2019%2F03%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 快速开始创建一篇新文章1$ hexo new "My New Post" 详细信息: Writing 启用本地预览服务1$ hexo server 详细信息: Server 生成静态文件1$ hexo generate 详细信息: Generating 部署到远程站点1$ hexo deploy 详细信息: Deployment]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js取出事件对象中对应的值显示未定义]]></title>
    <url>%2F2018%2F08%2F30%2Fjs%E5%8F%96%E5%87%BA%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%AF%B9%E5%BA%94%E7%9A%84%E5%80%BC%E6%98%BE%E7%A4%BA%E6%9C%AA%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[问题描述:微信小程序使用data-*向事件内存储对象,js中取出对应值时显示未定义. wxml1&lt;text class=&quot;authorName db&quot; catchtap=&quot;toListDetail&quot; data-videoId=&quot;&#123;&#123;item.id&#125;&#125;&quot;&gt;&#123;&#123;item.teacher&#125;&#125;&lt;/text&gt; js1234toListDetail:function (event) &#123; let videoId = event.target.dataset.videoId; console.log(videoId);//undefined &#125; #问题出现原因:data-*书写方式： 以data-开头，多个单词由连字符-链接，连字符转成驼峰,不能有大写,大写会自动转成小写; 如data-element-type，最终在 event.currentTarget.dataset 中会将连字符转成驼峰elementType。 如data-videoId，最终在 event.currentTarget.dataset 中大写会自动转成小写 videoid。| wxml | event.currentTarget.dataset || ———— | ———— || data-element-type | elementType || data-videoId | videoid | 问题解决办法: 在组件中使用data-*定义数据，注意字母大小写. 需要使用驼峰命名的时候,以连字符拼接.]]></content>
      <categories>
        <category>微信小程序</category>
        <category>遇到的问题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序setData中键名key中使用变量]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FsetData%E4%B8%AD%E9%94%AE%E5%90%8Dkey%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[setData 函数用于将数据从逻辑层发送到视图层（异步）,同时改变对应的 this.data 的值（同步）.setData中可以传入的参数Object 以 key: value 的形式表示,将 this.data 中的 key 对应的值改变成 value。其中 key 可以以数据路径的形式给出，支持改变数组中的某一项或对象的某个属性,有时我们需要在使用变量表示key,这时应该如何操作呢. 问题描述:例一:1234binddata: function (e) &#123; var idNum = e.target.id; this.setData(&#123; idNum: e.detail.value &#125;); &#125; idNum传过去，直接是data中多了一个’idNum’的数据，不是动态的id数值. 例二:123456changeIntro:function (event) &#123; let videoArrayIndex = event.target.dataset.index; this.setData(&#123; &apos;videoArray[videoArrayIndex].introState&apos; : true &#125;) &#125; 无法改变introState的值,因为videoArrayIndex没有被解析为序列号. #解决办法: ##一. 用一个空对象暂存123var data = &#123;&#125;data[key] = value // key 可以是任何字符串this.setData(data) 使用一个中间对象暂存解决上述例二1234567changeIntro:function (event) &#123; let videoArrayIndex = event.target.dataset.index; let dataIntro = &#123;&#125;; let keyIntro = &apos;videoArray[&apos;+videoArrayIndex+&apos;].introState&apos;; dataIntro[keyIntro] = true; // key 可以是任何字符串 this.setData(dataIntro) &#125; 二. 使用es6新特性ES6 允许声明在对象字面量时使用简写语法，来初始化属性变量和函数的定义方法，并且允许在对象属性中进行计算操作：123this.setData(&#123; [key]: value &#125;) 使用es6新特性解决上述例二123456changeIntro:function (event) &#123; let videoArrayIndex = event.target.dataset.index; this.setData(&#123; [&apos;videoArray[&apos;+videoArrayIndex+&apos;].introState&apos;] : true &#125;) &#125;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序实现视图向js传递参数]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E8%A7%86%E5%9B%BE%E5%90%91js%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[有时候我们需要从小程序的视图页面向js文件传递参数,通过阅读官方文档发现可以通过向事件触发时绑定的事件对象存储数据达到效果. #实现原理如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。微信小程序中的事件对象 属性 类型 说明 type String 事件类型 timeStamp Integer 事件生成时的时间戳 target Object 触发事件的组件的一些属性值集合 currentTarget Object 当前组件的一些属性值集合 视图层上可以通过设置data-*向事件对象中存储数据,js中可以获取该事件对象event并取出其中存储的数据,从而达到视图页面向js文件传递参数的效果.事件对象详解 实例演示wxml12345 &lt;view&gt; &lt;button bindtap=&quot;showMoreText&quot; data-index=&quot;向js传递索引号&quot;&gt; 更多 &lt;/button&gt;&lt;/view&gt; js12345678Page(&#123; data: &#123; showMoreText:function (event) &#123; console.log(event); console.log(event.target.dataset.index) &#125; &#125;&#125;)]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown中使用html标签]]></title>
    <url>%2F2018%2F08%2F28%2FMarkdown%E4%B8%AD%E4%BD%BF%E7%94%A8html%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[有时候,我们会在笔记中使用一些HTML标签,但是Markdown中直接使用html标签会被解析为格式.该怎么书写，可以直接显示为html的标签呢. 12&lt;h1&gt;这是一个标题&lt;/h1&gt;//其中的&lt;h1&gt;这是一个标题&lt;/h1&gt;总是会被解析为成html标签，而不是直接显示为html标签。 问题出现原因：Markdown支持html语法，所以会对相应的标签进行解析。 问题解决办法： 使用引号把标签包起来1`&lt;h1&gt;这是一个标题&lt;/h1&gt;` &lt;h1&gt;这是一个标题&lt;/h1&gt; 使用转义字符来表示相应的标签1&amp;lt;h1&amp;gt;这是一个标题&amp;lt;/h1&amp;gt; &lt;h1&gt;这是一个标题&lt;/h1&gt; 相关工具： HTML在线转义工具]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序页面跳转]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[路由：路由在项目开发中一直是个核心点，在这里其实微信对路由的介绍很少，可见微信在路由方面经过很好的封装，也提供三个跳转方法。 三个跳转方法 wx.navigateTo(OBJECT)：保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。 wx.redirectTo(OBJECT)：关闭当前页面，跳转到应用内的某个页面。 wx.navigateBack()：关闭当前页面，回退前一页面。这三个基本上使用足够，在路由方面微信封装的很好，开发者根本不用去配置路由，往往很多框架在路由方面配置很繁琐。 问题描述：路由跳转失败出现原因：没有仔细看说明文档，需要在app。json中配置路由跳转的地址123456789101112131415&#123; &quot;pages&quot;:[ &quot;pages/personChoice/personChoice&quot;, &quot;pages/result/result&quot;, &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;:&#123; &quot;backgroundTextStyle&quot;:&quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;, &quot;navigationBarTextStyle&quot;:&quot;black&quot; &#125;&#125; 解决办法：仔细看说明文档注意:微信小程序的跳转有个坑。只能保留10个页面。历史记录有十个页面之后，跳转会失效。所以要适当的清除历史记录。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序上拉加载和下拉刷新]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%2F</url>
    <content type="text"><![CDATA[说明：要触发下拉刷新上拉加载事件，需要能够监听到事件才行 ,在需要实现下拉刷新上拉加载的页面配置对应页面xxx.json文件或者更改全局的app.json文件. 更改页面配置xxx.json文件页面配置xxx.json文件中添加以下字段12345&#123; &quot;enablePullDownRefresh&quot;:true,//是否开启下拉刷新 &quot;backgroundTextStyle&quot;:&quot;dark&quot;,//下拉背景字体、loading 图的样式，仅支持 dark/light，默认light不可见 &quot;onReachBottomDistance&quot;: 50//页面上拉触底事件触发时距页面底部距离，单位为px&#125; 自定义上拉记载触发的函数12345678910111213Page(&#123; data: &#123; &#125;, onReachBottom: function() &#123; wx.showToast(&#123; title: &apos;上拉触底&apos;, icon: &apos;success&apos;, duration: 2000 &#125;); console.log(&apos;--------上拉触底-------&apos;) &#125;&#125;);]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序将时间戳转化为几天前]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B0%86%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%87%A0%E5%A4%A9%E5%89%8D%2F</url>
    <content type="text"><![CDATA[需求描述: 文件创建时间与当前时间小于24小时,显示小时数,大于24小时,显示天数,时间戳转化为几天前，几小时前，几分钟前 代码演示wxs:1234567891011121314151617181920212223242526272829303132var getDateDiff = function (dateTimeStamp) &#123; var minute = 1000 * 60; var hour = minute * 60; var day = hour * 24; var halfamonth = day * 15; var month = day * 30; var now = getDate();//有些特殊 不能使用 new Date() var diffValue = now - dateTimeStamp; if(diffValue &lt; 0)&#123;return;&#125; var monthC =diffValue/month; var weekC =diffValue/(7*day); var dayC =diffValue/day; var hourC =diffValue/hour; var minC =diffValue/minute; if(monthC&gt;=1)&#123; result=&quot;&quot; + parseInt(monthC) + &quot;月前&quot;; &#125; else if(weekC&gt;=1)&#123; result=&quot;&quot; + parseInt(weekC) + &quot;周前&quot;; &#125; else if(dayC&gt;=1)&#123; result=&quot;&quot;+ parseInt(dayC) +&quot;天前&quot;; &#125; else if(hourC&gt;=1)&#123; result=&quot;&quot;+ parseInt(hourC) +&quot;小时前&quot;; &#125; else if(minC&gt;=1)&#123; result=&quot;&quot;+ parseInt(minC) +&quot;分钟前&quot;; &#125;else result=&quot;刚刚&quot;; return result;&#125;;//时间戳转化为几天前，几小时前，几分钟前]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>wxs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序视图层处理增强之WXS]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%86%E5%9B%BE%E5%B1%82%E5%A4%84%E7%90%86%E5%A2%9E%E5%BC%BA%E4%B9%8BWXS%2F</url>
    <content type="text"><![CDATA[WXS是专供WXML调用的有独立作用域的JS模块（不是全功能的JS，感觉有所限制）,可以在在视图层对数据进行格式化处理,起到过滤器的作用。 熟悉微信小程序开发框架的开发者，肯定会对其视图层WXML中缺失的一个功能耿耿于怀，那就是没有办法在视图层对数据进行格式化处理。比如我们从后端获取到一个包含了时间戳数据的数组，然后需要在界面上把这些日期都格式化显示为2017-01-01这种格式的日期形式，在Vue, Angular之类的前端Web框架中，一般在视图层都提供了如filter之类相应比较好用的方案。而在现有的微信小程序代码中？你能怎么做？估计我们的做法要么是在Page代码中遍历一次数组，做一下格式化；要么，只能让后端返回已经格式化好的数据了。 举个例子，在这之前，我们是没有办法在WXML的数据绑定括号1&#123;&#123;&#125;&#125; 中调用JS函数的，所以在WXML层面就缺少了进一步做数据处理的能力。下列代码是不工作的：12345678910111213&lt;!-- wxml文件 --&gt;&lt;view&gt;&#123;&#123;testFunc(name)&#125;&#125;&lt;/view&gt;// some-page.jsPage(&#123; data: &#123; name: &quot;一斤代码&quot; &#125;, testFunc: function (name) &#123; return &quot;Hello,&quot; + name &#125;&#125;) 而有了WXS之后，我们就可以实现我们预期的功能了：12345678910111213141516&lt;!-- wxml文件 --&gt;&lt;view&gt;&#123;&#123;myModule.testFunc(name)&#125;&#125;&lt;/view&gt;&lt;wxs module=&quot;myModule&quot;&gt; function testFunc(name) &#123; return &quot;Hello,&quot; + name &#125; module.exports.testFunc = testFunc&lt;/wxs&gt;// some-page.jsPage(&#123; data: &#123; name: &quot;一斤代码&quot; &#125;&#125;) WXS可以直接定义在wxml文件的标签体中，也可以写在独立的.wxs后缀名的文件中，然后在wxml文件中通过的形式引入。如要要在WXS代码中去引用其他独立.wxs文件，可以通过 require()函数来引入，基本上都是我们熟悉的方式：1234var formatUtil = require(&quot;./format-util.wxs&quot;);var now = getDate()formatUtil.formatDate(now) 所以，WXS在功能方面，并没有什么复杂的东西，唯一需要特别注意一些的，就是它的作用域了： 模块只能在定义模块的 WXML 文件中被访问到。使用 或 时， 模块不会被引入到对应的 WXML 文件中。 标签中，只能使用定义该 的 WXML 文件中定义的 模块。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>wxs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序设置过滤器将时间戳转化为日期字符串]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B0%86%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%97%A5%E6%9C%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[在微信开发小程序时，后台传入的日期数据可能是时间戳 而不是日期, 或者需要把日期转换成时间戳来做出相应的处理时,我们将用到时间戳和日期的相互转换. WXS是专供WXML调用的有独立作用域的JS模块（不是全功能的JS，感觉有所限制）,可以在在视图层对数据进行格式化处理,起到过滤器的作用。 js文件12345Page(&#123; data: &#123; timestamp: 1522117395730 &#125;&#125;) wxml文件12345678910111213&lt;wxs module=&quot;m1&quot;&gt; function format(ts) &#123; var d = getDate(ts) return [d.getFullYear(), d.getMonth()+1, d.getDate()].join(&apos;-&apos;) + &apos; &apos; + [d.getHours(), d.getMinutes(), d.getSeconds()].join(&apos;:&apos;) &#125; module.exports.format = format&lt;/wxs&gt;&lt;view&gt;&#123;&#123; timestamp &#125;&#125;&lt;/view&gt;&lt;view&gt;&#123;&#123; m1.format(timestamp) &#125;&#125;&lt;/view&gt; 注意:wxs 获取当前日期不可以使用 new Date()，而需要使用 getDate() 代替。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>wxs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述JavaScript中this的指向]]></title>
    <url>%2F2018%2F08%2F27%2F%E7%AE%80%E8%BF%B0JavaScript%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91%2F</url>
    <content type="text"><![CDATA[this的指向：本文重点介绍this作为对象方法调用，作为函数调用，作为构造函数调用，和使用apply 或 call 调用这几种，其他的情况了解即可，请牢记一点，this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的。 一.背景介绍 在面向对象的语言中（例如Java,C#等)，this含义是明确且具体的，即指向当前对象。一般在编译期绑定。而在javascript中，this是动态绑定的，它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式，并且在严格模式下也有不同，这就导致了this具备了多重含义，可以使得javascript更灵活的使用。但是，带来了灵活性的同时也会给我们初学者带来不少困惑。即使是细微的语法变化，都有可能意外改变this的值。 二.知识剖析JavaScript中函数的调用常用的有以下几种方式： 作为对象方法调用 作为函数调用 作为构造函数调用 使用apply 或 call 调用 下面我们将按照调用方式的不同，分别讨论this 的含义 1.纯粹的作为函数调用：全局函数中，this指向window 1234function a()&#123; console.log(this);&#125;a(); 2.作为对象方法的调用：当函数被作为某个对象的方法调用时，this就是那个对象 1234567891011var name = &apos;火影&apos;;var person2 = &#123; name: &apos;水影&apos;, sayName: function() &#123; console.log(this.name); &#125;&#125;;var sayNameWin = person2.sayName;person2.sayName(); //水影sayNameWin(); //火影 作为 window 的方法被调用的 3.作为构造函数调用：this指向新对象 123456function Person3(name) &#123; this.name = name; console.log(this);&#125;var person3 = new Person3(&apos;张飒&apos;);console.log(person3.name); //张飒 4.apply、call调用：this指向改变后的调用这个函数的对象12345678var person4 = &#123; name: &apos;人才&apos;&#125;;function fn() &#123; console.log(this); //Object &#123;name: &quot;人才&quot;&#125; console.log(this.name); //人才&#125;fn.apply(person4); 三.拓展思考如何能加深记忆？this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的。 四.参考文献深入浅出 JavaScript 中的 thisJavaScript中的this用法与指向如何理解 JavaScript 中的 this 关键字？ 五.更多讨论1. 如果想让一个this指向函数内部，但是它指向了全局，有什么办法让它指向函数内部？使用call方法或者apply方法给它指定this，或者把他作为对象的方法调用 2. setTimeout、setInterval中的this是指向哪里？《 javascript 高级程序设计》中写到：“超时调用的代码都是在全局执行域中执行的”。setTimeout/setInterval 执行的时候，this 默认指向 window 对象，除非手动改变 this 的指向。 3. 简单说一下this 到底有几种指向？我们重点掌握作为对象方法调用，作为函数调用，作为构造函数调用，和使用apply 或 call 调用这几种，其他的情况了解即可，]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步请求之设置请求头Content-Type]]></title>
    <url>%2F2018%2F08%2F25%2F%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E4%B9%8B%E8%AE%BE%E7%BD%AEContent-Type%2F</url>
    <content type="text"><![CDATA[什么是AJAX: 先给出结论——我们每日用到的AJAX，是通过javascript的XMLHttpRequest对象，使用HTTP请求，来直接与服务器通信。而angular的$http服务，其内部代码也是使用XMLHttpRequest对象来连接服务器。 #问题：为什么这个post请求不能成功，服务器返回码虽然是200，但它值总是不对？？？ #答案：除开请求参数，请求地址等基本错误外，还有可能有一个非常重要的原因就是请求头中的Content-Type不对。 #基础知识：HTTP，是一套网络通信规则，让我们可以通过浏览器等客户端请求和发送数据到服务器。 #每次HTTP通信需要完成7个步骤：1.建立TCP连接2.浏览器向服务器发送请求命令3.浏览器发送请求头信息4.服务器应答5.服务器发送应答头信息6.服务器向浏览器发送数据7.关闭TCP连接 进一步诠释HTTP（可以不看的部分）： 请求头声明有关浏览器和正文的一些相关信息1234567Content-Encoding:gzipContent-Language:zh-CNContent-Type:text/html; charset=utf-8Date:Wed, 11 Jan 2017 01:48:38 GMTPragma:no-cacheServer:nginx/1.4.6 (Ubuntu)Transfer-Encoding:chunked 应答码 1XX 收到请求，正在处理 2XX 成功类 3XX 重定向类 4XX 客户端错误类（著名的404，表示请求的页面不存在） 5XX 服务器错误类 响应头也包含很多服务信息12345678910111213141516Accept:application/json, text/plain, */* Accept-Encoding:gzip, deflate, sdch Accept-Language:zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4 Connection:keep-alive Cookie:JSESSIONID=aaa6A1XXqQ-QbbwfPOZGv Host:59.110.159.108 Referer:http://59.110.159.108/luoboduo/html/index.html User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36 6.服务器返回的数据（JSON/XML/….）{&quot;code&quot;:0,&quot;message&quot;:&quot;success&quot;,&quot;onlineUserCount&quot;:&quot;&quot;,&quot;classCount&quot;:308,&quot;userCount&quot;:8507} 详细讲讲Content-Type因为POST请求的协议并没有规定数据必须使用什么编码方式，而数据发送出去，还要服务器解析成功才行。服务器则通常根据请求头里的Content-Type字段来获知消息是以什么方式编码，再以对应方式解析。而有的接口服务器则不能解析某些编码方式的数据。因此需要对Content-Type进行设置。 最常见的Content-Type列出如下： ##1. application/x-www-form-urlencoded 最常见的POST提交格式，使用这个编码格式post的数据会以这种方式提交：key1=value1&amp;key2=value2。而我们的任务中所用到的大多数接口都只支持这种编码格式。 注意：jquery的POST默认就是application/x-www-form-urlencoded；而angular默认是application/json，而且若是提交的数据格式为json则需要序列化$.param(json) ##2. multipart/form-data 通常上传图片等文件会使用这种编码格式提交。 使用方法： var fd = new FormData(); fd.append(key, value); 注意：若使用jquery，Content-Type设置为false；若使用angular，Content-Type设置为undefind 3. application/json 提交JSON格式的数据 注意：若使用jquery，json数据需要字符串化JSON.stringify()；若使用angular，直接使用json即可]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>xhr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何验证程序是否完成，测试以及deBug?]]></title>
    <url>%2F2018%2F08%2F24%2F%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%90%A6%E5%AE%8C%E6%88%90%EF%BC%8C%E6%B5%8B%E8%AF%95%E4%BB%A5%E5%8F%8A%E4%BF%AE%E6%AD%A3Bug%2F</url>
    <content type="text"><![CDATA[在日常中，我们码代码都是按照需求来的，为了验证我们的工作成果是否符合项目的需求，那么验证程序是否完成、测试以及修复bug就成了我们工作中非常重要的流程。 一.背景介绍在日常中，我们码代码都是按照需求来的，为了验证我们的工作成果是否符合项目的需求，那么验证程序是否完成、测试以及修复bug就成了我们工作中非常重要的流程。 二.知识剖析 什么样的程序是完成的程序 从需求的角度看：满足用户的全部需求 从程序的角度看：代码不存在明显bug，结构明晰，逻辑通顺，有一定的优化 从UI图的角度看：较为完美的还原了UI图的设计 从后期版本维护迭代的角度看：注释完备，稳定性好，不加班的代码就是好代码 测试：测试是使用人工操作或者软件自动运行的方式来检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别的过程。软件测试的方法 按照测试范围，可以分为模块测试和整体联调 按照测试条件，可以分为正常操作情况测试和异常情况测试 按照测试的输入范围，可以分为全覆盖测试和抽样测试 按照测试方式模块测试：针对设计中的一个一个模块来进行测试的，目的是保证每个模块作为一个单元能正确运行，所以模块测试通常又被称为单元测试。在这个测试步骤中所发现的往往是编码和详细设计的错误。整体联调：测试模块间接口的正确性、各模块间的数据流和控制流是否按照设计实现其功能、以及集成后整体功能的正确性。正常操作情况测试：根据正确的操作流程对单独的模块或整体进行测试，确定被测对象可以良好运行异常情况测试：异常情况，可能会包括数据库异常，系统异常，用户异常操作等情况3.一些测试的概念成熟性：软件产品要避免由软件中错误而导致失效的能力容错性：在软件失效或者违反规定的接口的情况下，软件产品维持规定的性能级别的能力易恢复性：在发生故障的情况下，软件重建规定的性能级别并恢复受直接影响的数据的能力可靠性依从性：软件产品依附于同可靠性相关的标准、约定或规定的能力全覆盖测试：对于被测对象全面，整体，多维度的测试，受限于时间和人力成本，除非被测对象级别很高，不然不会采用这种测试方式抽样测试：针对功能及模块随机抽取被测对象 三.常见问题如何debug？ 四.解决方案老大在知乎上的回答： 确认Bug是否在本地可以重现。 确认Bug在哪一段代码中。 去除掉所有无关代码，只去调试和Bug相关的代码。 和之前正常运行的版本对比，尝试恢复到之前可以正常运行的代码。 重新写一个小Demo，确认是否可以正常运行，可以的话，移动代码到原有的代码中。 如果本地无法重现，打日志，观察线上行为。 重启服务，重启IDE，重启笔记本，重启服务器。 跟产品经理说这个Bug解决不了，花费的代价很大，不值得。 张明云在知乎上的回答：解决问题的流程：了解问题→定位问题→分析问题→解决问题→验证问题解决问题的方法(排名分先后) 借助搜索引擎：遇到有明显的异常信息，且自己并不熟悉为什么异常时，最高效的解决方法是借助搜索引擎，这里的搜索引擎一定是谷歌，不是百度；借助搜索引擎能解决工作中的大部分bug，你要相信，全世界这么多开发人员，你遇到过的大多数问题其他人也遇到过； 打印调试法：这是最笨但最有效的办法，人会说谎、断点调试可能会说谎，但日志一定不会说谎； 二分排除法：当你遇到随机问题、帮助他人解bug或者遇到自己不熟悉的代码时，通过屏蔽一部分代码，运行观察问题仍然存在，如果存在则进一步分析屏蔽一部分代码，直到定位到有问题的具体位置为止，这种方法能解决工作中的很大一部分疑难杂症； 小黄鸭调试法：当你向某个对象陈述你的思路时，往往会有意想不到的结果，哪怕对方并不是一个生物； 断点调试法：受限于效率不高以及在多线程环境下断点调试并不灵，有必要时才考虑用这种方法；通常可以使用打印调试法来代替； 线上求助：包括论坛提问、RTX和微信群提问等；不到万不得已不要用这种办法，在有限的圈子里面，你遇到的一个具体技术问题很有可能其他人并没有遇到过，多数时候问了也是白问，但有时候也可能是一种有效的方法。 五.编码实战#六.拓展思考 什么是小黄鸭调试法? 小黄鸭调试法，又称橡皮鸭调试法、黄鸭除虫法（Rubber Duck Debugging）是可在软件工程中使用的一种调试代码的方法。方法就是在程序的调试、除错或测试过程中，操作人耐心地向小黄鸭解释每一行程序的作用，以此来激发灵感与发现矛盾。 此概念是参照于一个故事。故事中程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码。许多程序员都有向别人提问及解释编程问题的经历，而目标甚至可能是完全不懂编程的人。而就在解释的过程中，程序员可能就发觉了问题的解决方案。一边阐述代码的意图，一边观察它实际上的意图并做调试，两者间的任何不协调都会变得更明显，使人更容易发现错误所在。如果没有玩具小鸭，操作人也可以向其他任何东西倾诉，比如桌上的盆栽、键盘/鼠标等。 七.参考资料软件开发流程如何提高测试覆盖率测试分析中对异常情况考虑软件异常测试断点调试老程序员解bug有那些通用套路？ 八.更多讨论Q: bug的优先级有哪几种？ critical(危险的)：是说项目中某一块功能因为这个bug而导致测试无法进行下去，此critical级别，该等级问题出现在不影响其他功能测试的情况下可以继续该版本试block是说项目中有闪退情况，崩溃情况。此为block级别，出现这种级别的问题此本停止测试 major(重要的)：是说一些功能没有实现，但是不影响使用，功能菜单缺失，但不会影响系统稳定。此为major，这种问题应该合理安排时间进行修改 normal(普通的)：是说界面等UI问题显示错误，比如字体大小，颜色，间距等问题。此类问题在测试初期较多，优先程度较低；在测试后期出现较少，应及时处理） minor(次要的)：是说界面、性能缺陷，建议类问题，不影响操作功能的执行，可以优化性能的方案等。 Q: 日志和断点的优劣？对于少量数据的检测，断点操作比较麻烦，日志很直接。但是对于比较复杂的代码，打断点能更好的理清逻辑和检查数据。 Q: 如何避免写出bug？改动代码时要考虑到对其他模块的影响；思考问题要全面，考虑到可能发生的各种情况；从其他地方找到的代码要弄清楚原理，了解这个知识点，再用到自己的项目中。 相关链接ppt地址腾讯视频地址csdn博客地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6 新特性简要总结]]></title>
    <url>%2F2018%2F08%2F15%2FES6-%E6%96%B0%E7%89%B9%E6%80%A7%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 一、 let、const 和 块级作用域let 允许创建块级作用域，ES6 推荐在函数中使用 let 定义变量，而非 var：123456var a = 2;&#123; let a = 3; console.log(a); // 3&#125;console.log(a); // 2 同样在块级作用域有效的另一个变量声明方式是 const，它可以声明一个常量。ES6 中，const 声明的常量类似于指针，它指向某个引用，也就是说这个「常量」并非一成不变的，如：123456&#123; const ARR = [5,6]; ARR.push(7); console.log(ARR); // [5,6,7] ARR = 10; // TypeError&#125; 有几个点需要注意： let 关键词声明的变量不具备变量提升（hoisting）特性 let 和 const 声明只在最靠近的一个块中（花括号内）有效 当使用常量 const 声明时，请使用大写变量，如：CAPITAL_CASING const 在声明时必须被赋值 二、箭头函数ES6 中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =&gt;，紧接着是函数体：123456var getPrice = function() &#123; return 4.55;&#125;; // Implementation with Arrow Functionvar getPrice = () =&gt; 4.55; 三、 函数参数默认值ES6 中允许你对函数参数设置默认值：(当没有传递该参数的具体值的时候，使用默认值)12let getFinalPrice = (price, tax=0.7) =&gt; price + price * tax;getFinalPrice(500); // 850 四、Spread / Rest 操作符Spread / Rest 操作符指的是 …，具体是 Spread 还是 Rest 需要看上下文语境。 当被用于迭代器中时，它是一个 Spread 操作符：123456function foo(x,y,z) &#123; console.log(x,y,z);&#125; let arr = [1,2,3];foo(...arr); // 1 2 3 当被用于函数传参时，是一个 Rest 操作符：1234function foo(...args) &#123; console.log(args);&#125;foo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5] 五、对象词法扩展ES6 允许声明在对象字面量时使用简写语法，来初始化属性变量和函数的定义方法，并且允许在对象属性中进行计算操作：12345678910111213141516171819202122232425function getCar(make, model, value) &#123; return &#123; // 简写变量 make, // 等同于 make: make model, // 等同于 model: model value, // 等同于 value: value // 属性可以使用表达式计算值 [&apos;make&apos; + make]: true, // 忽略 `function` 关键词简写对象函数 depreciate() &#123; this.value -= 2500; &#125; &#125;;&#125;let car = getCar(&apos;Barret&apos;, &apos;Lee&apos;, 40000); //car: &#123;// make: &apos;Barret&apos;,// model:&apos;Lee&apos;,// value: 40000,// makeBarret: true,// depreciate: function()// &#125; 六、二进制和八进制字面量ES6 支持二进制和八进制的字面量，通过在数字前面添加 0o 或者0O 即可将其转换为八进制值：12345let oValue = 0o10;console.log(oValue); // 8 let bValue = 0b10; // 二进制使用 `0b` 或者 `0B`console.log(bValue); // 2 七、对象和数组解构解构可以避免在对象赋值时产生中间变量：1234567891011121314151617function foo() &#123; return [1,2,3];&#125;let arr = foo(); // [1,2,3] let [a, b, c] = foo();console.log(a, b, c); // 1 2 3 function bar() &#123; return &#123; x: 4, y: 5, z: 6 &#125;;&#125;let &#123;x: x, y: y, z: z&#125; = bar();console.log(x, y, z); // 4 5 6 八、对象超类ES6 允许在对象中使用 super 方法（用于继承父级的方法）： 使用super后，必须使用Object.setPrototypeOf方法指定父级12345678910111213141516var parent = &#123; foo() &#123; console.log(&quot;Hello from the Parent&quot;); &#125;&#125; var child = &#123; foo() &#123; super.foo(); console.log(&quot;Hello from the Child&quot;); &#125;&#125; Object.setPrototypeOf(child, parent);child.foo(); // Hello from the Parent // Hello from the Child 九、模板语法和分隔符ES6 中有一种十分简洁的方法组装一堆字符串和变量。 ${ … } 用来渲染一个变量 ` 作为分隔符12let user = &apos;Barret&apos;;console.log(`Hi $&#123;user&#125;!`); // Hi Barret! 十、 for…of VS for…infor…of 用于遍历一个迭代器，如数组：123456let nicknames = [&apos;di&apos;, &apos;boo&apos;, &apos;punkeye&apos;];nicknames.size = 3;for (let nickname of nicknames) &#123; console.log(nickname);&#125;// 结果: di, boo, punkeye for…in 用来遍历对象中的属性：123456let nicknames = [&apos;di&apos;, &apos;boo&apos;, &apos;punkeye&apos;];nicknames.size = 3;for (let nickname in nicknames) &#123; console.log(nickname);&#125;Result: 0, 1, 2, size 十一、Map 和 WeakMapES6 中两种新的数据结构集：Map 和 WeakMap。事实上每个对象都可以看作是一个 Map。 Map: 键值对的键名、键值都可以为任意数据结构的对象； 一个对象由多个 key-val 对构成，在 Map 中，任何类型都可以作为对象的 key，如：1234567891011121314151617var myMap = new Map(); var keyString = &quot;a string&quot;, keyObj = &#123;&#125;, keyFunc = function () &#123;&#125;; // 设置值myMap.set(keyString, &quot;value 与 &apos;a string&apos; 关联&quot;);myMap.set(keyObj, &quot;value 与 keyObj 关联&quot;);myMap.set(keyFunc, &quot;value 与 keyFunc 关联&quot;); myMap.size; // 3 // 获取值myMap.get(keyString); // &quot;value 与 &apos;a string&apos; 关联&quot;myMap.get(keyObj); // &quot;value 与 keyObj 关联&quot;myMap.get(keyFunc); // &quot;value 与 keyFunc 关联&quot; 属性：Map.size返回Map实例成员的总数；方法：操作方法(5种)+遍历方法(4种) 操作方法 Map.set(key,value)：设置key值对应的值，如果key存在，则覆盖原有值； Map.get(key)：获取键名为key的键值； Map.has(key)：检查键名key是否存在Map实例中，返回boolean值，若存在返回true,不存在返回false; Map.delete(key)：删除键名为key的属性，返回boolean值，若删除成功返回true,失败返回false; Map.clear()：清除Map实例的所有成员，无返回值 遍历方法 Map.keys()：返回键名的遍历器 Map.values()：返回键值的遍历器 Map.entries()：返回所有成员的遍历器 Map.forEach((value,key,map)=&gt;{},thisObj)：遍历Map的所有成员 WeakMap : 键名只能为对象的Map，弱引用 WeakMap 就是一个 Map，只不过它的所有 key 都是弱引用，意思就是 WeakMap 中的东西垃圾回收时不考虑，使用它不用担心内存泄漏问题。 另一个需要注意的点是，WeakMap 的所有 key 必须是对象。它只有四个方法 delete(key),has(key),get(key) 和set(key, val)：1234567891011121314151617let w = new WeakMap();w.set(&apos;a&apos;, &apos;b&apos;); // Uncaught TypeError: Invalid value used as weak map key var o1 = &#123;&#125;, o2 = function()&#123;&#125;, o3 = window; w.set(o1, 37);w.set(o2, &quot;azerty&quot;);w.set(o3, undefined); w.get(o3); // undefined, because that is the set value w.has(o1); // truew.delete(o1);w.has(o1); // false 十二、Set 和 WeakSetSet 对象是一组不重复的值，重复的值将被忽略，值类型可以是原始类型和引用类型：Set —没有重复成员元素的数组 本质：Set本身是一个构造函数；接收一个具有iterable接口数据结构的参数，用来生成一个没有重复元素的数组； 12345let nums=new Set([1,2,3,4,3,2]);//[1,2,3,4]nums.add(2);//[1,2,3,4]nums.add(&apos;2&apos;);//[1,2,3,4,&apos;2&apos;]nums.add(&#123;&#125;);//[1,2,3,4,&apos;2&apos;,&#123;&#125;] Set添加元素时不会发生类型转换，nums.add(&#123;&#125;);//[1,2,3,4,&apos;2&apos;,&#123;&#125;,&#123;&#125;] Set添加的对象总不相等 两类8个方法：操作方法(4种）+遍历方法(4种)操作方法 Set.add(value)：向Set实例添加值value，返回Set结构本身 ; Set.delete(value)：向Set实例删除值value，返回boolean, 成功为true，失败返回false; Set.has(value)：检查Set实例是否含有值value，返回boolean，包含返回true，不包含返回false Set.clear()：清楚Set实例的所有成员，无返回值； 遍历方法 Set.keys()：返回键名的遍历器； Set.values()：返回键值的遍历器； Set.entries()：返回键值对的遍历器； Set.forEach((value,key)=&gt;{},thisObj)：使用回调函数遍历每个成员 使用场景 使用场景：数组去重、求数组的交集、并集、差集123456789101112// ①数组去重let arr=[1,2,3,4,3,2,1];let b=[...arr];//[1, 2, 3, 4, 3, 2, 1]let a=Array.from(new Set(arr));//[1,2,3,4]let c = [...new Set(arr)];//[1,2,3,4]// ②数组运算let arr1=new Set([1,2,3,4]);let arr2=new Set([3,4,5,6]);let union=new Set([...arr1,...arr2]);//[1,2,3,4,5,6]let intersect=new Set([...arr1].filter(value=&gt;b.has(value)));//[3,4]let diffrence=new Set([...arr1].filter(value=&gt;!b.has(value)));//[1,2] WeakSet—成员只能是对象的Set+ WeakSet的成员只能是对象不能是其他类型值；+ WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用； 弱引用，即当一个WeakSet实例的成员引用对象A时，当其他对象不在引用对象A，JS的垃圾回收机制便会自动回收该对象占用的内存，不考虑WeakSet实例是否还在引用；弱引用的对象随时可能消失，无法保证成员的存在，因此WeakSet相比较Set数据结构，没有clear(）方法、没有size属性、也没有遍历方法; 十三、类ES6 中有 class 语法。值得注意是，这里的 class 不是新的对象继承模型，它只是原型链的语法糖表现形式。 函数中使用 static 关键词定义构造函数的的方法和属性：类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 12345678910111213141516171819class Task &#123; constructor() &#123; console.log(&quot;task instantiated!&quot;); &#125; showId() &#123; console.log(23); &#125; static loadAll() &#123; console.log(&quot;Loading all tasks..&quot;); &#125;&#125; console.log(typeof Task); // functionlet task = new Task(); // &quot;task instantiated!&quot;task.showId(); // 23task.loadAll(); //loadAll不是一个函数Task.loadAll(); // &quot;Loading all tasks..&quot; 类中的继承和超集： 12345678910111213141516class Car &#123; constructor() &#123; console.log(&quot;Creating a new car&quot;); &#125;&#125; class Porsche extends Car &#123; constructor() &#123; super(); console.log(&quot;Creating Porsche&quot;); &#125;&#125; let c = new Porsche();// Creating a new car// Creating Porsche extends 允许一个子类继承父类，需要注意的是，子类的constructor 函数中需要执行 super() 函数。 当然，你也可以在子类方法中调用父类的方法，如super.parentMethodName()。 有几点值得注意的是： 类的声明不会提升（hoisting)，如果你要使用某个 Class，那你必须在使用之前定义它，否则会抛出一个 ReferenceError 的错误 在类中定义函数不需要使用 function 关键词 十四、SymbolES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。 12var sym = Symbol( &quot;some optional description&quot; );console.log(typeof sym); // symbol 注意，这里 Symbol 前面不能使用 new 操作符。如果它被用作一个对象的属性，那么这个属性会是不可枚举的. 十五、 PromisesES6 对 Promise 有了原生的支持，一个 Promise 是一个等待被异步执行的对象，当它执行完成后，其状态会变成 resolved 或者rejected。123456789var p = new Promise(function(resolve, reject) &#123; if (/* condition */) &#123; // fulfilled successfully resolve(/* value */); &#125; else &#123; // error, rejected reject(/* reason */); &#125;&#125;); 每一个 Promise 都有一个 .then 方法，这个方法接受两个参数，第一个是处理 resolved 状态的回调，一个是处理 rejected 状态的回调：12p.then((val) =&gt; console.log(&quot;Promise Resolved&quot;, val), (err) =&gt; console.log(&quot;Promise Rejected&quot;, err));]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[取消浏览器对页面滚动条位置的记录]]></title>
    <url>%2F2018%2F08%2F11%2F%E5%8F%96%E6%B6%88%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%E6%9D%A1%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[浏览器在导航跳转和通过 History API 创建历史记录时，都会记录当前的垂直滚动距离，在重新访问时恢复这个距离。如何取消记录当前的垂直滚动距离,使其刷新时可以回到顶部呢? 问题描述：项目提出bug，当正在浏览页面的时候点击返回首页此时页面停留在页面顶部，然后立即刷新，页面会回到刚才浏览的部分。期望：当浏览时刷新可以保存滑动条的位置但是当点击首页的时候不需要保存 问题出现原因：浏览器在导航跳转和通过 History API 创建历史记录时，都会记录当前的垂直滚动距离，在重新访问时恢复这个距离。 问题解决办法：1、初级版1234567891011$(&quot;.toIndex&quot;).click(function()&#123; if (&apos;scrollRestoration&apos; in history) &#123; history.scrollRestoration = &apos;manual&apos;; &#125;&#125;);//去除默认的滚动恢复行为var recoverAuto = function () &#123; if (&apos;scrollRestoration&apos; in history) &#123; history.scrollRestoration = &apos;auto&apos;; &#125;&#125;;setTimeout(recoverAuto,1800);//回复默认的滚动恢复行为 给返回首页添加点击事件，关闭记录当前的垂直滚动距离浏览器行为。但是这样会导致之后也无法保存滚动条的位置，所以后面加了一个定时器，在1.8s之后恢复浏览器的记录行为。缺点：如果用户在1.8s之内浏览页面并刷新，不会回到浏览位置。 2、 终极方案（从根本上解决问题，无bug）123$(&quot;.toIndex&quot;).click(function()&#123; $(&apos;body,html&apos;).scrollTop(0);&#125;);//返回首页的同时将滑动条置顶 给返回首页添加点击事件，返回首页的同时将滑动条置顶，让浏览器记录一个在顶部的历史记录。 相关知识 平常使用浏览器的后退功能时，常常会发现返回的页面滚动到了之前的位置，而不是简单的回到顶部。这是由于浏览器在导航跳转和通过 History API 创建历史记录时，都会记录当前的垂直滚动距离，在重新访问时恢复这个距离。值得一提的是，在 HTML History Spec中并没有强制要求浏览器记录与恢复滚动距离。 引入新的 API为了让开发者能够通过编程方式关闭这一浏览器行为，《浏览器恢复滚动提案》引入了新的 API：1234if (&apos;scrollRestoration&apos; in history) &#123; // 默认值为&apos;auto&apos; history.scrollRestoration = &apos;manual&apos;;&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown 配置七牛云作为图床]]></title>
    <url>%2F2018%2F07%2F31%2FMarkdown-%E9%85%8D%E7%BD%AE%E4%B8%83%E7%89%9B%E4%BA%91%E4%BD%9C%E4%B8%BA%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[Hexo在使用Markdown编辑发布博客时，经常要上传本地图片，渲染加载图片的效果很不理想。推荐使用云平台作为图床，提高编辑效率和图片效果。 一. 注册七牛云账号 七牛云注册地址 新增存储空间。注册完成之后，在资源主页中的对象存储里添加对象，如添加image 简单的上传图片，复制外链 二. 使用插件（Mpic）Mpic下载 之前我在没有发现Mpic这款软件的时候，将图片上传到七牛云存储总共分四步： 登录打开七牛云网页个人存储空间 上传图片 复制外链 粘贴到 Markdown 一张图片的上传整整用了四步，特别麻烦。直到LZ最近发现了Mpic之后，才发现，上传图片原来也能这么简单。使用Mpic，只需要将七牛云存储的账号信息配置一次(参考：如何设置七牛云存储账号？)，就可以将以上这四个步骤合为一个。同时，MPic提供了点击上传、拖曳上传、截图上传、复制上传四种上传图片的方法，更是让人感叹好的软件极大的提高了效率啊。 配置Mpic插件，获取密匙进入七牛云个人中心的密钥管理，获取AccessKey和SecretKey 三. 使用极简图床使用极简图床,关联七牛云账号]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用js或css实现瀑布流（Pinterest）布局教程]]></title>
    <url>%2F2018%2F07%2F30%2F%E4%BD%BF%E7%94%A8js%E6%88%96css%E5%AE%9E%E7%8E%B0%E7%80%91%E5%B8%83%E6%B5%81%EF%BC%88Pinterest%EF%BC%89%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[瀑布流，又称瀑布流式布局。这种布局适合于小数据块，每个数据块内容相近且没有侧重。通常，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。 瀑布流布局实例一、JS实现 代码：js实现瀑布流布局代码 demo：js实现瀑布流布局demo 二、CSS实现 Multi-columns Flexbox Grid 总结：这篇文章主要介绍了如何实现瀑布流的布局。文章简单介绍了css三种实现方案：Multi-columns、Flexbox和Grid。从上面的示例或者实现手段而言，较为友好的是Flexbox的方案。当然，随着CSS Grid特性的完善，使用Grid实现瀑布流布局将会变得更为简单和友好。以及一种相对简单的js实现方案。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏捷开发流程]]></title>
    <url>%2F2018%2F07%2F30%2F%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[敏捷软件开发，又称敏捷开发，是一种从1990年代开始逐渐引起广泛关注的一些新型软件开发方法，是一种应对快速变化的需求的一种软件开发能力。它们的具体名称、理念、过程、术语都不尽相同，相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发过程中人的作用。 一、story讲解 制作竞品分析PPT，UE全组参与。（用时：根据产品复杂度，0.5-2小时之内） 制作产品原型，交由客户看，客户没有异议之后禅道录入story 产品在禅道拆分好story，并且定义出优先级，关联需求，后续开发根据优先级进行开发 由产品讲解story，前端和后端都参与。（用时：根据产品的复杂度，1-3小时之内） 二、人员划分 新建wiki项目主页，把PPT和产品原型（HTML文件）上传到wiki 根据产品原型，按照模块划分相关负责人，前端和后端都是，并放到wiki。（由项目负责人新建） 三、定义接口文档（2-3天） 前端后端相关人员一起，对照原型，根据模块及页面大概定义出接口 一个页面中有几个接口，每个接口入参与出参是什么 后端每个模块的负责人，根据开会讨论的结果，在wiki上生成标准的接口文档 将后端做好的接口文档发给前端模块负责人过目，有问题继续修改；没问题开始后续的步骤 。 四、方案设计（1小时-1天左右，根据模块大小定义时间） 后端开发人员，根据原型以及定义的接口，做好方案设计 对有难度或者有疑点的接口，做出方案，尽量给出多个合理方案 每个方案写清楚优点缺点 五、方案评审（2-3小时） 对做出的方案设计，做方案评审，建议全体人员参与（无论做不做该项目） 六、禅道拆分（1-2小时） 相关负责人按照优先级顺序，在禅道拆分自己的任务，单个任务最多不要超过4小时，即拆分要详细 拆分一个task时，以具体写的代码为一个task，并在任务名称中写出该类/方法的名称在任务描述中写出该task的代码块具体有的功能 当拆完task后，这几个task所完成功能的代码已经过了一遍 如果有不了解的功能，在方案评审前先写出一个demo，以方便拆分task的估时 一个task用时应在0.5-2之间，最大最大4个小时 以文件上传功能为例，分成3个task task1.任务名称：公共模块-文件上传-上传文件controller的方法fileUpload任务描述：通过网页获取文件，文件判空，判断文件的归属类型（用户/教材/课时/步骤/咨询）工时：1 task2.任务名称：公共模块-文件上传-添加文件FileUtil 和FileUtilOssImpl任务描述：util处理上传的文件，判断文件类型，大小，设置文件上传的路径，返回的url工时：1.5 task3.任务名称：公共模块-文件上传-文件接口spring-fileOss.xml 配置文件任务描述：oss的文件上传， 调用的spring.xml配置文件（密匙，ID,bucket等）工时：1.5 七、开发 搭建开发服务器 开发人员根据禅道上的任务，按时完成自己的开发工作，具体体现到日报上 每天上午开10分钟左右进度会议，如果有延迟现象出现，拿出解决方案，保证项目按照禅道上的时间点完成 数据库索引(两种索引): 经常查询的，数据散列度比较高的，做一般索引，不需要建联合索引。 数据必须保持唯一的，建唯一索引。(要有文档，文档表明哪些字段要建索引。发邮件。) 八、阶段测试 每天至少发布一次代码到开发环境，并且保证发布完之后程序没问题(与开发并行) 九、性能测试和coderevivew（1天） 对每个接口做好性能测试 每个接口的响应时间不超过200ms，如果有超过的，做优化，尽量缩小到200ms内 完成codereview，根据codereview结论完成修改 十、压力测试 做好压测报告 十一、 Demodemo 发demo申请邮件，收件人包括产品、测试同学、前后端相关开发人员 主题：XX项目demo通知 内容：时间 地点 参会人员 开demo会议：主讲人：某个开发人员 会议途中产品和测试提出问题 发demo结果通知邮件(由产品同学发) demo结果 如果不通过，有哪些问题 如果不通过，召集第二次Demo会议，知道通过为止。第二次会议只需演示之前不通过的部分 测试 demo通过之后 开发人员对代码打tag（参考文档： 如何打tag 。） 开发人员部署测试环境，部署完成之后发邮件，写明域名； 交给测试人员进行测试，测试人员发送全体测试周期邮件 测试期间，如果有测试发现bug，会在禅道上面提出bug，禅道会发送邮件到各自开发人员的邮箱，开发人员要关注BUG邮件 ，及时确认BUG，及时修改 修改BUG之后，开发环境前端代码由前端同学自己部署，后端代码由后端同学自己部署 测试完成之后，测试或产品发送上线通知具体参看： 测试Bug划分及处理流程 。测试和线上环境发布流程： 测试及线上环境发布流程 。 十二、 发布测试环境、集成测试（2-3天） 禅道上建立bug，测试出bug，指派给相关人员修改 十三、发布线上环境，同时停止开发环境和测试环境十四、线上监控 错误报告]]></content>
      <tags>
        <tag>敏捷开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css常用命名规范]]></title>
    <url>%2F2018%2F07%2F29%2Fcss%E5%B8%B8%E7%94%A8%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[作为一个对代码负责的人，每次看见别人代码里混乱的命名，总是不禁心里一顿暗骂。问及写代码的人，他们的回答总是：我英文不好，不知道如何取名，都想破了脑袋。而一些QQ群里提问题的朋友截图代码，命名也是非常混乱。网上有很多人发表CSS常用命名的文章，也都挺好的，我只是一个收集者，和把自己的常用命名加上去，分享给有需要的人，希望大家以后写的代码自己看着舒服，别人维护着也舒服。 class的命名 头：header 内容：content/container 尾：footer 导航：nav navigation n.航行；航海 侧栏：sidebar 栏目：column 页面外围控制整体佈局宽度：wrapper 左右中：left right center 登录条：loginbar 标志：logo 广告：banner 页面主体：main 热点：hot 新闻：news 下载：download 子导航：subnav 菜单：menu 子菜单：submenu 搜索：search 友情链接：friendlink 页脚：footer 版权：copyright 滚动：scroll 内容：content 标签：tags 文章列表：list 提示信息：msg–message 小技巧：tips 栏目标题：title 加入：joinus 指南：guide 服务：service 注册：regsiter 状态：status 投票：vote 合作伙伴：partner id的命名页面结构 容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体佈局宽度：wrapper 左右中：left right center 导航 导航：nav 主导航：mainnav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary 功能 标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：register 搜索：search 功能区：shop 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标籤页：tab 文章列表：list 提示信息：msg 当前的: current 小技巧：tips 图标: icon 注释：note 指南：guild 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>命名规范</tag>
      </tags>
  </entry>
</search>
