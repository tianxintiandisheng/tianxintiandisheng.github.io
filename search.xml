<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[css有哪些选择器，优先级如何计算？]]></title>
    <url>%2F2019%2F10%2F07%2Fcss%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%8C%E4%BC%98%E5%85%88%E7%BA%A7%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%EF%BC%9F%2F</url>
    <content type="text"></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何进行自适应网页设计？]]></title>
    <url>%2F2019%2F10%2F07%2F%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%87%AA%E9%80%82%E5%BA%94%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[什么是自适应网页设计“自适应网页设计”的概念，什么是自适应网页设计，即可以自动识别屏幕宽度、并做出相应调整的网页设计。 如何实现自适应网页设计 允许网页宽度自动调整：在网页代码的头部加入一行viewport元标签，宽度为设备宽度，缩放比例为一。 不使用绝对宽度：可以使用百分比宽度，视窗宽度等，或者width:auto; 使用相对大小的字体：em、rem 流动布局：各个区块的位置是浮动的，不是固定不变的 图片自适应：图片自动缩放 img { max-width: 100%;} 选择加载css：自适应网页设计”的核心，就是CSS3引入的Media Query模块。它的意思就是，自动探测屏幕宽度，然后加载相应的CSS文件。 css中的@media媒体查询规则：同一个CSS文件中，也可以根据不同的屏幕分辨率，选择应用不同的CSS规则。 参考资料自适应网页设计]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[px、em、rem、%、vw、wh、vm等单位有什么区别？]]></title>
    <url>%2F2019%2F10%2F07%2Fpx%E3%80%81em%E3%80%81rem%E3%80%81-%E3%80%81vw%E3%80%81wh%E3%80%81vm%E7%AD%89%E5%8D%95%E4%BD%8D%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[px：绝对单位，页面按精确像素展示 em：相对单位，基准点为父级元素字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。 rem：相对单位，为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。 %：相对单位，相对于父级元素的百分比宽度 vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。 vm；css3单位，相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vm举个例子：浏览器高度900px，宽度1200px，取最小的浏览器高度，1 vm = 900px/100 = 9 px。]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何利用PS切图以及从UI图中获取所需信息？]]></title>
    <url>%2F2019%2F10%2F07%2F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8PS%E5%88%87%E5%9B%BE%E4%BB%A5%E5%8F%8A%E4%BB%8EUI%E5%9B%BE%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%89%80%E9%9C%80%E4%BF%A1%E6%81%AF%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[PS切图切片工具使用PS中的切片工具进行所需图片的切割，然后点击文件选项卡，选择其中存储为web所用格式即可完成ps切图。 一键切图下载一键切图工具并载入动作，用移动工具选择图层，按F2一键切图。最后选择保存为web所需格式，注意保存为png格式防止出现兼容性问题。 下载链接及教程： 前端高效开发之“一键切图” 获取UI中的信息 各部分之间的距离 文字的字体，字号颜色 背景的颜色（使用取色器） 注意事项：UI图的px和css中的px不是一个单位，一般来说UI图中大小除以2写在css里]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何将代码部署至自己的服务器？]]></title>
    <url>%2F2019%2F10%2F07%2F%E5%A6%82%E4%BD%95%E5%B0%86%E4%BB%A3%E7%A0%81%E9%83%A8%E7%BD%B2%E8%87%B3%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[1. 买一个服务器2. 下载filezilla3. 连接自己的服务器，将对应代码上传（全中文页面不再赘述）]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考2</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何配置nginx，实现在手机上查看页面？]]></title>
    <url>%2F2019%2F10%2F07%2F%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEnginx%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%9C%A8%E6%89%8B%E6%9C%BA%E4%B8%8A%E6%9F%A5%E7%9C%8B%E9%A1%B5%E9%9D%A2%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[什么是nginx？Nginx（发音同engine x）是异步框架的网页服务器，也可以用作反向代理、负载平衡器和HTTP缓存。该软件由伊戈尔·赛索耶夫创建并于2004年首次公开发布。2011年成立同名公司以提供支持。2019年3月11日，Nginx公司被F5 Networks以6.7亿美元收购。 Nginx是免费的开源软件，根据类BSD许可证的条款发布。一大部分Web服务器使用Nginx，通常作为负载均衡器。 正向代理正向代理简介一般情况下，如果没有特别说明，代理技术默认说的是正向代理技术。关于正向代理的概念如下： 正向代理(forward)是一个位于客户端【用户A】和原始服务器(origin server)【服务器B】之间的服务器【代理服务器Z】，为了从原始服务器取得内容，用户A向代理服务器Z发送一个请求并指定目标(服务器B)，然后代理服务器Z向服务器B转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。如下图 从上面的概念中，我们看出，文中所谓的正向代理就是代理服务器替代访问方【用户A】去访问目标服务器【服务器B】 ， 总结：代理服务器代替了用户A 正向代理的意义为什么要用通过代理服务器去访问服务器B，而不是用户直接访问？ 访问本无法访问的服务器B 加速访问服务器B Cache（缓存） 作用 客户端访问授权（为什么我们无法直接访问谷歌） 隐藏访问者的行踪（服务器B只知道代理服务器Z访问了它） 反向代理反向代理简介反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。 总结：代理服务器代替了服务器B 反向代理的意义 保护和隐藏原始资源服务器 用户A始终认为它访问的是原始服务器B而不是代理服务器Z，但实用际上反向代理服务器接受用户A的应答，从原始资源服务器B中取得用户A的需求资源，然后发送给用户A。由于防火墙的作用，只允许代理服务器Z访问原始资源服务器B。尽管在这个虚拟的环境下，防火墙和反向代理的共同作用保护了原始资源服务器B，但用户A并不知情。 负载均衡 当反向代理服务器不止一个的时候，我们甚至可以把它们做成集群，当更多的用户访问资源服务器B的时候，让不同的代理服务器Z（x）去应答不同的用户，然后发送不同用户需要的资源。 当然反向代理服务器像正向代理服务器一样拥有CACHE的作用，它可以缓存原始资源服务器B的资源，而不是每次都要向原始资源服务器B请求数据，特别是一些静态的数据，比如图片和文件，如果这些反向代理服务器能够做到和用户X来自同一个网络，那么用户X访问反向代理服务器X，就会得到很高质量的速度。这正是CDN技术的核心。 如何配置nginx，实现在手机上查看页面？Nginx的配置文件是文件夹中的conf文件下的nginx.conf，其实配置文件默认不修改也是可有用的； 如果你通过浏览器输入localhost出现的页面即为文件夹下HTML文件中的index.html；所以你可以将你想要检测的产品放到HTML文件夹中，并将原本的index.html文件给删了，这个时候打开网页输入localhost，使用ctrl+F5清下浏览器缓存即出现你产品中的index.html(产品的首页都会命名为index.html）页面，然后进行一系列测试看看是否OK； 如果要使用自己文件夹中的文件测试，需要更改Nginx的配置文件是文件夹中的conf文件下的nginx.conf，修改三处root地址为自己的文件夹所在地址，第一处改为 D:\home\www，第二处改为 /home/www,第三处改为/home/www。 注意事项： 左斜杠/与右斜杠\的区别不要打错了！ 参考资料 图解正向代理、反向代理、透明代理 维基百科]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考2</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何利用github搭建自己的个人网站？]]></title>
    <url>%2F2019%2F10%2F07%2F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[使用github搭建个人网站 在github上搭建网站 即username.github.io（username是你的github用户名） 把自己的域名（如zhangsan.com）绑定到username.github.io上 具体操作：如何用github搭建自己的个人网站 用Hexo+Github 搭建个人网站 搭建环境准备（包括node.js和git环境，gitHub账户的配置） 安装Hexo 配置Hexo 怎样将Hexo与github page 联系起来 怎样发布文章 主题 推荐 主题Net的简单配置 添加sitemap和feed插件 添加404 公益页面 具体操作：手把手教你用Hexo+Github 搭建属于自己的博客]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考2</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[svn和git有什么区别?]]></title>
    <url>%2F2019%2F10%2F07%2Fsvn%E5%92%8Cgit%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[svn与git简介SVN （集中式版本控制系统）SVN是Subversion的简称，是一个开放源代码的版本控制系统,支持大多数常见的操作系统。作为一个开源的版本控制系统,Subversion管理着随时间改变的数据。这些数据放置在一个中央资料档案库(repository)中。这个档案库很像一个普通的文件服务器,不过它会记住每一次文件的变动。这样你就可以把档案恢复到旧的版本,或是浏览文件的变动历史。Subversion是一个通用的系统,可用来管理任何类型的文件,其中包括了程序源码。 工作流程集中式管理的工作流程如下图： 集中式代码管理的核心是服务器，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如果脱离了服务器，开发者基本上可以说是无法工作的。下面举例说明： 开始新一天的工作： 从服务器下载项目组最新代码。 进入自己的分支，进行工作，每隔一个小时向服务器自己的分支提交一次代码（很多人都有这个习惯。因为有时候自己对代码改来改去，最后又想还原到前一个小时的版本，或者看看前一个小时自己修改了哪些代码，就需要这样做了）。 下班时间快到了，把自己的分支合并到服务器主分支上，一天的工作完成，并反映给服务器。 SVN属于集中化的版本控制系统​ 这种做法带来了许多好处，特别是相较于老式的本地VCS来说。现在，每个人都可以一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限。事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。若是宕机一小时，那么在这一小时内，谁都无法提交更新、还原、对比等，也就无法协同工作。如果中央服务器的磁盘发生故障，并且没做过备份或者备份得不够及时的话，还会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，被客户端提取出来的某些快照数据除外，但这样的话依然是个问题，你不能保证所有的数据都已经有人提取出来。Subversion原理上只关心文件内容的具体差异。每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容。 Subversion的特点 每个版本库有唯一的URL（官方地址），每个用户都从这个地址获取代码和数据； 获取代码的更新，也只能连接到这个唯一的版本库，同步以取得最新数据； 提交必须有网络连接（非本地版本库）； 提交需要授权，如果没有写权限，提交会失败； 提交并非每次都能够成功。如果有其他人先于你提交，会提示“改动基于过时的版本，先更新再提交”… 诸如此类； 冲突解决是一个提交速度的竞赛：手快者，先提交，平安无事；手慢者，后提交，可能遇到麻烦的冲突解决。 GIT（分布式版本控制系统）Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目 Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库. 工作流程下图是经典的git开发过程。 Git的功能特性从一般开发者的角度来看，git有以下功能： 从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上。 在自己的机器上根据不同的开发目的，创建分支，修改代码。 在单机上自己创建的分支上提交代码。 在单机上合并分支。 把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。 生成补丁（patch），把补丁发送给主开发者。 看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。 一般开发者之间解决冲突的方法，开发者之间可以使用pull 命令解决冲突，解决完冲突之后再向主开发者提交补丁。 从主开发者的角度（假设主开发者不用开发代码）看，git有以下功能： 查看邮件或者通过其它方式查看一般开发者的提交状态。 打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源项目，还要决定哪些补丁有用，哪些不用）。 向公共服务器提交结果，然后通知所有开发人员。 Git属于分布式的版本控制系统​ 自2005年诞生于以来，Git日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。它的速度飞快，极其适合管理大项目，它还有着令人难以置信的非线性分支管理系统，可以应付各种复杂的项目开发需求。 与SVN不同，Git记录版本历史只关心文件数据的整体是否发生变化。Git并不保存文件内容前后变化的差异数据。实际上，Git更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git不会再次保存，而只对上次保存的快照作一连接。 Git特点 Git中每个克隆(clone)的版本库都是平等的。你可以从任何一个版本库的克隆来创建属于你自己的版本库，同时你的版本库也可以作为源提供给他人，只要你愿意。 Git的每一次提取操作，实际上都是一次对代码仓库的完整备份。提交完全在本地完成，无须别人给你授权，你的版本库你作主，并且提交总是会成功。 甚至基于旧版本的改动也可以成功提交，提交会基于旧的版本创建一个新的分支。 Git的提交不会被打断，直到你的工作完全满意了，PUSH给他人或者他人PULL你的版本库，合并会发生在PULL和PUSH过程中，不能自动解决的冲突会提示您手工完成。 冲突解决不再像是SVN一样的提交竞赛，而是在需要的时候才进行合并和冲突解决。 svn和git的区别 SVN属于集中化的版本控制系统，有个不太精确的比喻:SVN = 版本控制+ 备份服务器SVN使用起来有点像是档案仓库的感觉，支持并行读写文件，支持代码的版本化管理，功能包括取出、导入、更新、分支、改名、还原、合并等。 Git是一个分布式版本控制系统，操作命令包括：clone，pull，push,branch ,merge ,push,rebase，Git擅长的是程序代码的版本化管理。 GIT跟SVN一样有自己的集中式版本库或服务器。但，GIT更倾向于被使用于分布式模式，也就是每个开发人员从中心版本库/服务器上chect out代码后会在自己的机器上克隆一个自己的版本库。 可以这样说，如果你被困在一个不能连接网络的地方时，就像在飞机上，地下室，电梯里等，你仍然能够提交文件，查看历史版本记录，创建项目分支，等。对一些人来说，这好像没多大用处，但当你突然遇到没有网络的环境时，这个将解决你的大麻烦。 GIT把内容按元数据方式存储，而SVN是按文件所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。 如果你把.git目录的体积大小跟.svn比较，你会发现它们差距很大。因为,.git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。 分支在SVN中一点不特别，就是版本库中的另外的一个目录。如果你想知道是否合并了一个分支，你需要手工运行像这样的命令svn propget svn:mergeinfo，来确认代码是否被合并。 然而，处理GIT的分支却是相当的简单和有趣。你可以从同一个工作目录下快速的在几个分支间切换。你很容易发现未被合并的分支，你能简单而快捷的合并这些文件。 GIT没有一个全局的版本号，而SVN有目前为止这是跟SVN相比GIT缺少的最大的一个特征。你也知道，SVN的版本号实际是任何一个相应时间的源代码快照。我认为它是从CVS进化到SVN的最大的一个突破。因为GIT和SVN从概念上就不同，我不知道GIT里是什么特征与之对应。如果你有任何的线索，请在评论里奉献出来与大家共享。 GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 svn和git的优缺点SVN 的优缺点​ SVN对中文支持好，操作简单，使用没有难度，美工人员，产品人员，测试人员，实施人员都可轻松上手。使用界面统一，功能完善，操作方便。 Git的优缺点​ 对程序源代码进行差异化的版本管理，代码库占极少的空间。易于代码的分支化管理。不支持中文，图形界面支持差，使用难度大。不易推广。 svn和git适用范围的不同 适用对象不同。Git适用于参与开源项目的开发者。他们由于水平高，更在乎的是效率而不是易用性。SVN则不同，它适合普通的公司开发团队。使用起来更加容易。 使用的场合不同。Git适用于通过Internet，有多个开发角色的单个项目开发，SVN适合企业内部由项目经理统一协调的多个并行项目的开发。 权限管理策略不同。Git没有严格的权限管理控制，只要有帐号，就可以导出、导入代码，甚至执行回退操作。SVN则有严格的权限管理，可以按组、按个人进行针对某个子目录的权限控制。区分读、写权限。更严格的，不支持回退操作。保证代码永远可以追踪。 分支(branch)的使用范围不一样。Git中，你只能针对整个仓库作branch,而且一旦删除，便无法恢复。而SVN中，branch可以针对任何子目录，它本质上是一个拷贝操作。所以，可以建立非常多、层次性的branch,并且，在不需要时将其删除，而以后需要时只要checkout老的SVN版本就可以了。 基于第三点，Git适用于单纯的软件项目，典型的就是一些开源项目，比如Linux内核、busybox等。相反，SVN擅长多项目管理。比如，你可以在一个SVN仓库中存放一个手机项目的bsp/设计文档/文件系统/应用程序/自动化编译脚本，或者在一个SVN中存放5款手机项目的文件系统。git中必须建立n(项目数)*m（组件数）个仓库。SVN中只需要最多n或者m个就可以了。 Git使用128位ID作为版本号，而且checkout时要注明是哪个branch,而SVN使用一个递增的序列号作为全局唯一的版本号，更加简明易懂。虽然可以使用gittag来建立一些文字化的别名，但是毕竟那只是针对特殊版本。 可跟踪性，git的典型开发过程为：建立分支，进行开发，提交到本地master，删除分支。这样做的后果是以前的修改细节会丢失。而在SVN下做同样的事情，不会丢失任何细节。这里是一个有趣的链接，表明了git下典型的工作方式：（以master为核心，不断创建新branch,删除旧branch) 局部更新，局部还原。SVN由于是在每个文件夹建立一个.svn文件夹来实现管理，所以可以很简单实现局部更新或者还原。假如你只希望更新某些部分，则svn可以很好实现。同时代码写错了，同时可以很好实现局部还原，当然git也可以通过历史版本还原，但是无法简单地实现局部还原。 SVN 和 Git 哪个更适用于项目管理？​ 首先说一下，我是一个研发团队的项目经理，SVN和Git我都用过，SVN更适用于项目管理， Git仅适用于代码管理。 ​ 一个研发队伍的成员正常包括：需求分析、设计、美工、程序员、测试、实施、运维，每个成员在工作中都有产出物， 包括了文档、设计代码、程序代码，这些都需要按项目集中进行管理的。SVN能清楚的按目录进行分类管理， 使项目组的管理处于有序高效的状态。 总结 总之，公司的开发团队在进行的项目开发管理时，svn是更好的选择，团队成员共同维护公司的中心版本。 若是开源项目，则git更加适合，每个人都可以维护自己专属的版本，同时有github开源社区支持。 参考和转载伯乐在线:http://blog.jobbole.com/31444/ 百度百科:http://baike.baidu.com marko39:http://jingyan.baidu.com/article/676629976401a154d51b8430.html 码迷网:http://www.mamicode.com/info-detail-107111.htm 百度百科:http://baike.baidu.com marko39:http://jingyan.baidu.com/article/676629976401a154d51b8430.html 码迷网:http://www.mamicode.com/info-detail-107111.htm]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考2</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何使用git将代码上传至github?]]></title>
    <url>%2F2019%2F10%2F07%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8git%E5%B0%86%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E8%87%B3github%2F</url>
    <content type="text"><![CDATA[代码开发在大多数情况下不是一个人的工作，那么不同人之间如何统一代码共同进行项目开发呢。git 是一款分布式版本控制系统，本文简要介绍了git的基本应用。 git是什么？Git是一款分布式版本控制系统 github是什么？GitHub是一款免费的远程仓库 如何使用git将代码上传至github？关于如何安装git，如何使用git将代码上传至github，廖雪峰的教程已经相当完善且浅显易懂了，我在此不再赘述。 廖雪峰的git教程]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考2</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何用TortoiseSVN将项目代码提交到SVN?]]></title>
    <url>%2F2019%2F10%2F07%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8svn%E5%B0%86%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E8%87%B3github%2F</url>
    <content type="text"><![CDATA[代码开发在大多数情况下不是一个人的工作，那么不同人之间如何统一代码共同进行项目开发呢。Subversion 是一种跨平台的开源版本控制系统，本文简要介绍了svn的基本应用。 目录 导引 安装Subversionn 安装TortoiseSVN 一步步地操作 设置全局忽略文件类型(此步骤为可选)步骤 创建版本库Repository数据库 创建工作目录 - 将你的项目与数据库连接起来 添加忽略 注意事项 参考资料 导引 到目前有很多关于Subversion (SVN) 和 TortoiseSVN的优秀书籍和教程。其中有部分在本文的参考资料区有列出。这篇教程无疑是站在巨人的肩膀上。它只覆盖了subversion (SVN)有限的一部分功能。 然而我希望此文能简化你对SVN的认识。 Subversion 是一种跨平台的开源版本控制系统 (http://subversion.tigris.org/). 它由版本数据库 (FSFS 或 BDB) 和一些命令行工具组成。目前有各种各样的SVN前端工具。 Subversion是为多人参与的项目专门设计的。 但它也可用于管理个人项目。 此文仅限于基于Windows的本地SVN环境(未单独配置远程的服务器)。 安装Subversion打开Tigris.org网站的下载区，选择 开源代码软件工程工具Subversion (http://subversion.tigris.org/)。 Windows下最新的命令行版Subversion的安装文件和库都能在http://www.open.collab.net/downloads/subversion/下载到。下载安装包。SVN的默认安装目录为C:\Program Files\Subversion，当然你也可以修改磁盘路径。 现在你就可以开始使用SVN了。 如果你不习惯使用命令行工具，那你有必要安装一个你觉得合适的GUI前端。 安装TortoiseSVNTortoiseSVN是一种Subversion客户端, Windows下它是一个命令行扩展, Windows资源管理器的一个插件(http://tortoisesvn.tigris.org/)。 最新版本可以在这下载到 http://tortoisesvn.sourceforge.net/downloads. 截止到2015.12.18的最新版本为：TortoiseSVN-1.9.2.26806-x64-svn-1.9.2.msi，如果需要切换语言，还可以在官网上下载相应语言包。 如果你电脑安装的Windows是32位的请选择32位的TortoiseSVN安装包，如果你电脑安装的Windows是x64的请选择x64的TortoiseSVN安装包。 下载区域的另一个文件TortoiseSVN-xxx-xxx.md5, 是安装时不需要的。它包含安装包的验证编号checksum，该验证编号能有效验证你是否下载到了合适的安装包 (且它没有损坏)。 你可以下载程序HashFile (http://www.shokhirev.com/nikolai/programs/progmisc.html) 来验证下载到的安装包的 MD5 哈希值 (checksum). 该验证编号必须和TortoiseSVN-xxx-xxx.md5文件上的信息完全一致。 这个安装也是直接的，同意默认设置即可。 唯一有趣的是ASP.Net hack. 默认情况下, SVN 使用 .svn 工作目录 (正如Linux下隐藏文件的命名风格)。这使得 微软 ASP.Net 和 the hack 强制 SVN 去使用 _svn 作为工作目录。 如果你要使用Subversion对ASP.Net项目进行版本控制，请不要安装ASP.Net hack这一项。 注： 安装完TortoiseSVN后，你的Windows 资源管理器的主目录上会出现下图所示的新的按钮： 同时这些新增按钮也会添加到 (通过鼠标右键单击激活) 的上下文菜单中。 一步步地操作目前有很多Subversion管理方式(参看手册). 现在我们主要考虑如下主要的情形: 你有一个现有的项目，你想将它加入版本控制。 这是你本地电脑上的个人项目。 在这种情形下你不应该会担心安全性和开启一个subversion服务器。 假设你的项目驻放在 C:\Projects\MyProject 路径下，它包含如下文件，或许还有些子文件夹： 步骤0 (可选). 设置全局忽略文件类型。你可能不想跟踪临时文件 或 某些其他格式的文件。鼠标右击任意一个文件夹，然后打开TortoiseSVN的Settings： 当然你也可以鼠标右击文件， 打开Windows资源管理器主目录中的TortoiseSVN/Settings。“General” -&gt; “Subversion”处，你可以列出各种各样的文件类型，并使用空格隔开 (比如上图中示例的 *.bak *.~*). 注意到这个设置会对所有的工作目录有效。参看手册的5.25可了解更多的设置。 步骤1.创建版本库Repository。在你的硬盘上为你的项目创建版本库的目录, 比如 C:\SVN. 在它里面创建一个空的子目录 \MyProject. 鼠标右键点击MyProject，并选择TortoiseSVN -&gt; 在此创建版本库: 选择默认”原生文件系统”(FSFS)选项，并单击OK按钮： 这一步将 C:\SVN\MyProject 转化为含有如下内容的版本库： 到目前为止，它还是一个空的版本库，虽然Subversion已经创建了几个目录和文件 ! 我们需要将我们的项目文件中需要进行版本控制的文件填充进去并将它链接到我们的工作项目的目录。这些操作中可能会有几个和大家的习惯操作不一样、新的操作。 步骤2. 导入初始化。 在你的磁盘的某处 (比如 在 C:\tmp) 创建一个目录 (比如 \new) ，含有如下3个子目录： 123C:\tmp\new\branches C:\tmp\new\tags C:\tmp\new\trunk 相应的文件结构为： 为了能用更多高级的项目管理功能，这个结构是必须的, 如果事先创建它也不会带来什么损害。 有些手册首推先导入此结构到版本库，然后向里面添加项目。我推荐使用如下的快捷方式： 备份你的项目文件 (比如 C:\Projects\MyProject), 以防万一. 删除所有不在全局忽略文件列表中的不需要进行版本控制的文件。 将 文件夹 \MyProject 中需要进行版本控制的内容 移动 进 trunk 子目录 (C:\tmp\new\trunk). 我们之后无论如何都将会需要一个空的文件夹。 将目录”new”导入Import到版本库 (选择”new”，右键依次单击TortoiseSVN-&gt;Import)： URL 选择 file:///C:/SVN/Myproject (左斜杠”/“ !): “Import finished” 消息出现时，表明 C:\tmp\new\下的所有文件及子文件夹都已成功导入版本库 : 不需要担心”tmp\new” 消息, 只要验证哪些文件真正地导入到了版本库中即可。 书表右键单击 C:\SVN\MyProject ，然后打开 TortoiseSVN -&gt; Repo-browser(版本库浏览器)： 导航 至 file///C:/SVN/MyProject/trunk: 注意到全局忽略列表的文件都没被导入。 并且也没有 ‘C:\tmp\new’ 目录的痕迹了， ‘C:\tmp\new’ 目录再没有什么用处了，可以删掉。 步骤3. 创建工作目录 - 将你的项目与数据库连接起来.现在你已经成功增加了你对所有需要进行版本控制的文件添加了版本控制，并且当前的空目录 C:\Projects\MyProject (回忆一下, 我们之前已将改目录中的所有文件 移动 到了 目录 C:\tmp\new\trunk 中，对么?). “为了让你的双手移动文件的这个行为获得”赞美”, 完全得到批准, 并且完全导入Subversion目录, 你需要从版本库中对它进行检出Checkout” . 书表右击 C:\Projects\MyProject 文件夹，并选择 “SVN Checkout”(SVN 检出): 设置 URL 为 file:///C:/SVN/MyProject/trunk ，并设置检出目录为： C:\Projects\MyProject 点击OK. 会提示”Checkout (检出) has finished”： “赞美” 以”对勾Check”小图标的形式反映在你的项目目录和里面所有的文件(和所有的子目录)上。 步骤4.添加忽略的文件在资源管理器中，右键一个未加入版本控制文件或目录，并从弹出菜单选择TortoiseSVN →Add to Ignore List，会出现一个子菜单，允许你仅选择该文件或者所有具有相同后缀的文件。 如果你想从忽略列表中移除一个或多个条目，右击这些条目，选择TortoiseSVN →从忽略列表删除。 几点注意事项 提交 (checking in) 你对版本库的变更: 右击鼠标，然后选择 “SVN Commit”(SVN提交)添加文件到版本库。 除了参考书籍 [4] 和 [5], 我也推荐 Charlie Calvert 的文章 [6]. 如果你使用 Lavasoft Ad-Aware, 不要删除可以忽略的对象: 这一步会删除注册表中的图标设置 ! 祝开开心心 使用Subversion版本控制 ! 这是一个两步的过程: 先右击选中的文件，然后右键依次选择 “TortoiseSVN”-&gt;”Add” 先右击选中的文件，然后右键依次选择 “TortoiseSVN”-&gt;”SVN Commit” 参考资料如何用TortoiseSVN将项目代码提交到SVN 原作者: Bravo Yeung公众号: dotNET匠人]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考2</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Adobe Photoshop CC ps 2019中文版Win/Mac破解教程]]></title>
    <url>%2F2019%2F10%2F07%2FPS%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B2019%2F</url>
    <content type="text"><![CDATA[使用破解补丁（Win/Mac通用） 下载原版软件Adobe Creative Cloud平台下载正版渠道的Photoshop CC 2019（即V20版本） 下载破解软件ZII目前可以破解的软件： 123456789101112131415161718Adobe Acrobat DC 19.x (universal amtlib)Adobe After Effects CC 2019 v16.1 – 16.1.3Adobe Animate CC 2019 v19.2 – 19.2.1Adobe Audition CC 2019 v12.1 – 12.1.4Adobe Bridge CC 2019 v9.0.3 – 9.1Adobe Character Animator CC 2019 v2.1 – 2.1.1Adobe Dimension CC v2.3Adobe Dreamweaver CC 2019 v19.1 – 19.2.1Adobe Illustrator CC 2019 v23.0.3 – 23.1Adobe InCopy CC 2019 v14.0.2Adobe Indesign CC 2019 v14.0.2 – 14.0.3.433Adobe Lightroom Classic v8.2.1 – 8.4.1Adobe Media Encoder CC 2019 v13.1 – 13.1.5Adobe Photoshop CC 2019 v20.0.4 – 20.0.6Adobe Prelude CC 2019 v8.1 – 8.1.1Adobe Premiere Pro CC 2019 v13.1 – 13.1.5Adobe Premiere Rush CC v1.1 – 1.2.5Adobe XD v21.0.12.11 – 22.5.12.1 Adobe CC 2019 Win/Mac通用破解补丁 Zii v4.4.4 + GenP v1.5.6.2 直接下载破解版软件（仅win可用）Adobe Photoshop CC 2019 v20.0.6 Win/Mac 中文/英文/多语言破解版]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[太吾绘卷大型攻略]]></title>
    <url>%2F2019%2F03%2F09%2F%E5%A4%AA%E5%90%BE%E7%BB%98%E5%8D%B7%E5%A4%A7%E5%9E%8B%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[摘要: 本攻略以太吾绘卷人物创建到人物死亡的顺序介绍了游戏的基本机制与玩法,旨在帮助初次体验太吾绘卷的玩家迅速融入游戏谱写属于自己的江湖绘卷. 关键词: 太吾绘卷 游戏机制 基本玩法 游戏攻略 《太吾绘卷》是一款以神话和武侠为题材的独立游戏。玩家将扮演“太吾氏传人”，在以古代中国为背景的架空世界中，通过一代又一代传人的努力和牺牲，最终击败强大的宿敌，决定人世的命运。 游戏采取了类似沙盒游戏的开放世界系统。玩家创建的每一个“太吾世界”，都将是独一无二的随机地图，以及完全随机生成的NPC和敌人，玩家可从15个门派和几乎所有NPC人物中学习武艺和技能。另外，该游戏的NPC之间也有着复杂的关系，玩家可以与他们结成各种各样的关系，甚至直接决定NPC的生死。除传统RPG玩法外《太吾绘卷》还融合了许多不同的玩法，如Roguelike、斗蟋蟀以及建造、经营、管理等。 目前《太吾绘卷》还处于开发阶段,游戏中基本没有对新手的引导以及对玩法机制的解释,导致游戏过于硬核.不便于新手玩家体验游戏,本攻略以太吾绘卷人物创建到人物死亡的顺序介绍了游戏的基本机制与玩法,旨在帮助初次体验太吾绘卷的玩家迅速融入游戏谱写属于自己的江湖绘卷. 一.相枢降世入轮回1 人物创建1.1处事立场1.1.1处事立场概述简易总结: 新手建议选择中庸或者仁善,以便获得更好的游戏体验. 处世立场（Attitude）决定角色在世界中待人处事的方式。 每一个角色都拥有一种处世立场。玩家可以在创建自己的角色时选择立场，在人物面板中可以查看其处世立场，立场相差越大的角色越难以相处. 立场并不只有五个孤立的取值，而是连续的数轴，创建角色时可以拖动滑块来自定义更细的倾向；在游戏内选择不符合自身立场的选项时，角色的立场值会随着移动，表现出的立场类型可能改变. 1.1.2处事立场的改变与然山派青琅主互动（需好感达到或超过融洽）,可消耗30点地区恩义,改变主角或同道的立场. 1.1.3处事立场的作用玩家角色立场作用 立场选项 被索要物品 清理外道巢穴 救助入魔人 刚正 大量降低好感；若对方名誉为负，则增加名誉 地区恩义额外+1、所在地图所有城镇安定+1 被救助者入魔值清零 仁善 好感无变化，根据对方名誉增减名誉 所在地图所有城镇文化+1 加大量好感度 中庸 少量降低好感 所在地图所有城镇文化+1、安定+1 被救助者名誉置中（默默无闻） 叛逆 大量降低好感，根据对方名誉反向增减名誉 获得银钱和威望 丢下失心人不管，失心人仍在原地 唯我 大量降低好感，根据对方名誉反向增减名誉 获得新的同道；该同道固定拥有被逼屈从特性，每年好感-60 杀掉失心人且不会被寻仇 立场相同对人物与NPC的关系有促进作用，对立立场容易结仇；刚正、仁善立场在对话时不太会与NPC结仇，也容易提升好感度，但是同样也不可以作恶；中庸立场与任何立场的人都不会结仇叛逆、唯我立场，虽然自身利益方面会有收益，但是极为容易与NPC结仇，带来后续关系链的麻烦； npc立场影响 立场影响闲聊行为的结果：立场相同的角色闲聊时增加大量好感，处世立场不合的角色闲聊时会增加少量好感。 玩家在门派内寻求支持时，不同立场的角色提出的要求不尽相同 立场 对应要求 刚正 接下五招：进行切磋，获胜，或在对方使用第五个攻击功法之后仍然未被击败 仁善 在较艺中获胜 中庸 赠送对银钱(身份越高,所需银钱越多) 叛逆 关系达到喜爱/亲密（视对方身份品级而定） 唯我 在切磋中获胜 1.2 外表相貌1.2.1 外表相貌概述简易总结: 五官选择后三分之一选项,善用sl,获取龙姿/凤仪以及以上的相貌. 只有第一代太吾可以选择自己的相貌,小孩的五官部件在爸妈的对应器官之间随机。 所以使用修改器的也会按照基本法. ####1.2.2 外表相貌与魅力值的关系 魅力与长相有关，准确说跟眼睛、鼻子、嘴巴、眉毛、特征5个五官部件有关，跟头发无关。 每种五官的所有选项都被分为三类，丑，中和美。每个器官按照等级有不同评分。按照五官序号的从小到大，前1/3为丑，中间1/3为中等，后1/3为美。如下表: 按照评分所在区间，魅力值会在对应的区间内随机产生。最高档范围是500-900。也即[出众]～[天人]。其中(在无额外特质魅力加成情况下)随机到天人的概率为1/400。如下表： 本攻略并非原创,NGA-UID:157403- 魅力捏脸手册 {09/30 更新：补充少量有关生孩子的机制} 1.2.3外表相貌的作用 外表相貌在太吾绘卷中会影响游戏中的人物对你的初始好感度 外表相貌会影响某些功法的特殊效果eg: 璇女派九品绝技正练-魅力越高,敌方攻速越慢 1.3 出生特质 角色进入游戏后的属性资质均为一个范围内随机。 角色拥有总共最多10点特质点数可分配在经历、财富、技艺三大分支，帮助角色获得某些方面的优势。 简易总结: 如果追求资质高突破阅读容易可以主技艺；如果追求经营可以主财富；如果追求属性可以主经历；如果你追求后期完美无缺，那么白蛇和盛世的效果是不能依靠反复投胎刷档和后期努力得到的。 1.4 出生地区本选项会影响玩家所在太吾村的地点，并根据出生地区门派特定，会略微影响人物属性。 建议在此处选择你想优先拜入的门派，查看好各个门派的功法及其需求，规划好角色学武路线，好让出身特质和之后的资质对话中让角色获得正确的增益。 出身地对人物属性加成的具体影响, 有关创建人物[太吾绘卷吧]_百度贴吧 1.5 出生时节简要总结:新手建议选择处暑出生,方便读书. 太吾绘卷,中出生在不同的时节会获得不同的属性天赋,具体加成见下表: 2 人物特性简要总结:善用sl,获得天元一气/绝世奇才/良材美玉特性 2.1人物特性概述 人物会随机获得各种特性。 人物特性栏显示的为当前人物的特性，蓝色为正面特性，红色为负面特性，白色为中立特性。每个特性在鼠标放置上方之后会显示详细说明。 特性中剑图标在战斗中会为队友提供攻击方面受益，盾图标会在战斗中提供防御方面收益，圆形图标会在战前提供计略。 某些特性可以遗传,此方面内容将在太吾遗传学中详细说明,此处不再赘述. 2.2特性的改变 已有特性的等级只能通过璇女派的门派互动更改 角色有时会因为各种事件获得额外的特性。eg: 身怀六甲(通过与配偶春宵一刻),经文祝祷(通过僧人衣服的互动,此特性可遗传) 2.3特性的作用 人物的特性影响战斗时机略的使用，并且决定他们的进攻、防守倾向。 在战斗和较艺的准备阶段，玩家可以通过消耗一定的机略点数来采用不同的机略，如喝茶/使用药品，决定开局时敌我双方的距离，影响我方或敌方的同伴的出手频率、守御值、专注上升速度、逃跑概率等。 影响角色的人物属性、七元赋性等数值 2.4特性的遗传 父母共同拥有的特性必定会遗传 神锋敛彩,璞玉韬光,经文祝祷只要父母单方面拥有即可遗传 2.4人物特性预览 此图来自百度贴吧-摇光为星-全特性效果总会图 3 人物属性3.1年龄与健康3.1.1 年龄与健康概述 人物半身像下方为年龄、生时、健康度，上图生时下方的数字“55/55”为人物的健康程度，以本人物举例，健康值上限即为剩余寿命55。 3.1.2 年龄与健康的改变 在受内外伤/内息/中毒超过可承受上限情况下，当前健康值会减少。如在当前健康值到0之后时节更替，人物死亡。中毒程度每超过上限一倍,时节更替时健康多减一. 战斗失利也会减少健康。 健康值上限会在每年你过生日的时节根据你的当前健康值-1重新获得上限。一旦健康值上限为0，人物死亡。所以请做好角色的健康管理，包中常备健康药。 游戏存在续命方法，可以提高健康上限,空桑派互动秘药延寿。 游戏中每年你过生日的时节你的年龄就会+1 3.1.3 年龄与健康的作用 年龄对行动力与主要属性有一定影响. 时节更替后,健康值上限为0时,人物死亡,触发传剑 3.2 七元赋性 主要在奇遇中生效，角色在奇遇岔路口会选择数值大的方向 福缘对物品掉落有一定影响 坚毅影响读书的耐心 ,npc坚毅越高越不容易意外中毒/受伤(坚毅大于三十) 3.3 主要属性主要属性分为：膂力、体质、灵敏、根骨、悟性、定力。所有主要属性都会影响需要该属性的功法发挥效率。 膂力会增加需要膂力武器的使用效率。超过50的部分会转化为攻击力道。减少装备重量对移动速度的负面影响。 灵敏会增加需要灵敏武器的使用效率。超过50的部分会转化为攻击迅捷。 定力会增加需要定力武器的使用效率。超过50的部分会转化为攻击精妙。 体质会影响角色的外伤上限。 根骨会影响角色的内伤上限。 悟性可以让读书和突破难度变得更简单。 3.4 防御属性防御属性分为：护体、御气、内息、卸力、拆招、闪避。 护体为外功防御，会被敌人的“破体”属性削弱 御气为内功防御，会被敌人的“破气”属性削弱(破体/破气属性为武器属性，后续讲到装备时会详解) 内息为人物对内力的控制能力，可以压制并恢复内力紊乱 卸力、拆招、闪避为人物的防御命中属性。卸力防御力道、拆招防御精妙、闪避防御迅疾。简而言之，如果敌人释放攻击功法时角色的三项防御命中属性均大于敌人的对应攻击命中属性，那么敌人的技能威力为0。平砍时也同样会进行命中属性比较。 3.5其他属性3.5.1提气架势 提气、架势速度影响人物战斗时这个圈。只有内外两圈都满了才能施放功法，内圈是提气圈，外圈是架势圈。角色一定会完成提气后才架势。 提气架势消耗，顾名思义，改变消耗的提气架势量。 内功发挥，内功发挥初始值为100%，并不是说内功发挥少了你的内功就变弱了，而是比百分百越少，角色的攻击功法外伤比例就越高；比百分百越高，角色攻击功法内伤比例就越高。内外伤比例直接表现为功法所需的提气架势比例 3.5.2攻击命中 力道、精妙、迅疾为人物的攻击命中属性。 卸力防御力道、拆招防御精妙、闪避防御迅疾。如果角色的三项命中属性均高于敌人的防御属性且处于正确的范围内，则攻击功法发挥为十成。 xx发挥、造成内/外伤、破气/体强度，建议直接看攻击功法上的数值，那是经过最终计算的结果(不考虑敌人防御属性情况下) 3.5.3治疗守御 守御指的是战斗时人物的白条(护体真气)，敌人在击破守御前是几乎不能对角色造成实质伤害的。提高守御效率能提高守御的硬度和速度。 疗伤/驱毒效率，提高疗伤和驱毒的能力 3.5.4行动能力 移动速度,移动一次的速度 移动距离,移动一次的距离 攻击速度,施展武器攻击敌方的速度 武器切换,战斗中切换武器的速度 施展速度,影响功法的施展时间 3.6 轮回轮回栏显示角色的前世 角色会继承前世的10%属性及资质(可建造术数四品建筑轮回台提高这个比例) 二 天下风云出我辈1 太吾村建设1.1建设概述当玩家剧情发展到进入太吾村时，就会成为一名光荣的村长，拥有自己的村庄，也就是产业“太吾村”。 玩家可以根据自己的需求在太吾村建造多种建筑，也可对太吾村自然资源进行采集、撤除等等操作。 吾村地区整体规模为13×13的方格，每一个方格均为空地或者已建造的建筑或者自然生成的资源。 当空地有相邻的建筑时，会出现一个小房子图标，表示该空地可以建造建筑。 建筑右上角数字为建筑等级。建筑等级最高为20建筑等级有多种影响：a.当建筑B为建筑A的前置建筑时，建筑A的当前等级为建筑B的建筑等级上限。b.当建筑A为经营建筑时，建筑等级会影响经营质量。如市集，建筑等级越高，收获的金钱越多；如知音阁，建筑等级越高，招募的流民音律资质就越高。c.当建筑B为建筑A的增益建筑时，建筑B的建筑等级影响增益质量。 大多数建筑均有维护费用 ，当玩家拥有银钱无法达到维护建筑的最低要求时，建筑会受损 。当修习类/经营类建筑受损到100%/5%时，该建筑即无法正常使用/增加收获进度；当建筑受损程度达到100%时，该建筑会倒塌，该建筑位置会变为废墟，无法修复；当银钱重新达到建筑的最低要求时，受损建筑会在每个时节自行修复一些，待建筑恢复完好，方可正常使用。 建筑建造或者扩建显示的需要时节为本次建造所需消耗时节数，每当增大投入1人力，消耗时节数减少1，最低消耗1时节。(投入人数有上限) 1.2建筑分类1.2.1剧情类 太吾村(唯一不可拆除)：太吾村建筑为产业的核心建筑，剧情自带无需自行建造。太吾村的规模等级会影响产业的建筑上限，每提升1级太吾村的规模等级，建筑上限增加2点 仓库：仓库为剧情自带，无需自行建造。可存放装备物品，提升资源储存上限，与全太吾绘卷世界的其他仓库共通。提升仓库等级会提高资源储存上限并增加仓库容量 太吾氏祠堂(唯一不可拆除)：太吾氏祠堂为剧情建筑，建筑图纸剧情自动获得，需玩家自行建造。从主角20岁开始，年龄每增长10年可多一个通过消耗威望来提升同道的资质格子；基于祠堂规模与主角名誉，在每次“立春”时节可以获得一定的威望。 驿站(唯一不可拆除)：驿站为剧情建筑，当完成“墓中仙人”剧情后回到太吾村，会触发信件剧情，对话结束后驿站建筑图纸自动获得，需自行建造。当驿站完成建造后，人物即可通过点击地图界面中查看世界区域按钮 ，进入世界地图，点击目标地区，即可旅行到该地。 如玩家已开通该地区的驿站(即到达过该地域存在驿站的城镇)，可往返与该地区；如若无开通此地区，仍可旅行至此地，但是旅行至该地区后需找到该地区的驿站方可继续旅行至其他地区。(驿站同样是可经营建筑，选择村民经营驿站可以获得银钱和威望) 1.2.2基础类建筑基础建筑分非修行类与修行类。 非修行类包括：居所(每提升两级额外多一点可用人力)、厢房(提供额外好感加成) 修行类包括：人物修炼功法(练功房)或修习十六类技艺(木工房、琴舍等等)处，玩家可在此类建筑中进行修习&amp;突破&amp;研读，某些技艺建筑还可进行制造。 1.2.3 扩展类建筑扩展类建筑需要紧靠其他建筑建造。扩展类建筑等级不可超过其基础建筑等级。扩展类建筑可分为： 经营类建筑。经营类建筑一般为修习类建筑的扩展建筑，需建在在对应基础建筑的邻近. 玩家需派遣一村民进入经营类建筑进行长期经营，经营者的技艺能力和心情会影响经营质量收获进度。每个时节会获得收获进度，更换经营者不会清空当前经营进度。经营评价与经营者反馈会影响经营质量。经营进度满了会在收获栏显示收获，需要玩家自己点击收获。招募人才的收获时间是有限制的！记得及时收人！ 经营类建筑共分为三类： 赚取银钱建筑(镖局、酒楼、市集、赌坊等等)、 获取威望建筑(金铺、知客亭等等)、 招募人才建筑(百家宴、勾栏瓦舍、书院等等)。 增益类建筑。增益类建筑一般为修习类建筑的扩展建筑，需建在在对应基础建筑的邻近。 增益类建筑可对对应的基础建筑或直接对人物提供增益效果，增益效果随增益建筑建筑等级提高而提高。 如：绝诣堂(减少修习绝技所需历练)、龟龙山(减少突破诗书所需历练)、龙泉七星井(可制作出高一品的金铁器具)、画影轩(大幅提高初识者的好感度)等等。 采集类建筑。采集类建筑依托自然资源建造，需建在在对应基础资源的邻近。 可收获对应原材料，可提高资源增长概率，建筑等级不能超过资源等级。建筑等级影响采集质量。 如矿井、树农、药农、花农、筒车、泥渠、宝井、火爆堆、冰夷像等等都属于采集类。 1.3 建筑解锁与效果 技艺建筑需要对应技艺书修习到75%以上后可在商人处购买对应建筑图纸。 建筑效果见下表: 2 武学2.1 功法的分类2.1.1内功 每种内功均有对应的内力属性 金刚(金)：生玄阴(水)；被归元(土)生；克紫霞(木)；被纯阳(火)克 紫霞(木)：生纯阳(火)；被玄阴(水)生；克归元(土)；被金刚(金)克 玄阴(水)：生紫霞(木)；被金刚(金)生；克纯阳(火)；被归元(土)克 纯阳(火)：生归元(土)；被紫霞(木)生；克金刚(金)；被玄阴(水)克 归元(土)：生金刚(金)；被纯阳(火)生；克玄阴(水)；被紫霞(木)克 混元为全属性 2.1.2身法2.1.3绝技2.1.4攻击2.2 获取功法 拜入门派后请教门下弟子,根据支持率获取功法 请教非门派人士,可获取随机该人物研习程度大于五十的功法 战斗时掉落 2.3 研习功法2.3.1 功法的修习与突破在任意城市/村落/门派点击进入该地区的产业视图，找到练功房/或相应技艺基础建筑 ，点击图标进入可以进入到练功读书界面. 点击“修习”按钮 ,点击齿轮状按钮即可选择你所要修习的功法/技艺书。(显示内容为角色学习过的功法/技艺书，修习度100%的功法不在此显示).点击所需修习功法，然后按圆圈确定；或者按x取消。 每当功法修习至玄关(25%/50%/75%)，需进行突破方可继续修习。 2.3.2 研读书籍的资质需求太吾绘卷中每种品级的武学秘籍、文化典籍都会要求角色的资质，越高级的书要求的资质也会越高，想要读懂书中的内容就要努力提高自身的资质. 书籍50%阅读难度所需的资质+造诣与裸资质需求见下表 书籍品级 资质+造诣需求 裸资质需求 九品 19 4 八品 48 23 七品 91 46 六品 148 58 五品 219 89 四品 304 108 三品 404 149 二品 518 193 一品 646 226 从上面可以看出，资质在读书这方面的影响其实就是三段:58，89，108。对应的你能顺顺当当的读书读到6，5，4品书。 建人物时，点了天人造化后配合早熟特性，内功身法绝技三项是比较容易达到108+的资质的，其他的武功和技艺方法很多时候1项都没有 这时候退而求其次，关注89+这个数值就好。最偏重的一门兵器一门技艺89+，其他两三门辅修兵器技艺58+就可以。 2.3.3 功法的正逆练与冲解特效正逆练由读书所决定。 读真传秘籍获得正练效果1,读手抄秘籍获得逆练效果1 正练效果会提高功法的发挥上限,逆练功法会降低功法的使用需求 正逆练还会有心法正逆特效的区别，正≥5时为正，逆≥5时为逆，正逆都为5时为冲解。 具体特效安装功法显示mod即可,此处不再赘述. 3 奇遇3.1 奇遇概述 奇遇进入之前需要支付“门票”——资源、食物、道具等，以及消耗对应行动力。 难度: 影响奇遇所需技艺等级 区域: 影响七元赋性格的分布。 队伍七元赋性：队伍中所有人的七元赋性的平均值。 队伍技艺值：太吾的技艺资质+太吾的技艺造诣+队伍其他人的技艺资质总和的一半 进入奇遇后以队伍七元赋性决定前进方向，队伍七元哪个大就去哪个分支向，不会走回头路，有箭头显示以奇遇转盘检定队伍技艺值决定行动效果，队伍技艺值大于转盘数值则成功，否则失败。 3.2 促织高鸣作用: 可以通过该奇遇捕获促织 拥有三只或以上促织后可与任何关系符合条件的成年npc进行促织决斗来获取资源或者增加好感 作为礼物赠送给npc(呆物送掌门) 作为商品换取银钱 把促织放在祠堂,每年特定时节会根据促织胜场获取威望 放置于装备栏改变人物七元赋性 作为奇遇天才地宝的进入条件 出现条件: 每年8、9、10月份出现 需求: 捕虫网 奇遇转盘检定：难度对应的杂学 奇遇最后可抓蛐蛐保证你队伍的杂学高于转盘所需情况下，尽量多走福缘提高获得高品质蛐蛐机会 难度也会影响蛐蛐的品质, 蛐蛐分平叫和急叫,急叫时波纹大且急 在蛐蛐从开始急叫到结束的中间捉是最好的捉太快或太慢都不行,一般声音越大的就越好 促织决斗的流程见下表: 作者的太吾生涯仅有一只怀胎三年生的天蓝青,它一生从未战斗过,所以本攻略对促织的描述不多,敬请见谅. 3.3 商贾云集作用: 奇遇内有大量商人 出现条件: 每年2、3、4月份出现 需求: 难度对应的威望 奇遇转盘检定：难度对应的品鉴 难度会影响商人售卖的物品 奇遇内福缘判定成功会提升商队好感(暂时)。 和商人进行交易即可提高商号友好度。银钱交易量，友好度越多。 商号好感度会影响购买出售价格、商人出售物品数量、商人出售物品品阶。 3.4 外道巢穴作用: 每当打通外道巢穴会根据人物立场进行选择，可获得大量地区恩义。根据人物立场的不同会有不同的奖励。 首杀 首次打通某类外道巢穴后，无论哪个地图格上的同类外道巢穴所属外道都会遇到太吾就逃跑。 要在本地区打掉现有最高等级的外道巢穴，才会刷下一级。 出现条件: 未知 需求: 任意食物 奇遇转盘检定： 名称 所需技艺 技艺等级 恶丐窝 毒术 杂学 10-50 贼人营寨 巧匠 杂学 10-50 悍匪砦 杂学 锻造 20-100 叛徒结伙 制木 杂学 30-150 恶人谷 术数 杂学 40-200 迷香阵 织锦 音律 40-200 乱葬岗 医术 毒术 50-250 异士居 绘画 品鉴 诗书 60-300 修罗场 医术 杂学 70-350 邪人死地 道法 70-350 3.5 剑冢作用: 挑战剑冢boss时会根据对剑冢boss百分比给予太吾精纯点数，一个boss最多3点 打通某一剑冢后会解锁下一个10%阶段的门派支持上限/地区恩义上限/地区威胁上限/商人好感上限同时也会解锁下一品阶的npc可以被相枢化魔和成为太吾同道。剩余的剑冢会提高难度 此攻略图片来自百度贴吧-戳眼神教教主-各个剑冢boss的强度和应对方法 3.5.1 大玄凝 3.5.2 焚神练 3.5.3 溶尘隐 3.5.4 鬼神霞 3.5.5 莫女衣 3.5.6 伏铁邪 3.5.7 囚魔木 3.5.8 解龙魄 3.5.9 凤凰茧 3.5.10 剑冢挑战顺序 3.6 天书宝典宝典作用: 每本宝典能加100对应武学资质，可以拯救一位太吾的人生,资质只要到六七十再带上相应的宝典，神一品的功法突破起来也是轻轻松松。 赠与NPC,向其请教功法 取得宝典的方法： 亲自上手绑架走扒下来 天书宝典奇遇 界青门安排，等到站了进奇遇拿。(不知道是不是设定，宝典奇遇的勇壮和福缘判定特别多) 刚正立场并且名誉符合要求，追着惩戒打到死，等奇遇抢。 如果你到奇遇终点的路线完美避开了所有勇壮格子，到达终点时会直接取得宝典。 如果途中有过战斗则在终点要和某人打一架来决定宝典归属。 奇遇轮盘互动: 奇遇当中，遇敌时根据敌人的立场会有不同的互动结果： 刚正：恶战，败者退出争夺。可以避战。 仁善：切磋，可以避战。 中庸： 暂时停战 叛逆：选择是否助其虚张声势：是：对方看起来会比实际更强，出现在终点处与你争夺的可能性变大 否：打一架。 唯我：遇到唯我的敌人必定在对方的偷袭中受伤(不触发战斗，发生在对话当中的既定事实)，然后可选择避战或刚到底。此时避战必定成功 奇遇的轮盘对应资质: 奇遇的轮盘只有对应宝典的武学造诣 4 战斗4.1 战斗准备在与敌人相遇时会触发战斗，玩家可以点击角色半身像来使用道具、更改装备和功法，也可点击敌人半身像查看敌人的装备物品人物属性。知己知彼，百战不殆。 4.1.1 机略来源 机略等级和类型由整个队伍决定。人物特性的里圆圈的会具体表现为战斗、较艺准备中的机略。 不同颜色(红vs蓝)的机略等级会相互抵消每个角色的白色机略会加在红蓝机略等级高的那一方。如该角色无红蓝色机略或红蓝等级一致，无论白色机略等级高低都视为无。 机略等级公式：主角的机略等级X(6-队伍总人数(包括主角在内))+队友的机略等级 4.1.2 机略作用 使用战前道具 喝酒/喝茶/用药/使用剑冢碎片改变人物属性，需要消耗机略等级。 决定先后手 敌我双方剩余机略等级高者为先，低者为后。如果一致，则随机先后。 先手在战斗时初始拥有90%提气架势圈与3点移动力；后手在战斗时初始拥有60%的提气架势圈与2点移动力。 战斗策略 策略盘。消耗机略等级使用战斗机略，单选。机略消耗量由敌方机略数值影响。 策略盘根据队伍红蓝机略等级的不同分为两种： 当人物及队伍中的队员合计蓝色机略数&gt;红色机略数时，人物会采取近战策略 当人物及队伍中的队员合计蓝色机略数&lt;红色机略数时，人物会采取远程策略 4.2 伤害1伤害 = 击中部位基础伤害(比如胸背1级伤口60，3级伤口180)*武功或者武器伤害百分比*对应的(破x-御x)/100*(1+内外功伤害加成)*暴击倍率 此伤害公式仅供参考 4.3 伤势在《太吾绘卷》中，玩家们对敌人所用的武功、武器不同，对敌人造成伤口破绽也会不同。我们对其伤口多次进行伤害后，后续的伤害会越来越高. 4.3.1 功法造成的伤势所有攻击功法出招都是四次。 计算顺序为迅疾、精妙、力道。 上图是巨阙的。 在功法属性一栏看到，读格子数目，迅疾，精妙，力道的比例分别为1：1：8。 那么前三招的发挥比例分别为10%，10%，80%。 假如你命中三维全压对面，最后一击的发挥比例就是10%+10%+80%=100% 假如你的迅疾太低，己方迅疾低于敌方闪避,第一招被闪避了，那么最后一击的发挥比例就是10%+80%=90% 此外，这几个颜色的格子还影响发挥比率。 计算方法为 发挥比例100%【包括】以上，造成的伤势程度为致命伤;倍率为3倍。 发挥比例50%【包括】以上，造成的伤势程度为重伤;倍率为2倍。 还拿巨阙做例子，第一击迅疾属性10%，轻伤，第二击精妙属性10%，轻伤，第三击力道属性80%，重伤。 最后一击100%，致命伤。 如果前两段都被格挡，只有第三段和第四段的话，就是80%+80%，两段都是重伤伤势，倍率为两倍，虽然被削弱但影响不是致命的。 4.3.2 普攻造成的伤势己方攻击命中属性略大于敌方防御防御属性,造成轻伤. 使用武器 招式 攻击命中属性 己方力道 敌方卸力 造成伤势 刀 劈 力道 100 99 轻伤 己方攻击命中属性大于敌方防御防御属性的两倍,造成重伤. 使用武器 招式 攻击命中属性 己方力道 敌方卸力 造成伤势 刀 劈 力道 100 50 重伤 技巧: 根据上述结论,可以适当堆砌己方命中属性使用正练空桑绝技剖腹切割法或正练百花谷绝技对敌方进行控制和提高己方伤害. 4.4 破绽与闭穴4.4.1 破绽破绽产生: 功法特效 破绽作用: 对破绽部位造成伤害，会提高伤害，同时无视守御值 4.4.1 闭穴闭穴产生: 功法特效 闭穴作用: 闭穴会对闭穴的部位造成闭穴效果,不同的部位有不同的效果. 5 地区恩义的作用 五仙教 五圣秘浴 消耗30%地区恩义 祛除所有毒素 百花谷 起死回生 消耗30%地区恩义 治愈所有伤势 狮相门 散播威名 消耗30%地区恩义 获得大量威望（约1000） 铸剑山庄 欧冶古具 消耗50%地区恩义 自选获得三品锻造、制木、织锦、巧匠工具之一（仅余一次使用机会） 璇女派 玉镜沉思 消耗50%地区恩义 看仙人弹琴改善某负面特性，看仙人舞剑增强某正面特性 峨眉派 天府规略 消耗50%地区恩义 使太吾村中各资源点的规模提升 无量金刚宗 搜集贡品 消耗20%地区恩义 获得大量金钱（一万多） 武当派 七星调元 消耗30%地区恩义 使人物内息紊乱恢复 界青门 委托暗杀 消耗30%地区恩义 需记住名字 伏龙坛 龙岛忠仆 消耗30%地区恩义 获得好感每年加60的同道一名 血犼教 血池秘法 消耗30%地区恩义 使人物进入（活回到）入邪的状态 然山派 王禅典籍 消耗30%地区恩义 改变人物立场（约一格） 少林派 念经忏悔 消耗20%地区恩义 减少人物恶名 元山派 石牢静坐 消耗30%地区恩义 减少人物入邪程度 空桑派 秘药延寿 消耗50%地区恩义 续命六年但同时将身中剧毒 各地区大当家等红色人物 推恩施义 消耗20%地区恩义 增加地区安定、文化、资源 各地区豪富等黄色人物 商会赞誉 消耗50%地区恩义 增加所选商会好感 各地区二当家权贵等橙色人物 笼络人心 花一万买地区恩义 三 一入江湖岁月催1 喜结良缘结婚条件: 双方年龄必须满16岁 倾诉爱意成功 双方不是三代以内的直系血亲(德国骨科警告) 2 传宗接代2.1 触发生育的必要条件1.双方为一男一女 2.双方关系为两情相悦/结发夫妻 3.双方在同一个格子 2.2 影响生育几率的因素 年龄: 30岁之后生育几率大幅下降 特性: 父母双方某些不良特性会降低生育几率.eg: 石芯玉女,无根之人 立场: 立场为刚正的NPC在与玩家成为结发夫妻之前基本不会与玩家进行生育互动;立场为叛逆的NPC可在与玩家成为结发夫妻之前和玩家进行生育互动. 此立场因素并不影响NPC之间的生育互动 2.3 子女的继承项目2.3.1 相貌子女的五官部件在爸妈的对应器官之间随机 2.3.2 特性 父母共同拥有的特性必定会遗传 神锋敛彩,璞玉韬光,经文祝祷只要父母单方面拥有即可遗传 其他的特性遗传个数与等级见下表: 如果人物遗传的特性达到三个，随机产生新特性的机会将减半，特性越多产生随机特性的机会越小，遗传特性达到七个后将不再有随机新特性. 参考资料: 百度贴吧-吉祥的客栈-太吾遗传学 2.3.2 属性和资质子女某项属性和资质的数值 = 父母对应属性之和的平均值+随机数 属性和资质的提升: 如果玩家为女太吾,可在身怀六甲期间触发胎教事件提升子女的属性和资质. 轻轻抚慰：加主要属性（人物的根骨等主要属性） 哼唱小曲：加技艺资质（随机技艺天赋或是全体提升） 调匀气息：加武学资质（随机武学天赋或是全部提升） 将子女拉入同道,可在祠堂消耗威望对其传功提升其武学资质或者技艺资质 3 传剑当玩家的健康值在时节更替后归零时/人物入魔,触发传剑.玩家可选择同道中的一人进行传剑;如果没有同道且没有开启随机继承人选项,游戏结束. 3.1 传剑对被传剑人的影响 被传剑人会丧失自己原本的所有已习得功法,获得上一代太吾所有已习得功法 被传剑人会获得上一代太吾几乎所有资产,不能继承的资产包括:上一代太吾的衣服,上一代太吾获得的奇书宝典(除此之外均可继承) 被传剑人的身份会变为太吾传人 3.2 生平遗惠在选择传剑人之后,可根据上一代太吾的生平遗惠选择几项对下一代太吾有增益的增益效果. 3.3 游戏选项变更在传剑时,玩家可对游戏选项进行变更 eg: 游戏难度,侵袭速度,外道数量等 四 不及人生一场醉太吾历一年八月 太吾降世,名为沈万三.沈万三自知天资愚钝,幸好他在梦中曾见过盛世光景,对建设颇有心得.于是他一心一意的建设着太吾村,除了参与每年的新春集会,几乎没有出过太吾村. 太吾历十五年 沈万三惊闻剑冢异动,惶惶不可终日,忙忙带上家乡美酒出门学艺. 听闻铸剑山庄广收门徒,有教无类,遂拜入山庄门下.习得十二路鱼肠刺剑. 太吾历十六年 宁琴对沈万三倾心爱慕,追随其至逐剑山庄,沈万三感动不已便与宁琴成为结发夫妻,共度余生. 太吾历十七年 宁琴生子,取名沈灵虚. 太吾历十七年 宁琴生女,取名沈逍遥. 太吾历二十年 以十二路鱼肠刺剑平息剑冢异动. 太吾历二十一年 剑冢异动又起,沈万三心生愤慨,决心破除剑冢,以绝后患. 太吾历二十二年 沈万三大破剑冢溶尘隐,而后安心回到太吾村发展建设. 太吾历二十三年 剑冢异动再起,沈万三心叹:不知这如履薄冰的日子还要持续多久,这便是太吾的宿命吗? 随后便再次踏入学艺之路. 太吾历四十一年 沈万三已将巨阙剑修得大成,锻造之术亦至宗师之境.但是因资质过低,修炼内功走火入魔,大限已至,传剑其女沈逍遥.沈逍遥乃是绝世奇才,战力惊人,刚刚接过剑柄便提刀杀向剑冢,三刀劈碎大玄凝. 沈逍遥觉剑冢之祸非一世之功,必须的给自己留下一个传承之人,便开始游历天下,寻一个资质上佳之人与之成婚诞下希望之火. 太吾历四十二年 寻寻觅觅,花费数年时间,终遇一文人,良材美玉资质上佳,与其共结连理,诞下一女,取名沈君鄂. 太吾历五十九年 沈逍遥以巨阙刀法连破五个剑冢,提刀而立,为之四顾,为之踌躇满志,一头杀入凤凰茧,不料身死道消.匆匆传剑其女沈君鄂. 沈逍遥: 只要让我在劈一刀,你必死无葬身之地! 奈何我伤势过重,已无力出招,我恨啊!我还没有做好准备,还没有给我的儿女传功啊! 太吾历六十年 沈君鄂接过剑柄,心道凤凰茧之败并非母亲功法不够凌厉,而是招架不足还为出招便已身死.我只需寻得一保命绝技便可攻破凤凰茧. 沈君鄂遍历天下,寻得一神功天蛇换骨,匆匆研习了几章得其效果便直奔剑冢而去. 沈君鄂将伏虞剑柄嵌入剑冢墓门,只听轰隆一声,大门应声而开,一个人影随之从剑冢中凑出. 金凰儿嬉笑着说:”我问你啊,方今之世，可有圣人吗?我等不到圣人,唯有出来寻找,且让我试试你可有圣人之才如何?’’不料话音未落,金凰儿便拔刀向沈君鄂劈来. 一番苦战,沈君鄂击败了金凰儿! 金凰儿虽身负重伤,却仍嘻嘻而笑: “不错,便是你啦!” 她说着,盛了一碗金黄的美酒递来给沈君鄂. 沈君鄂不由自主的想要去接:”相枢降世入轮回,天下风云出我辈.一入江湖岁月催,不及人生一场醉.如此美酒,理应大醉一场!” 哪知一眨眼,眼前便什么也没有了. 五 致谢词在我初次游玩《太吾绘卷》时,我遇到了许多艰难与困阻,我查询了众多攻略,一点一点拼凑出我的江湖.美好的假期结束了,我也应该去工作来维持生计.但是我希望当有新玩家来体验属于他们的江湖和感动时能少一些阻碍,基于此我编写了本篇攻略. 因为本篇攻略参考众多,没有一一列出,敬请见谅. 感谢《太吾绘卷》带给我的感动,是它让我谱写则属于自己的江湖,感谢《太吾绘卷》全体制作人员.感谢为《太吾绘卷》无私奉献的攻略作者们，在此，我再一次真诚地向帮助过我的攻略作者表示感谢! 六 参考资料 灰机wiki-太吾绘卷-灰机Wiki NGA-UID:5758723-太吾百晓册 NGA-UID:157403- 魅力捏脸手册 {09/30 更新：补充少量有关生孩子的机制} 百度贴吧-摇光为星-全特性效果总会图 百度贴吧-戳眼神教教主-各个剑冢boss的强度和应对方法]]></content>
      <categories>
        <category>游戏攻略</category>
      </categories>
      <tags>
        <tag>太吾绘卷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的inline元素、block元素、inline-block元素有哪些？它们之间有什么区别？]]></title>
    <url>%2F2018%2F10%2F03%2F%E5%B8%B8%E8%A7%81%E7%9A%84inline%E5%85%83%E7%B4%A0%E3%80%81block%E5%85%83%E7%B4%A0%E3%80%81inline-block%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[每个html标签元素都有其默认的元素类型，主要包括两大类:inline内联元素、block块元素。除默认为以上两种，还有部分标签元素叫可变元素，会根据上下文语境决定该元素为inline元素或是block元素。在css里，有一个display的属性，他规定元素应该生成的框的类型。可能的值有很多，inline、block、inline-block,其中inline-block是在css2.1里新增的值。具有这个值的元素，我们可以把它叫做inline-block元素。 一.inline元素、block元素、inline-block元素的具体解释inline元素inline元素全称Inline Elements，英文原意:An inline element does not start on a new line and only takes up as much width as necessary.一个内联元素不会开始新的一行，并且只占有必要的宽度。 特点: 和其他元素都在一行上； 元素的高度、宽度、行高及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变。 block元素block元素全称Block-level Elements，英文原意:A block-level element always starts on a new line and takes up the full width available (stretches out to the left and right as far as it can).一个块级元素总是开始新的一行，并且占据可获得的全部宽度(左右都会尽可能的延伸到它能延伸的最远) 特点: 每个块级元素都从新的一行开始，并且其后的元素也另起一行。（一个块级元素独占一行）; 元素的高度、宽度、行高以及顶和底边距都可设置; 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 inline-block元素inline-block元素，英文释义:inline-block elements are like inline elements but they can have a width and a height.它像内联元素，但具有宽度和高度。 特点: 和其他元素都在一行上； 元素的高度、宽度、行高以及顶和底边距都可设置 二.常见的inline元素、block元素、inline-block元素常见的inline内联元素：span、img、a、lable、input、abbr（缩写）、em（强调）、big、cite（引用）、i（斜体）、q（短引用）、textarea、select、small、sub、sup，strong、u（下划线）、button（默认display：inline-block）） 常见的block块级元素：div、p、h1…h6、ol、ul、dl、table、address、blockquote、form 常见的inline-block内联块元素：img、input 三.的inline元素、block元素、inline-block元素的区别 块级元素会独占一行，而内联元素和内联块元素则会在一行内显示。 块级元素和内联块元素可以设置 width、height 属性，而内联元素设置无效。 块级元素的 width 默认为 100%，而内联元素则是根据其自身的内容或子元素来决定其宽度。]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考1</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何理解盒模型及其content、padding、border、margin？]]></title>
    <url>%2F2018%2F10%2F03%2F%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%85%B6content%E3%80%81padding%E3%80%81border%E3%80%81margin%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[如何理解盒模型及其content、padding、border、margin？ 当对一个文档进行布局(laying out)的时候，浏览器渲染引擎会根据CSS-Box模型（CSS Basic Box model）将所有元素表示为一个矩形盒子（box)。CSS决定这些盒子的大小，位置以及属性（颜色，背景，边框尺寸…). 一.CSS标准盒子模型。 1. 内容区域content内容区域content area 是包含元素真实内容的区域。它通常包含背景、颜色或者图片等，位于内容边界的内部，它的大小为内容宽度 或 content-box宽及内容高度或content-box高。 如果 box-sizing 为默认值， width, min-width, max-width, height, min-height 与 max-height 控制内容大小。 2. 内边距区域padding内边距区域padding area 延伸到包围padding的边框。如果内容区域content area设置了背景、颜色或者图片，这些样式将会延伸到padding上(而不仅仅是作用于内容区域)。它位于内边距边界内部, 它的大小为 padding-box 宽与 padding-box 高。 内边距与内容边界之间的空间可以由 padding-top, padding-right, padding-bottom, padding-left 和简写属性 padding 控制。 3. 边框区域border边框区域border area 是包含边框的区域，扩展了内边距区域。它位于边框边界内部，大小为 border-box 宽和 border-box 高。由 border-width 及简写属性 border控制。 4. 外边距区域margin外边距区域margin area用空白区域扩展边框区域，以分开相邻的元素。它的大小为 margin-box 的高宽。 外边距区域大小由 margin-top, margin-right, margin-bottom, margin-left 及简写属性 margin 控制。 注意: 在外边距合并 的情况下，由于盒之间共享外边距，外边距不容易弄清楚。 对于非替换的行内元素来说，尽管内容周围存在内边距与边框，但其占用空间（行高）由 line-height 属性决定。 二. 浏览器兼容一旦为页面设置了恰当的 DTD，大多数浏览器都会按照上面的图示来呈现内容。然而 IE 5 和 6 的呈现却是不正确的。根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。 虽然有方法解决这个问题。但是目前最好的解决方案是回避这个问题。也就是，不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素和子元素。 IE8 及更早IE版本不支持设置填充的宽度和边框的宽度属性。 解决IE8及更早版本不兼容问题可以在HTML页面声明&lt;!DOCTYPE html&gt;即可。]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考1</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[webstorm默认配置下的常用快捷键]]></title>
    <url>%2F2018%2F10%2F03%2Fwebstorm%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[mac book 下文的 ctrl 替换成 command 键。 查找/代替 快捷键 说明 ctrl+shift+N 通过文件名快速查找工程内的文件（必记） ctrl+shift+alt+N 通过一个字符快速查找位置（必记） ctrl+F 在文件内快速查找代码 F3 查找下一个 shift+F3 查找上一个 ctrl+R 文件内代码替换 ctrl+shift+R 指定目录内代码批量替换 ctrl+shift+F 指定目录内代码批量查找 ctrl+R 文件内代码替换 界面操作 快捷键 说明 ctrl+shift+A 快速查找并使用编辑器所有功能（必记） alt+[0-9] 快速拆合功能界面模块 ctrl+shift+F12 最大区域显示代码（会隐藏其他的功能界面模块） alt+shift+F 将当前文件加入收藏夹 ctrl+alt+s 打开配置窗口 ctrl+tab 切换代码选项卡（还要进行此选择，效率差些） alt+&lt;-或-&gt; 切换代码选项卡 代码编辑(必记) 快捷键 说明 ctrl+D 复制当前行 ctrl+W 选中单词 ctrl+&lt;-或-&gt; 以单词作为边界跳光标位置 alt+Insert 新建一个文件或其他 ctrl+alt+L 格式化代码 shift+tab/tab 减少/扩大缩进（可以在代码中减少行缩进） ctrl+Y 删除一行 shift+enter 重新开始一行（无论光标在哪个位置） 导航 快捷键 说明 esc 进入代码编辑区域 alt+F1 查找代码在其他界面模块的位置，颇为有用 ctrl+G 到指定行的代码 ctrl+]/[ 光标到代码块的前面或后面 alt+up/down 上一个/下一个方法 建议配置版本控制快捷键 快捷键 说明 ctrl+C 提交代码 ctrl+p 向远程版本库推送更新]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[加和不加meta的viewport有什么区别？]]></title>
    <url>%2F2018%2F10%2F03%2F%E5%8A%A0%E5%92%8C%E4%B8%8D%E5%8A%A0meta%E7%9A%84viewport%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在使用视窗宽度vw时，需要加入一个&lt;meta&gt;标签，这个标签究竟起什么作用，如果不加对网页有何影响呢？ #简介 什么是viewport？vieport是用户在网页上的可见区域。 什么是meta？&lt;meta&gt;是HTML5中引入的一种使设计人员标记控制vieport的标签。 &lt;meta&gt; 的作用为什么要加入&lt;meta&gt;，不加会有什么影响？vieport随设备而异，并且在移动电话上会比在计算机屏幕上小。 在平板电脑和手机之前，网页仅设计用于计算机屏幕，并且网页具有静态设计和固定大小是很常见的。 然后，当我们开始使用平板电脑和手机上网时，固定大小的网页太大，无法容纳视口。要解决此问题，这些设备上的浏览器会按比例缩小整个网页以适合屏幕大小。这样用户的观看体验会比较差！这不是完美的！ ##如何使用 &lt;meta&gt;？ 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta&gt;标签是如何控制网页的尺寸和缩放浏览器的说明。 width=device-width部分将页面的宽度设置为跟随设备的屏幕宽度（视设备而定）。 initial-scale=1.0部分设置浏览器首次加载页面时的初始缩放级别。]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考1</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IDE是什么？它和文本编辑器相比有什么优缺点？]]></title>
    <url>%2F2018%2F10%2F03%2FIDE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E5%92%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在我们学习it的时候，不可避免的会遇到一个问题，那就是我们使用什么来编写代码呢？ 简介文本编辑器文本编辑器是计算机软件中的一种。主要用于用来编写和查看文本文件。 IDEIDE是带有软件开发功能的“集成开发环境”。 集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。 优缺点优点 节省时间和精力。IDE的目的就是要让开发更加快捷方便，通过提供工具和各种性能来帮助开发者组织资源，减少失误，提供捷径。 建立统一标准。当一组程序员使用同一个开发环境时，就建立了统一的工作标准，当IDE提供预设的模板，或者不同团队分享代码库时，这一效果就更加明显了。 管理开发工作。首先，IDE提供文档工具，可以自动输入开发者评论，或者迫使开发者在不同区域编写评论。其次，IDE可以展示资源，更便于发现应用所处位置，无需在文件系统里面艰难的搜索。 缺点 学习曲线问题。IDE基本上是比较复杂的工具，为了更好的熟练使用，需要一定的时间和耐心。 初学者的困难。对初学者来说，使用IDE来学习开发有相当的难度，不适合学习一种新语言时使用。 无法修复坏代码或设计。开发者不能完全依赖工具的便捷，还是必须保持专业水准和熟练度，开发的成果好坏主要还是看开发员的技术。]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考1</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[九宫格的布局你还能想到哪些办法实现？它们各自的优势劣势是什么？]]></title>
    <url>%2F2018%2F10%2F03%2F%E4%B9%9D%E5%AE%AB%E6%A0%BC%E7%9A%84%E5%B8%83%E5%B1%80%E4%BD%A0%E8%BF%98%E8%83%BD%E6%83%B3%E5%88%B0%E5%93%AA%E4%BA%9B%E5%8A%9E%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%E5%AE%83%E4%BB%AC%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E5%8A%BF%E5%8A%A3%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[九宫格布局是我们在网页开发中常用的布局之一，那么如何使用代码完成它呢？ 设置垂直方向的padding撑开容器123456789101112div.box &#123; width: 30%; padding-bottom: 30%; margin: 1%; background-color: orange; float: left; border-radius: 5%;&#125;div &#123; width: 100%; padding-bottom: 30%;&#125; 在 CSS 盒模型中，一个比较容易被忽略的就是 margin, padding 的百分比数值计算。按照规定，margin, padding 的百分比数值是相对 父元素宽度 的宽度计算的。由此可以发现只需将元素垂直方向的一个 padding 值设定为与 width 相同的百分比就可以制作出自适应正方形了： 优点：简洁明了，且兼容性好 缺点：填充内容后会出现问题 viewport 使用vw单位123456789101112div.box &#123; width: 30vw; height: 30vw; margin: 1vw; background-color: orange; float: left; border-radius: 5%;&#125;div &#123; width: 100vw; height: 100vw;&#125; 优点：简洁方便 缺点：浏览器兼容不好]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考1</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML文件里开头的!Doctype有什么作用？]]></title>
    <url>%2F2018%2F10%2F03%2FHTML%E6%96%87%E4%BB%B6%E9%87%8C%E5%BC%80%E5%A4%B4%E7%9A%84-Doctype%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[每个 HTML 文件里开头都有个很重要的东西&lt;!DOCTYPE html&gt;,DOCTYPE是document type的简写，它并不是 HTML 标签，也没有结束标签，它是一种标记语言的文档类型声明，即告诉浏览器当前 HTML 是用什么版本编写的。 一. 背景介绍什么是DOCTYPE?DOCTYPE是document type的简写，它并不是 HTML 标签，也没有结束标签，它是一种标记语言的文档类型声明，即告诉浏览器当前 HTML 是用什么版本编写的。 注意: DOCTYPE的声明必须是 HTML 文档的第一行，位于html标签之前。大多数Web文档的顶部都有doctype声明，它是在新建一个文档时，由Web创作软件草率处理的众多细节之一。很少人会去注意 doctype ，但在遵循标准的任何Web文档中，它都是一项必需的元素。doctype会影响代码验证，并决定了浏览器最终如何显示你的 Web文档。 二. 知识剖析DOCTYPE的作用?DOCTYPE是document type(文档类型)的简写，在web设计中用来声明文档类型。在所有 HTML 文档中规定 DOCTYPE 是非常重要的，这样浏览器就能了解预期的文档类型， 告诉浏览器要通过哪一种规范（DTD）解析文档（比如HTML或XHTML规范）。DOCTYPE会影响代码验证，并决定了浏览器最终如何显示你的Web文档。 HTML 4.01 和 HTML5 中 DOCTYPE的区别 HTML 4.01 中的 doctype 需要对 DTD 进行引用，因为 HTML 4.01 基于 SGML。 HTML 5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为（html 5简化了这种声明，意在告诉浏览器使用统一的标准即可）。 三. 代码实战如何使用DOCTYPE?HTML 文档的第一行，位于html标签之前 ,引入DOCTYPE声明。123456789&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 注意事项:DOCTYPE的声明必须是 HTML 文档的第一行，位于html标签之前。在DOCTYPE声明前面出现了这些内容：普通文本、HTML 标签、HTML 注释、XML 声明、IE条件注释,会导致HTML 进入怪异模式.]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考1</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用浏览器的F12调试页面]]></title>
    <url>%2F2018%2F10%2F03%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84F12%E8%B0%83%E8%AF%95%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[一个程序员按照要求编写一个网页，不可能一次编写就完全达到目的，一般要对自己的的代码修改调试几次后才能到达要求，浏览器的F12开发人员工具就可以很方便的帮助程序员调试自己的代码。 简介F12 开发人员工具是一套按需采用的工具，网站开发人员可以随时在任何网页上使用 F12 工具，从而快速调试 JavaScript、HTML 和级联样式表 (CSS)，还可以跟踪并查明网页或网络的性能问题。 具体内容项目： element（元素）标签页：可以查看代码 sources（软件源）标签页：可以选取css文件、html文件并进行修改 快捷键： ctrl+shift+c 选取元素进行查看 ctrl+shift+m 模拟移动端进行查看]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考1</category>
      </categories>
      <tags>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo快速入门]]></title>
    <url>%2F2018%2F09%2F03%2Fhexo%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 快速开始创建一篇新文章1$ hexo new "My New Post" 详细信息: Writing 启用本地预览服务1$ hexo server 详细信息: Server 生成静态文件1$ hexo generate 详细信息: Generating 部署到远程站点1$ hexo deploy 详细信息: Deployment]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js取出事件对象中对应的值显示未定义]]></title>
    <url>%2F2018%2F08%2F30%2Fjs%E5%8F%96%E5%87%BA%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%AF%B9%E5%BA%94%E7%9A%84%E5%80%BC%E6%98%BE%E7%A4%BA%E6%9C%AA%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[问题描述:微信小程序使用data-*向事件内存储对象,js中取出对应值时显示未定义. wxml1&lt;text class=&quot;authorName db&quot; catchtap=&quot;toListDetail&quot; data-videoId=&quot;&#123;&#123;item.id&#125;&#125;&quot;&gt;&#123;&#123;item.teacher&#125;&#125;&lt;/text&gt; js1234toListDetail:function (event) &#123; let videoId = event.target.dataset.videoId; console.log(videoId);//undefined &#125; #问题出现原因:data-*书写方式： 以data-开头，多个单词由连字符-链接，连字符转成驼峰,不能有大写,大写会自动转成小写; 如data-element-type，最终在 event.currentTarget.dataset 中会将连字符转成驼峰elementType。 如data-videoId，最终在 event.currentTarget.dataset 中大写会自动转成小写 videoid。| wxml | event.currentTarget.dataset || ———— | ———— || data-element-type | elementType || data-videoId | videoid | 问题解决办法: 在组件中使用data-*定义数据，注意字母大小写. 需要使用驼峰命名的时候,以连字符拼接.]]></content>
      <categories>
        <category>微信小程序</category>
        <category>遇到的问题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序setData中键名key中使用变量]]></title>
    <url>%2F2018%2F08%2F30%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FsetData%E4%B8%AD%E9%94%AE%E5%90%8Dkey%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[setData 函数用于将数据从逻辑层发送到视图层（异步）,同时改变对应的 this.data 的值（同步）.setData中可以传入的参数Object 以 key: value 的形式表示,将 this.data 中的 key 对应的值改变成 value。其中 key 可以以数据路径的形式给出，支持改变数组中的某一项或对象的某个属性,有时我们需要在使用变量表示key,这时应该如何操作呢. 问题描述:例一:1234binddata: function (e) &#123; var idNum = e.target.id; this.setData(&#123; idNum: e.detail.value &#125;); &#125; idNum传过去，直接是data中多了一个’idNum’的数据，不是动态的id数值. 例二:123456changeIntro:function (event) &#123; let videoArrayIndex = event.target.dataset.index; this.setData(&#123; &apos;videoArray[videoArrayIndex].introState&apos; : true &#125;) &#125; 无法改变introState的值,因为videoArrayIndex没有被解析为序列号. #解决办法: ##一. 用一个空对象暂存123var data = &#123;&#125;data[key] = value // key 可以是任何字符串this.setData(data) 使用一个中间对象暂存解决上述例二1234567changeIntro:function (event) &#123; let videoArrayIndex = event.target.dataset.index; let dataIntro = &#123;&#125;; let keyIntro = &apos;videoArray[&apos;+videoArrayIndex+&apos;].introState&apos;; dataIntro[keyIntro] = true; // key 可以是任何字符串 this.setData(dataIntro) &#125; 二. 使用es6新特性ES6 允许声明在对象字面量时使用简写语法，来初始化属性变量和函数的定义方法，并且允许在对象属性中进行计算操作：123this.setData(&#123; [key]: value &#125;) 使用es6新特性解决上述例二123456changeIntro:function (event) &#123; let videoArrayIndex = event.target.dataset.index; this.setData(&#123; [&apos;videoArray[&apos;+videoArrayIndex+&apos;].introState&apos;] : true &#125;) &#125;]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序实现视图向js传递参数]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E8%A7%86%E5%9B%BE%E5%90%91js%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[有时候我们需要从小程序的视图页面向js文件传递参数,通过阅读官方文档发现可以通过向事件触发时绑定的事件对象存储数据达到效果. #实现原理如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。微信小程序中的事件对象 属性 类型 说明 type String 事件类型 timeStamp Integer 事件生成时的时间戳 target Object 触发事件的组件的一些属性值集合 currentTarget Object 当前组件的一些属性值集合 视图层上可以通过设置data-*向事件对象中存储数据,js中可以获取该事件对象event并取出其中存储的数据,从而达到视图页面向js文件传递参数的效果.事件对象详解 实例演示wxml12345 &lt;view&gt; &lt;button bindtap=&quot;showMoreText&quot; data-index=&quot;向js传递索引号&quot;&gt; 更多 &lt;/button&gt;&lt;/view&gt; js12345678Page(&#123; data: &#123; showMoreText:function (event) &#123; console.log(event); console.log(event.target.dataset.index) &#125; &#125;&#125;)]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown中使用html标签]]></title>
    <url>%2F2018%2F08%2F28%2FMarkdown%E4%B8%AD%E4%BD%BF%E7%94%A8html%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[有时候,我们会在笔记中使用一些HTML标签,但是Markdown中直接使用html标签会被解析为格式.该怎么书写，可以直接显示为html的标签呢. 12&lt;h1&gt;这是一个标题&lt;/h1&gt;//其中的&lt;h1&gt;这是一个标题&lt;/h1&gt;总是会被解析为成html标签，而不是直接显示为html标签。 问题出现原因：Markdown支持html语法，所以会对相应的标签进行解析。 问题解决办法： 使用引号把标签包起来1`&lt;h1&gt;这是一个标题&lt;/h1&gt;` &lt;h1&gt;这是一个标题&lt;/h1&gt; 使用转义字符来表示相应的标签1&amp;lt;h1&amp;gt;这是一个标题&amp;lt;/h1&amp;gt; &lt;h1&gt;这是一个标题&lt;/h1&gt; 相关工具： HTML在线转义工具]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序页面跳转]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[路由：路由在项目开发中一直是个核心点，在这里其实微信对路由的介绍很少，可见微信在路由方面经过很好的封装，也提供三个跳转方法。 三个跳转方法 wx.navigateTo(OBJECT)：保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。 wx.redirectTo(OBJECT)：关闭当前页面，跳转到应用内的某个页面。 wx.navigateBack()：关闭当前页面，回退前一页面。这三个基本上使用足够，在路由方面微信封装的很好，开发者根本不用去配置路由，往往很多框架在路由方面配置很繁琐。 问题描述：路由跳转失败出现原因：没有仔细看说明文档，需要在app。json中配置路由跳转的地址123456789101112131415&#123; &quot;pages&quot;:[ &quot;pages/personChoice/personChoice&quot;, &quot;pages/result/result&quot;, &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;:&#123; &quot;backgroundTextStyle&quot;:&quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;, &quot;navigationBarTextStyle&quot;:&quot;black&quot; &#125;&#125; 解决办法：仔细看说明文档注意:微信小程序的跳转有个坑。只能保留10个页面。历史记录有十个页面之后，跳转会失效。所以要适当的清除历史记录。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序上拉加载和下拉刷新]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%2F</url>
    <content type="text"><![CDATA[说明：要触发下拉刷新上拉加载事件，需要能够监听到事件才行 ,在需要实现下拉刷新上拉加载的页面配置对应页面xxx.json文件或者更改全局的app.json文件. 更改页面配置xxx.json文件页面配置xxx.json文件中添加以下字段12345&#123; &quot;enablePullDownRefresh&quot;:true,//是否开启下拉刷新 &quot;backgroundTextStyle&quot;:&quot;dark&quot;,//下拉背景字体、loading 图的样式，仅支持 dark/light，默认light不可见 &quot;onReachBottomDistance&quot;: 50//页面上拉触底事件触发时距页面底部距离，单位为px&#125; 自定义上拉记载触发的函数12345678910111213Page(&#123; data: &#123; &#125;, onReachBottom: function() &#123; wx.showToast(&#123; title: &apos;上拉触底&apos;, icon: &apos;success&apos;, duration: 2000 &#125;); console.log(&apos;--------上拉触底-------&apos;) &#125;&#125;);]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序将时间戳转化为几天前]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B0%86%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%87%A0%E5%A4%A9%E5%89%8D%2F</url>
    <content type="text"><![CDATA[需求描述: 文件创建时间与当前时间小于24小时,显示小时数,大于24小时,显示天数,时间戳转化为几天前，几小时前，几分钟前 代码演示wxs:1234567891011121314151617181920212223242526272829303132var getDateDiff = function (dateTimeStamp) &#123; var minute = 1000 * 60; var hour = minute * 60; var day = hour * 24; var halfamonth = day * 15; var month = day * 30; var now = getDate();//有些特殊 不能使用 new Date() var diffValue = now - dateTimeStamp; if(diffValue &lt; 0)&#123;return;&#125; var monthC =diffValue/month; var weekC =diffValue/(7*day); var dayC =diffValue/day; var hourC =diffValue/hour; var minC =diffValue/minute; if(monthC&gt;=1)&#123; result=&quot;&quot; + parseInt(monthC) + &quot;月前&quot;; &#125; else if(weekC&gt;=1)&#123; result=&quot;&quot; + parseInt(weekC) + &quot;周前&quot;; &#125; else if(dayC&gt;=1)&#123; result=&quot;&quot;+ parseInt(dayC) +&quot;天前&quot;; &#125; else if(hourC&gt;=1)&#123; result=&quot;&quot;+ parseInt(hourC) +&quot;小时前&quot;; &#125; else if(minC&gt;=1)&#123; result=&quot;&quot;+ parseInt(minC) +&quot;分钟前&quot;; &#125;else result=&quot;刚刚&quot;; return result;&#125;;//时间戳转化为几天前，几小时前，几分钟前]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>wxs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序视图层处理增强之WXS]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%86%E5%9B%BE%E5%B1%82%E5%A4%84%E7%90%86%E5%A2%9E%E5%BC%BA%E4%B9%8BWXS%2F</url>
    <content type="text"><![CDATA[WXS是专供WXML调用的有独立作用域的JS模块（不是全功能的JS，感觉有所限制）,可以在在视图层对数据进行格式化处理,起到过滤器的作用。 熟悉微信小程序开发框架的开发者，肯定会对其视图层WXML中缺失的一个功能耿耿于怀，那就是没有办法在视图层对数据进行格式化处理。比如我们从后端获取到一个包含了时间戳数据的数组，然后需要在界面上把这些日期都格式化显示为2017-01-01这种格式的日期形式，在Vue, Angular之类的前端Web框架中，一般在视图层都提供了如filter之类相应比较好用的方案。而在现有的微信小程序代码中？你能怎么做？估计我们的做法要么是在Page代码中遍历一次数组，做一下格式化；要么，只能让后端返回已经格式化好的数据了。 举个例子，在这之前，我们是没有办法在WXML的数据绑定括号1&#123;&#123;&#125;&#125; 中调用JS函数的，所以在WXML层面就缺少了进一步做数据处理的能力。下列代码是不工作的：12345678910111213&lt;!-- wxml文件 --&gt;&lt;view&gt;&#123;&#123;testFunc(name)&#125;&#125;&lt;/view&gt;// some-page.jsPage(&#123; data: &#123; name: &quot;一斤代码&quot; &#125;, testFunc: function (name) &#123; return &quot;Hello,&quot; + name &#125;&#125;) 而有了WXS之后，我们就可以实现我们预期的功能了：12345678910111213141516&lt;!-- wxml文件 --&gt;&lt;view&gt;&#123;&#123;myModule.testFunc(name)&#125;&#125;&lt;/view&gt;&lt;wxs module=&quot;myModule&quot;&gt; function testFunc(name) &#123; return &quot;Hello,&quot; + name &#125; module.exports.testFunc = testFunc&lt;/wxs&gt;// some-page.jsPage(&#123; data: &#123; name: &quot;一斤代码&quot; &#125;&#125;) WXS可以直接定义在wxml文件的标签体中，也可以写在独立的.wxs后缀名的文件中，然后在wxml文件中通过的形式引入。如要要在WXS代码中去引用其他独立.wxs文件，可以通过 require()函数来引入，基本上都是我们熟悉的方式：1234var formatUtil = require(&quot;./format-util.wxs&quot;);var now = getDate()formatUtil.formatDate(now) 所以，WXS在功能方面，并没有什么复杂的东西，唯一需要特别注意一些的，就是它的作用域了： 模块只能在定义模块的 WXML 文件中被访问到。使用 或 时， 模块不会被引入到对应的 WXML 文件中。 标签中，只能使用定义该 的 WXML 文件中定义的 模块。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>wxs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序设置过滤器将时间戳转化为日期字符串]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B0%86%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%97%A5%E6%9C%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[在微信开发小程序时，后台传入的日期数据可能是时间戳 而不是日期, 或者需要把日期转换成时间戳来做出相应的处理时,我们将用到时间戳和日期的相互转换. WXS是专供WXML调用的有独立作用域的JS模块（不是全功能的JS，感觉有所限制）,可以在在视图层对数据进行格式化处理,起到过滤器的作用。 js文件12345Page(&#123; data: &#123; timestamp: 1522117395730 &#125;&#125;) wxml文件12345678910111213&lt;wxs module=&quot;m1&quot;&gt; function format(ts) &#123; var d = getDate(ts) return [d.getFullYear(), d.getMonth()+1, d.getDate()].join(&apos;-&apos;) + &apos; &apos; + [d.getHours(), d.getMinutes(), d.getSeconds()].join(&apos;:&apos;) &#125; module.exports.format = format&lt;/wxs&gt;&lt;view&gt;&#123;&#123; timestamp &#125;&#125;&lt;/view&gt;&lt;view&gt;&#123;&#123; m1.format(timestamp) &#125;&#125;&lt;/view&gt; 注意:wxs 获取当前日期不可以使用 new Date()，而需要使用 getDate() 代替。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>wxs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述JavaScript中this的指向]]></title>
    <url>%2F2018%2F08%2F27%2F%E7%AE%80%E8%BF%B0JavaScript%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91%2F</url>
    <content type="text"><![CDATA[this的指向：本文重点介绍this作为对象方法调用，作为函数调用，作为构造函数调用，和使用apply 或 call 调用这几种，其他的情况了解即可，请牢记一点，this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的。 一.背景介绍 在面向对象的语言中（例如Java,C#等)，this含义是明确且具体的，即指向当前对象。一般在编译期绑定。而在javascript中，this是动态绑定的，它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式，并且在严格模式下也有不同，这就导致了this具备了多重含义，可以使得javascript更灵活的使用。但是，带来了灵活性的同时也会给我们初学者带来不少困惑。即使是细微的语法变化，都有可能意外改变this的值。 二.知识剖析JavaScript中函数的调用常用的有以下几种方式： 作为对象方法调用 作为函数调用 作为构造函数调用 使用apply 或 call 调用 下面我们将按照调用方式的不同，分别讨论this 的含义 1.纯粹的作为函数调用：全局函数中，this指向window 1234function a()&#123; console.log(this);&#125;a(); 2.作为对象方法的调用：当函数被作为某个对象的方法调用时，this就是那个对象 1234567891011var name = &apos;火影&apos;;var person2 = &#123; name: &apos;水影&apos;, sayName: function() &#123; console.log(this.name); &#125;&#125;;var sayNameWin = person2.sayName;person2.sayName(); //水影sayNameWin(); //火影 作为 window 的方法被调用的 3.作为构造函数调用：this指向新对象 123456function Person3(name) &#123; this.name = name; console.log(this);&#125;var person3 = new Person3(&apos;张飒&apos;);console.log(person3.name); //张飒 4.apply、call调用：this指向改变后的调用这个函数的对象12345678var person4 = &#123; name: &apos;人才&apos;&#125;;function fn() &#123; console.log(this); //Object &#123;name: &quot;人才&quot;&#125; console.log(this.name); //人才&#125;fn.apply(person4); 三.拓展思考如何能加深记忆？this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的。 四.参考文献深入浅出 JavaScript 中的 thisJavaScript中的this用法与指向如何理解 JavaScript 中的 this 关键字？ 五.更多讨论1. 如果想让一个this指向函数内部，但是它指向了全局，有什么办法让它指向函数内部？使用call方法或者apply方法给它指定this，或者把他作为对象的方法调用 2. setTimeout、setInterval中的this是指向哪里？《 javascript 高级程序设计》中写到：“超时调用的代码都是在全局执行域中执行的”。setTimeout/setInterval 执行的时候，this 默认指向 window 对象，除非手动改变 this 的指向。 3. 简单说一下this 到底有几种指向？我们重点掌握作为对象方法调用，作为函数调用，作为构造函数调用，和使用apply 或 call 调用这几种，其他的情况了解即可，]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步请求之设置请求头Content-Type]]></title>
    <url>%2F2018%2F08%2F25%2F%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E4%B9%8B%E8%AE%BE%E7%BD%AEContent-Type%2F</url>
    <content type="text"><![CDATA[什么是AJAX: 先给出结论——我们每日用到的AJAX，是通过javascript的XMLHttpRequest对象，使用HTTP请求，来直接与服务器通信。而angular的$http服务，其内部代码也是使用XMLHttpRequest对象来连接服务器。 #问题：为什么这个post请求不能成功，服务器返回码虽然是200，但它值总是不对？？？ #答案：除开请求参数，请求地址等基本错误外，还有可能有一个非常重要的原因就是请求头中的Content-Type不对。 #基础知识：HTTP，是一套网络通信规则，让我们可以通过浏览器等客户端请求和发送数据到服务器。 #每次HTTP通信需要完成7个步骤：1.建立TCP连接2.浏览器向服务器发送请求命令3.浏览器发送请求头信息4.服务器应答5.服务器发送应答头信息6.服务器向浏览器发送数据7.关闭TCP连接 进一步诠释HTTP（可以不看的部分）： 请求头声明有关浏览器和正文的一些相关信息1234567Content-Encoding:gzipContent-Language:zh-CNContent-Type:text/html; charset=utf-8Date:Wed, 11 Jan 2017 01:48:38 GMTPragma:no-cacheServer:nginx/1.4.6 (Ubuntu)Transfer-Encoding:chunked 应答码 1XX 收到请求，正在处理 2XX 成功类 3XX 重定向类 4XX 客户端错误类（著名的404，表示请求的页面不存在） 5XX 服务器错误类 响应头也包含很多服务信息12345678910111213141516Accept:application/json, text/plain, */* Accept-Encoding:gzip, deflate, sdch Accept-Language:zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4 Connection:keep-alive Cookie:JSESSIONID=aaa6A1XXqQ-QbbwfPOZGv Host:59.110.159.108 Referer:http://59.110.159.108/luoboduo/html/index.html User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36 6.服务器返回的数据（JSON/XML/….）{&quot;code&quot;:0,&quot;message&quot;:&quot;success&quot;,&quot;onlineUserCount&quot;:&quot;&quot;,&quot;classCount&quot;:308,&quot;userCount&quot;:8507} 详细讲讲Content-Type因为POST请求的协议并没有规定数据必须使用什么编码方式，而数据发送出去，还要服务器解析成功才行。服务器则通常根据请求头里的Content-Type字段来获知消息是以什么方式编码，再以对应方式解析。而有的接口服务器则不能解析某些编码方式的数据。因此需要对Content-Type进行设置。 最常见的Content-Type列出如下： ##1. application/x-www-form-urlencoded 最常见的POST提交格式，使用这个编码格式post的数据会以这种方式提交：key1=value1&amp;key2=value2。而我们的任务中所用到的大多数接口都只支持这种编码格式。 注意：jquery的POST默认就是application/x-www-form-urlencoded；而angular默认是application/json，而且若是提交的数据格式为json则需要序列化$.param(json) ##2. multipart/form-data 通常上传图片等文件会使用这种编码格式提交。 使用方法： var fd = new FormData(); fd.append(key, value); 注意：若使用jquery，Content-Type设置为false；若使用angular，Content-Type设置为undefind 3. application/json 提交JSON格式的数据 注意：若使用jquery，json数据需要字符串化JSON.stringify()；若使用angular，直接使用json即可]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>xhr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何验证程序是否完成，测试以及deBug?]]></title>
    <url>%2F2018%2F08%2F24%2F%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%90%A6%E5%AE%8C%E6%88%90%EF%BC%8C%E6%B5%8B%E8%AF%95%E4%BB%A5%E5%8F%8A%E4%BF%AE%E6%AD%A3Bug%2F</url>
    <content type="text"><![CDATA[在日常中，我们码代码都是按照需求来的，为了验证我们的工作成果是否符合项目的需求，那么验证程序是否完成、测试以及修复bug就成了我们工作中非常重要的流程。 一.背景介绍在日常中，我们码代码都是按照需求来的，为了验证我们的工作成果是否符合项目的需求，那么验证程序是否完成、测试以及修复bug就成了我们工作中非常重要的流程。 二.知识剖析 什么样的程序是完成的程序 从需求的角度看：满足用户的全部需求 从程序的角度看：代码不存在明显bug，结构明晰，逻辑通顺，有一定的优化 从UI图的角度看：较为完美的还原了UI图的设计 从后期版本维护迭代的角度看：注释完备，稳定性好，不加班的代码就是好代码 测试：测试是使用人工操作或者软件自动运行的方式来检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别的过程。软件测试的方法 按照测试范围，可以分为模块测试和整体联调 按照测试条件，可以分为正常操作情况测试和异常情况测试 按照测试的输入范围，可以分为全覆盖测试和抽样测试 按照测试方式模块测试：针对设计中的一个一个模块来进行测试的，目的是保证每个模块作为一个单元能正确运行，所以模块测试通常又被称为单元测试。在这个测试步骤中所发现的往往是编码和详细设计的错误。整体联调：测试模块间接口的正确性、各模块间的数据流和控制流是否按照设计实现其功能、以及集成后整体功能的正确性。正常操作情况测试：根据正确的操作流程对单独的模块或整体进行测试，确定被测对象可以良好运行异常情况测试：异常情况，可能会包括数据库异常，系统异常，用户异常操作等情况3.一些测试的概念成熟性：软件产品要避免由软件中错误而导致失效的能力容错性：在软件失效或者违反规定的接口的情况下，软件产品维持规定的性能级别的能力易恢复性：在发生故障的情况下，软件重建规定的性能级别并恢复受直接影响的数据的能力可靠性依从性：软件产品依附于同可靠性相关的标准、约定或规定的能力全覆盖测试：对于被测对象全面，整体，多维度的测试，受限于时间和人力成本，除非被测对象级别很高，不然不会采用这种测试方式抽样测试：针对功能及模块随机抽取被测对象 三.常见问题如何debug？ 四.解决方案老大在知乎上的回答： 确认Bug是否在本地可以重现。 确认Bug在哪一段代码中。 去除掉所有无关代码，只去调试和Bug相关的代码。 和之前正常运行的版本对比，尝试恢复到之前可以正常运行的代码。 重新写一个小Demo，确认是否可以正常运行，可以的话，移动代码到原有的代码中。 如果本地无法重现，打日志，观察线上行为。 重启服务，重启IDE，重启笔记本，重启服务器。 跟产品经理说这个Bug解决不了，花费的代价很大，不值得。 张明云在知乎上的回答：解决问题的流程：了解问题→定位问题→分析问题→解决问题→验证问题解决问题的方法(排名分先后) 借助搜索引擎：遇到有明显的异常信息，且自己并不熟悉为什么异常时，最高效的解决方法是借助搜索引擎，这里的搜索引擎一定是谷歌，不是百度；借助搜索引擎能解决工作中的大部分bug，你要相信，全世界这么多开发人员，你遇到过的大多数问题其他人也遇到过； 打印调试法：这是最笨但最有效的办法，人会说谎、断点调试可能会说谎，但日志一定不会说谎； 二分排除法：当你遇到随机问题、帮助他人解bug或者遇到自己不熟悉的代码时，通过屏蔽一部分代码，运行观察问题仍然存在，如果存在则进一步分析屏蔽一部分代码，直到定位到有问题的具体位置为止，这种方法能解决工作中的很大一部分疑难杂症； 小黄鸭调试法：当你向某个对象陈述你的思路时，往往会有意想不到的结果，哪怕对方并不是一个生物； 断点调试法：受限于效率不高以及在多线程环境下断点调试并不灵，有必要时才考虑用这种方法；通常可以使用打印调试法来代替； 线上求助：包括论坛提问、RTX和微信群提问等；不到万不得已不要用这种办法，在有限的圈子里面，你遇到的一个具体技术问题很有可能其他人并没有遇到过，多数时候问了也是白问，但有时候也可能是一种有效的方法。 五.编码实战#六.拓展思考 什么是小黄鸭调试法? 小黄鸭调试法，又称橡皮鸭调试法、黄鸭除虫法（Rubber Duck Debugging）是可在软件工程中使用的一种调试代码的方法。方法就是在程序的调试、除错或测试过程中，操作人耐心地向小黄鸭解释每一行程序的作用，以此来激发灵感与发现矛盾。 此概念是参照于一个故事。故事中程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码。许多程序员都有向别人提问及解释编程问题的经历，而目标甚至可能是完全不懂编程的人。而就在解释的过程中，程序员可能就发觉了问题的解决方案。一边阐述代码的意图，一边观察它实际上的意图并做调试，两者间的任何不协调都会变得更明显，使人更容易发现错误所在。如果没有玩具小鸭，操作人也可以向其他任何东西倾诉，比如桌上的盆栽、键盘/鼠标等。 七.参考资料软件开发流程如何提高测试覆盖率测试分析中对异常情况考虑软件异常测试断点调试老程序员解bug有那些通用套路？ 八.更多讨论Q: bug的优先级有哪几种？ critical(危险的)：是说项目中某一块功能因为这个bug而导致测试无法进行下去，此critical级别，该等级问题出现在不影响其他功能测试的情况下可以继续该版本试block是说项目中有闪退情况，崩溃情况。此为block级别，出现这种级别的问题此本停止测试 major(重要的)：是说一些功能没有实现，但是不影响使用，功能菜单缺失，但不会影响系统稳定。此为major，这种问题应该合理安排时间进行修改 normal(普通的)：是说界面等UI问题显示错误，比如字体大小，颜色，间距等问题。此类问题在测试初期较多，优先程度较低；在测试后期出现较少，应及时处理） minor(次要的)：是说界面、性能缺陷，建议类问题，不影响操作功能的执行，可以优化性能的方案等。 Q: 日志和断点的优劣？对于少量数据的检测，断点操作比较麻烦，日志很直接。但是对于比较复杂的代码，打断点能更好的理清逻辑和检查数据。 Q: 如何避免写出bug？改动代码时要考虑到对其他模块的影响；思考问题要全面，考虑到可能发生的各种情况；从其他地方找到的代码要弄清楚原理，了解这个知识点，再用到自己的项目中。 相关链接ppt地址腾讯视频地址csdn博客地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6 新特性简要总结]]></title>
    <url>%2F2018%2F08%2F15%2FES6-%E6%96%B0%E7%89%B9%E6%80%A7%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 一、 let、const 和 块级作用域let 允许创建块级作用域，ES6 推荐在函数中使用 let 定义变量，而非 var：123456var a = 2;&#123; let a = 3; console.log(a); // 3&#125;console.log(a); // 2 同样在块级作用域有效的另一个变量声明方式是 const，它可以声明一个常量。ES6 中，const 声明的常量类似于指针，它指向某个引用，也就是说这个「常量」并非一成不变的，如：123456&#123; const ARR = [5,6]; ARR.push(7); console.log(ARR); // [5,6,7] ARR = 10; // TypeError&#125; 有几个点需要注意： let 关键词声明的变量不具备变量提升（hoisting）特性 let 和 const 声明只在最靠近的一个块中（花括号内）有效 当使用常量 const 声明时，请使用大写变量，如：CAPITAL_CASING const 在声明时必须被赋值 二、箭头函数ES6 中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =&gt;，紧接着是函数体：123456var getPrice = function() &#123; return 4.55;&#125;; // Implementation with Arrow Functionvar getPrice = () =&gt; 4.55; 三、 函数参数默认值ES6 中允许你对函数参数设置默认值：(当没有传递该参数的具体值的时候，使用默认值)12let getFinalPrice = (price, tax=0.7) =&gt; price + price * tax;getFinalPrice(500); // 850 四、Spread / Rest 操作符Spread / Rest 操作符指的是 …，具体是 Spread 还是 Rest 需要看上下文语境。 当被用于迭代器中时，它是一个 Spread 操作符：123456function foo(x,y,z) &#123; console.log(x,y,z);&#125; let arr = [1,2,3];foo(...arr); // 1 2 3 当被用于函数传参时，是一个 Rest 操作符：1234function foo(...args) &#123; console.log(args);&#125;foo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5] 五、对象词法扩展ES6 允许声明在对象字面量时使用简写语法，来初始化属性变量和函数的定义方法，并且允许在对象属性中进行计算操作：12345678910111213141516171819202122232425function getCar(make, model, value) &#123; return &#123; // 简写变量 make, // 等同于 make: make model, // 等同于 model: model value, // 等同于 value: value // 属性可以使用表达式计算值 [&apos;make&apos; + make]: true, // 忽略 `function` 关键词简写对象函数 depreciate() &#123; this.value -= 2500; &#125; &#125;;&#125;let car = getCar(&apos;Barret&apos;, &apos;Lee&apos;, 40000); //car: &#123;// make: &apos;Barret&apos;,// model:&apos;Lee&apos;,// value: 40000,// makeBarret: true,// depreciate: function()// &#125; 六、二进制和八进制字面量ES6 支持二进制和八进制的字面量，通过在数字前面添加 0o 或者0O 即可将其转换为八进制值：12345let oValue = 0o10;console.log(oValue); // 8 let bValue = 0b10; // 二进制使用 `0b` 或者 `0B`console.log(bValue); // 2 七、对象和数组解构解构可以避免在对象赋值时产生中间变量：1234567891011121314151617function foo() &#123; return [1,2,3];&#125;let arr = foo(); // [1,2,3] let [a, b, c] = foo();console.log(a, b, c); // 1 2 3 function bar() &#123; return &#123; x: 4, y: 5, z: 6 &#125;;&#125;let &#123;x: x, y: y, z: z&#125; = bar();console.log(x, y, z); // 4 5 6 八、对象超类ES6 允许在对象中使用 super 方法（用于继承父级的方法）： 使用super后，必须使用Object.setPrototypeOf方法指定父级12345678910111213141516var parent = &#123; foo() &#123; console.log(&quot;Hello from the Parent&quot;); &#125;&#125; var child = &#123; foo() &#123; super.foo(); console.log(&quot;Hello from the Child&quot;); &#125;&#125; Object.setPrototypeOf(child, parent);child.foo(); // Hello from the Parent // Hello from the Child 九、模板语法和分隔符ES6 中有一种十分简洁的方法组装一堆字符串和变量。 ${ … } 用来渲染一个变量 ` 作为分隔符12let user = &apos;Barret&apos;;console.log(`Hi $&#123;user&#125;!`); // Hi Barret! 十、 for…of VS for…infor…of 用于遍历一个迭代器，如数组：123456let nicknames = [&apos;di&apos;, &apos;boo&apos;, &apos;punkeye&apos;];nicknames.size = 3;for (let nickname of nicknames) &#123; console.log(nickname);&#125;// 结果: di, boo, punkeye for…in 用来遍历对象中的属性：123456let nicknames = [&apos;di&apos;, &apos;boo&apos;, &apos;punkeye&apos;];nicknames.size = 3;for (let nickname in nicknames) &#123; console.log(nickname);&#125;Result: 0, 1, 2, size 十一、Map 和 WeakMapES6 中两种新的数据结构集：Map 和 WeakMap。事实上每个对象都可以看作是一个 Map。 Map: 键值对的键名、键值都可以为任意数据结构的对象； 一个对象由多个 key-val 对构成，在 Map 中，任何类型都可以作为对象的 key，如：1234567891011121314151617var myMap = new Map(); var keyString = &quot;a string&quot;, keyObj = &#123;&#125;, keyFunc = function () &#123;&#125;; // 设置值myMap.set(keyString, &quot;value 与 &apos;a string&apos; 关联&quot;);myMap.set(keyObj, &quot;value 与 keyObj 关联&quot;);myMap.set(keyFunc, &quot;value 与 keyFunc 关联&quot;); myMap.size; // 3 // 获取值myMap.get(keyString); // &quot;value 与 &apos;a string&apos; 关联&quot;myMap.get(keyObj); // &quot;value 与 keyObj 关联&quot;myMap.get(keyFunc); // &quot;value 与 keyFunc 关联&quot; 属性：Map.size返回Map实例成员的总数；方法：操作方法(5种)+遍历方法(4种) 操作方法 Map.set(key,value)：设置key值对应的值，如果key存在，则覆盖原有值； Map.get(key)：获取键名为key的键值； Map.has(key)：检查键名key是否存在Map实例中，返回boolean值，若存在返回true,不存在返回false; Map.delete(key)：删除键名为key的属性，返回boolean值，若删除成功返回true,失败返回false; Map.clear()：清除Map实例的所有成员，无返回值 遍历方法 Map.keys()：返回键名的遍历器 Map.values()：返回键值的遍历器 Map.entries()：返回所有成员的遍历器 Map.forEach((value,key,map)=&gt;{},thisObj)：遍历Map的所有成员 WeakMap : 键名只能为对象的Map，弱引用 WeakMap 就是一个 Map，只不过它的所有 key 都是弱引用，意思就是 WeakMap 中的东西垃圾回收时不考虑，使用它不用担心内存泄漏问题。 另一个需要注意的点是，WeakMap 的所有 key 必须是对象。它只有四个方法 delete(key),has(key),get(key) 和set(key, val)：1234567891011121314151617let w = new WeakMap();w.set(&apos;a&apos;, &apos;b&apos;); // Uncaught TypeError: Invalid value used as weak map key var o1 = &#123;&#125;, o2 = function()&#123;&#125;, o3 = window; w.set(o1, 37);w.set(o2, &quot;azerty&quot;);w.set(o3, undefined); w.get(o3); // undefined, because that is the set value w.has(o1); // truew.delete(o1);w.has(o1); // false 十二、Set 和 WeakSetSet 对象是一组不重复的值，重复的值将被忽略，值类型可以是原始类型和引用类型：Set —没有重复成员元素的数组 本质：Set本身是一个构造函数；接收一个具有iterable接口数据结构的参数，用来生成一个没有重复元素的数组； 12345let nums=new Set([1,2,3,4,3,2]);//[1,2,3,4]nums.add(2);//[1,2,3,4]nums.add(&apos;2&apos;);//[1,2,3,4,&apos;2&apos;]nums.add(&#123;&#125;);//[1,2,3,4,&apos;2&apos;,&#123;&#125;] Set添加元素时不会发生类型转换，nums.add(&#123;&#125;);//[1,2,3,4,&apos;2&apos;,&#123;&#125;,&#123;&#125;] Set添加的对象总不相等 两类8个方法：操作方法(4种）+遍历方法(4种)操作方法 Set.add(value)：向Set实例添加值value，返回Set结构本身 ; Set.delete(value)：向Set实例删除值value，返回boolean, 成功为true，失败返回false; Set.has(value)：检查Set实例是否含有值value，返回boolean，包含返回true，不包含返回false Set.clear()：清楚Set实例的所有成员，无返回值； 遍历方法 Set.keys()：返回键名的遍历器； Set.values()：返回键值的遍历器； Set.entries()：返回键值对的遍历器； Set.forEach((value,key)=&gt;{},thisObj)：使用回调函数遍历每个成员 使用场景 使用场景：数组去重、求数组的交集、并集、差集123456789101112// ①数组去重let arr=[1,2,3,4,3,2,1];let b=[...arr];//[1, 2, 3, 4, 3, 2, 1]let a=Array.from(new Set(arr));//[1,2,3,4]let c = [...new Set(arr)];//[1,2,3,4]// ②数组运算let arr1=new Set([1,2,3,4]);let arr2=new Set([3,4,5,6]);let union=new Set([...arr1,...arr2]);//[1,2,3,4,5,6]let intersect=new Set([...arr1].filter(value=&gt;b.has(value)));//[3,4]let diffrence=new Set([...arr1].filter(value=&gt;!b.has(value)));//[1,2] WeakSet—成员只能是对象的Set+ WeakSet的成员只能是对象不能是其他类型值；+ WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用； 弱引用，即当一个WeakSet实例的成员引用对象A时，当其他对象不在引用对象A，JS的垃圾回收机制便会自动回收该对象占用的内存，不考虑WeakSet实例是否还在引用；弱引用的对象随时可能消失，无法保证成员的存在，因此WeakSet相比较Set数据结构，没有clear(）方法、没有size属性、也没有遍历方法; 十三、类ES6 中有 class 语法。值得注意是，这里的 class 不是新的对象继承模型，它只是原型链的语法糖表现形式。 函数中使用 static 关键词定义构造函数的的方法和属性：类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 12345678910111213141516171819class Task &#123; constructor() &#123; console.log(&quot;task instantiated!&quot;); &#125; showId() &#123; console.log(23); &#125; static loadAll() &#123; console.log(&quot;Loading all tasks..&quot;); &#125;&#125; console.log(typeof Task); // functionlet task = new Task(); // &quot;task instantiated!&quot;task.showId(); // 23task.loadAll(); //loadAll不是一个函数Task.loadAll(); // &quot;Loading all tasks..&quot; 类中的继承和超集： 12345678910111213141516class Car &#123; constructor() &#123; console.log(&quot;Creating a new car&quot;); &#125;&#125; class Porsche extends Car &#123; constructor() &#123; super(); console.log(&quot;Creating Porsche&quot;); &#125;&#125; let c = new Porsche();// Creating a new car// Creating Porsche extends 允许一个子类继承父类，需要注意的是，子类的constructor 函数中需要执行 super() 函数。 当然，你也可以在子类方法中调用父类的方法，如super.parentMethodName()。 有几点值得注意的是： 类的声明不会提升（hoisting)，如果你要使用某个 Class，那你必须在使用之前定义它，否则会抛出一个 ReferenceError 的错误 在类中定义函数不需要使用 function 关键词 十四、SymbolES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。 12var sym = Symbol( &quot;some optional description&quot; );console.log(typeof sym); // symbol 注意，这里 Symbol 前面不能使用 new 操作符。如果它被用作一个对象的属性，那么这个属性会是不可枚举的. 十五、 PromisesES6 对 Promise 有了原生的支持，一个 Promise 是一个等待被异步执行的对象，当它执行完成后，其状态会变成 resolved 或者rejected。123456789var p = new Promise(function(resolve, reject) &#123; if (/* condition */) &#123; // fulfilled successfully resolve(/* value */); &#125; else &#123; // error, rejected reject(/* reason */); &#125;&#125;); 每一个 Promise 都有一个 .then 方法，这个方法接受两个参数，第一个是处理 resolved 状态的回调，一个是处理 rejected 状态的回调：12p.then((val) =&gt; console.log(&quot;Promise Resolved&quot;, val), (err) =&gt; console.log(&quot;Promise Rejected&quot;, err));]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[取消浏览器对页面滚动条位置的记录]]></title>
    <url>%2F2018%2F08%2F11%2F%E5%8F%96%E6%B6%88%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%E6%9D%A1%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[浏览器在导航跳转和通过 History API 创建历史记录时，都会记录当前的垂直滚动距离，在重新访问时恢复这个距离。如何取消记录当前的垂直滚动距离,使其刷新时可以回到顶部呢? 问题描述：项目提出bug，当正在浏览页面的时候点击返回首页此时页面停留在页面顶部，然后立即刷新，页面会回到刚才浏览的部分。期望：当浏览时刷新可以保存滑动条的位置但是当点击首页的时候不需要保存 问题出现原因：浏览器在导航跳转和通过 History API 创建历史记录时，都会记录当前的垂直滚动距离，在重新访问时恢复这个距离。 问题解决办法：1、初级版1234567891011$(&quot;.toIndex&quot;).click(function()&#123; if (&apos;scrollRestoration&apos; in history) &#123; history.scrollRestoration = &apos;manual&apos;; &#125;&#125;);//去除默认的滚动恢复行为var recoverAuto = function () &#123; if (&apos;scrollRestoration&apos; in history) &#123; history.scrollRestoration = &apos;auto&apos;; &#125;&#125;;setTimeout(recoverAuto,1800);//回复默认的滚动恢复行为 给返回首页添加点击事件，关闭记录当前的垂直滚动距离浏览器行为。但是这样会导致之后也无法保存滚动条的位置，所以后面加了一个定时器，在1.8s之后恢复浏览器的记录行为。缺点：如果用户在1.8s之内浏览页面并刷新，不会回到浏览位置。 2、 终极方案（从根本上解决问题，无bug）123$(&quot;.toIndex&quot;).click(function()&#123; $(&apos;body,html&apos;).scrollTop(0);&#125;);//返回首页的同时将滑动条置顶 给返回首页添加点击事件，返回首页的同时将滑动条置顶，让浏览器记录一个在顶部的历史记录。 相关知识 平常使用浏览器的后退功能时，常常会发现返回的页面滚动到了之前的位置，而不是简单的回到顶部。这是由于浏览器在导航跳转和通过 History API 创建历史记录时，都会记录当前的垂直滚动距离，在重新访问时恢复这个距离。值得一提的是，在 HTML History Spec中并没有强制要求浏览器记录与恢复滚动距离。 引入新的 API为了让开发者能够通过编程方式关闭这一浏览器行为，《浏览器恢复滚动提案》引入了新的 API：1234if (&apos;scrollRestoration&apos; in history) &#123; // 默认值为&apos;auto&apos; history.scrollRestoration = &apos;manual&apos;;&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown 配置七牛云作为图床]]></title>
    <url>%2F2018%2F07%2F31%2FMarkdown-%E9%85%8D%E7%BD%AE%E4%B8%83%E7%89%9B%E4%BA%91%E4%BD%9C%E4%B8%BA%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[Hexo在使用Markdown编辑发布博客时，经常要上传本地图片，渲染加载图片的效果很不理想。推荐使用云平台作为图床，提高编辑效率和图片效果。 一. 注册七牛云账号 七牛云注册地址 新增存储空间。注册完成之后，在资源主页中的对象存储里添加对象，如添加image 简单的上传图片，复制外链 二. 使用插件（Mpic）Mpic下载 之前我在没有发现Mpic这款软件的时候，将图片上传到七牛云存储总共分四步： 登录打开七牛云网页个人存储空间 上传图片 复制外链 粘贴到 Markdown 一张图片的上传整整用了四步，特别麻烦。直到LZ最近发现了Mpic之后，才发现，上传图片原来也能这么简单。使用Mpic，只需要将七牛云存储的账号信息配置一次(参考：如何设置七牛云存储账号？)，就可以将以上这四个步骤合为一个。同时，MPic提供了点击上传、拖曳上传、截图上传、复制上传四种上传图片的方法，更是让人感叹好的软件极大的提高了效率啊。 配置Mpic插件，获取密匙进入七牛云个人中心的密钥管理，获取AccessKey和SecretKey 三. 使用极简图床使用极简图床,关联七牛云账号]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用js或css实现瀑布流（Pinterest）布局教程]]></title>
    <url>%2F2018%2F07%2F30%2F%E4%BD%BF%E7%94%A8js%E6%88%96css%E5%AE%9E%E7%8E%B0%E7%80%91%E5%B8%83%E6%B5%81%EF%BC%88Pinterest%EF%BC%89%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[瀑布流，又称瀑布流式布局。这种布局适合于小数据块，每个数据块内容相近且没有侧重。通常，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。 瀑布流布局实例一、JS实现 代码：js实现瀑布流布局代码 demo：js实现瀑布流布局demo 二、CSS实现 Multi-columns Flexbox Grid 总结：这篇文章主要介绍了如何实现瀑布流的布局。文章简单介绍了css三种实现方案：Multi-columns、Flexbox和Grid。从上面的示例或者实现手段而言，较为友好的是Flexbox的方案。当然，随着CSS Grid特性的完善，使用Grid实现瀑布流布局将会变得更为简单和友好。以及一种相对简单的js实现方案。]]></content>
      <categories>
        <category>层叠样式表CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏捷开发流程]]></title>
    <url>%2F2018%2F07%2F30%2F%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[敏捷软件开发，又称敏捷开发，是一种从1990年代开始逐渐引起广泛关注的一些新型软件开发方法，是一种应对快速变化的需求的一种软件开发能力。它们的具体名称、理念、过程、术语都不尽相同，相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发过程中人的作用。 一、story讲解 制作竞品分析PPT，UE全组参与。（用时：根据产品复杂度，0.5-2小时之内） 制作产品原型，交由客户看，客户没有异议之后禅道录入story 产品在禅道拆分好story，并且定义出优先级，关联需求，后续开发根据优先级进行开发 由产品讲解story，前端和后端都参与。（用时：根据产品的复杂度，1-3小时之内） 二、人员划分 新建wiki项目主页，把PPT和产品原型（HTML文件）上传到wiki 根据产品原型，按照模块划分相关负责人，前端和后端都是，并放到wiki。（由项目负责人新建） 三、定义接口文档（2-3天） 前端后端相关人员一起，对照原型，根据模块及页面大概定义出接口 一个页面中有几个接口，每个接口入参与出参是什么 后端每个模块的负责人，根据开会讨论的结果，在wiki上生成标准的接口文档 将后端做好的接口文档发给前端模块负责人过目，有问题继续修改；没问题开始后续的步骤 。 四、方案设计（1小时-1天左右，根据模块大小定义时间） 后端开发人员，根据原型以及定义的接口，做好方案设计 对有难度或者有疑点的接口，做出方案，尽量给出多个合理方案 每个方案写清楚优点缺点 五、方案评审（2-3小时） 对做出的方案设计，做方案评审，建议全体人员参与（无论做不做该项目） 六、禅道拆分（1-2小时） 相关负责人按照优先级顺序，在禅道拆分自己的任务，单个任务最多不要超过4小时，即拆分要详细 拆分一个task时，以具体写的代码为一个task，并在任务名称中写出该类/方法的名称在任务描述中写出该task的代码块具体有的功能 当拆完task后，这几个task所完成功能的代码已经过了一遍 如果有不了解的功能，在方案评审前先写出一个demo，以方便拆分task的估时 一个task用时应在0.5-2之间，最大最大4个小时 以文件上传功能为例，分成3个task task1.任务名称：公共模块-文件上传-上传文件controller的方法fileUpload任务描述：通过网页获取文件，文件判空，判断文件的归属类型（用户/教材/课时/步骤/咨询）工时：1 task2.任务名称：公共模块-文件上传-添加文件FileUtil 和FileUtilOssImpl任务描述：util处理上传的文件，判断文件类型，大小，设置文件上传的路径，返回的url工时：1.5 task3.任务名称：公共模块-文件上传-文件接口spring-fileOss.xml 配置文件任务描述：oss的文件上传， 调用的spring.xml配置文件（密匙，ID,bucket等）工时：1.5 七、开发 搭建开发服务器 开发人员根据禅道上的任务，按时完成自己的开发工作，具体体现到日报上 每天上午开10分钟左右进度会议，如果有延迟现象出现，拿出解决方案，保证项目按照禅道上的时间点完成 数据库索引(两种索引): 经常查询的，数据散列度比较高的，做一般索引，不需要建联合索引。 数据必须保持唯一的，建唯一索引。(要有文档，文档表明哪些字段要建索引。发邮件。) 八、阶段测试 每天至少发布一次代码到开发环境，并且保证发布完之后程序没问题(与开发并行) 九、性能测试和coderevivew（1天） 对每个接口做好性能测试 每个接口的响应时间不超过200ms，如果有超过的，做优化，尽量缩小到200ms内 完成codereview，根据codereview结论完成修改 十、压力测试 做好压测报告 十一、 Demodemo 发demo申请邮件，收件人包括产品、测试同学、前后端相关开发人员 主题：XX项目demo通知 内容：时间 地点 参会人员 开demo会议：主讲人：某个开发人员 会议途中产品和测试提出问题 发demo结果通知邮件(由产品同学发) demo结果 如果不通过，有哪些问题 如果不通过，召集第二次Demo会议，知道通过为止。第二次会议只需演示之前不通过的部分 测试 demo通过之后 开发人员对代码打tag（参考文档： 如何打tag 。） 开发人员部署测试环境，部署完成之后发邮件，写明域名； 交给测试人员进行测试，测试人员发送全体测试周期邮件 测试期间，如果有测试发现bug，会在禅道上面提出bug，禅道会发送邮件到各自开发人员的邮箱，开发人员要关注BUG邮件 ，及时确认BUG，及时修改 修改BUG之后，开发环境前端代码由前端同学自己部署，后端代码由后端同学自己部署 测试完成之后，测试或产品发送上线通知具体参看： 测试Bug划分及处理流程 。测试和线上环境发布流程： 测试及线上环境发布流程 。 十二、 发布测试环境、集成测试（2-3天） 禅道上建立bug，测试出bug，指派给相关人员修改 十三、发布线上环境，同时停止开发环境和测试环境十四、线上监控 错误报告]]></content>
      <tags>
        <tag>敏捷开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css常用命名规范]]></title>
    <url>%2F2018%2F07%2F29%2Fcss%E5%B8%B8%E7%94%A8%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[作为一个对代码负责的人，每次看见别人代码里混乱的命名，总是不禁心里一顿暗骂。问及写代码的人，他们的回答总是：我英文不好，不知道如何取名，都想破了脑袋。而一些QQ群里提问题的朋友截图代码，命名也是非常混乱。网上有很多人发表CSS常用命名的文章，也都挺好的，我只是一个收集者，和把自己的常用命名加上去，分享给有需要的人，希望大家以后写的代码自己看着舒服，别人维护着也舒服。 class的命名 头：header 内容：content/container 尾：footer 导航：nav navigation n.航行；航海 侧栏：sidebar 栏目：column 页面外围控制整体佈局宽度：wrapper 左右中：left right center 登录条：loginbar 标志：logo 广告：banner 页面主体：main 热点：hot 新闻：news 下载：download 子导航：subnav 菜单：menu 子菜单：submenu 搜索：search 友情链接：friendlink 页脚：footer 版权：copyright 滚动：scroll 内容：content 标签：tags 文章列表：list 提示信息：msg–message 小技巧：tips 栏目标题：title 加入：joinus 指南：guide 服务：service 注册：regsiter 状态：status 投票：vote 合作伙伴：partner id的命名页面结构 容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体佈局宽度：wrapper 左右中：left right center 导航 导航：nav 主导航：mainnav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary 功能 标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：register 搜索：search 功能区：shop 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标籤页：tab 文章列表：list 提示信息：msg 当前的: current 小技巧：tips 图标: icon 注释：note 指南：guild 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright]]></content>
      <categories>
        <category>层叠样式表CSS</category>
      </categories>
      <tags>
        <tag>命名规范</tag>
      </tags>
  </entry>
</search>
