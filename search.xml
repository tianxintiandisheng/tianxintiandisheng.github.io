<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>变量的解构赋值</title>
    <url>/2019/11/13/JS/ES6/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>以前，为变量赋值，只能直接指定值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>ES6 允许写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><a id="more"></a>




<p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</span><br><span class="line">third <span class="comment">// "baz"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</span><br><span class="line">x <span class="comment">// "a"</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>如果解构不成功，变量的值就等于<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo] = [];</span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>以上两种情况都属于解构不成功，<code>foo</code>的值都会等于<code>undefined</code>。</p>
<p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>上面两个例子，都属于不完全解构，但是可以成功。</p>
<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。</p>
<p>对于 Set 结构，也可以使用数组的解构赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line">x <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure>
<p>事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>fibs</code>是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>解构赋值允许指定默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></span><br></pre></td></tr></table></figure>
<p>注意，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。</p>
<p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>上面代码中，因为<code>x</code>能取到值，所以函数<code>f</code>根本不会执行。上面的代码其实等价于下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  x = f();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  x = [<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面最后一个表达式之所以会报错，是因为<code>x</code>用<code>y</code>做默认值时，<code>y</code>还没有声明。</p>
<h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>解构不仅可以用于数组，还可以用于对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">foo <span class="comment">// "aaa"</span></span><br><span class="line">bar <span class="comment">// "bbb"</span></span><br></pre></td></tr></table></figure>
<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">foo <span class="comment">// "aaa"</span></span><br><span class="line">bar <span class="comment">// "bbb"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于<code>undefined</code>。</p>
<p>如果解构失败，变量的值等于<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;foo&#125; = &#123;<span class="attr">bar</span>: <span class="string">'baz'</span>&#125;;</span><br><span class="line">foo <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，等号右边的对象没有<code>foo</code>属性，所以变量<code>foo</code>取不到值，所以等于<code>undefined</code>。</p>
<p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">console</span>;</span><br><span class="line">log(<span class="string">'hello'</span>) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<p>上面代码的例一将<code>Math</code>对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。例二将<code>console.log</code>赋值到<code>log</code>变量。</p>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">'hello'</span>, <span class="attr">last</span>: <span class="string">'world'</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line">f <span class="comment">// 'hello'</span></span><br><span class="line">l <span class="comment">// 'world'</span></span><br></pre></td></tr></table></figure>
<p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p>
<p>与数组一样，解构也可以用于嵌套结构的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br></pre></td></tr></table></figure>
<p>注意，这时<code>p</code>是模式，不是变量，因此不会被赋值。如果<code>p</code>也要作为变量赋值，可以写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br><span class="line">p <span class="comment">// ["Hello", &#123;y: "World"&#125;]</span></span><br></pre></td></tr></table></figure>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> node = &#123;</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; loc, <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">line <span class="comment">// 1</span></span><br><span class="line">loc  <span class="comment">// Object &#123;start: Object&#125;</span></span><br><span class="line">start <span class="comment">// Object &#123;line: 1, column: 5&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码有三次解构赋值，分别是对<code>loc</code>、<code>start</code>、<code>line</code>三个属性的解构赋值。注意，最后一次对<code>line</code>属性的解构赋值之中，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不是变量。</p>
<p>下面是嵌套赋值的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"> </span><br><span class="line">(&#123; <span class="attr">foo</span>: obj.prop, <span class="attr">bar</span>: arr[<span class="number">0</span>] &#125; = &#123; <span class="attr">foo</span>: <span class="number">123</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"> </span><br><span class="line">obj <span class="comment">// &#123;prop:123&#125;</span></span><br><span class="line">arr <span class="comment">// [true]</span></span><br></pre></td></tr></table></figure>
<p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: &#123;bar&#125;&#125; = &#123;<span class="attr">baz</span>: <span class="string">'baz'</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，等号左边对象的<code>foo</code>属性，对应一个子对象。该子对象的<code>bar</code>属性，解构时会报错。原因很简单，因为<code>foo</code>这时等于<code>undefined</code>，再取子属性就会报错。</p>
<p>注意，对象的解构赋值可以取到继承的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj1, obj2);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> &#123; foo &#125; = obj1;</span><br><span class="line">foo <span class="comment">// "bar"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>obj1</code>的原型对象是<code>obj2</code>。<code>foo</code>属性不是<code>obj1</code>自身的属性，而是继承自<code>obj2</code>的属性，解构赋值可以取到这个属性。</p>
<h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><p>对象的解构也可以指定默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;;</span><br><span class="line">msg <span class="comment">// "Something went wrong"</span></span><br></pre></td></tr></table></figure>
<p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，属性<code>x</code>等于<code>null</code>，因为<code>null</code>与<code>undefined</code>不严格相等，所以是个有效的赋值，导致默认值<code>3</code>不会生效。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>（1）如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure>
<p>上面代码的写法会报错，因为 JavaScript 引擎会将<code>{x}</code>理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p>
<p>（2）解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">'abc'</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure>
<p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p>
<p>（3）由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码对数组进行对象解构。数组<code>arr</code>的<code>0</code>键对应的值是<code>1</code>，<code>[arr.length - 1]</code>就是<code>2</code>键，对应的值是<code>3</code>。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）。</p>
<h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a <span class="comment">// "h"</span></span><br><span class="line">b <span class="comment">// "e"</span></span><br><span class="line">c <span class="comment">// "l"</span></span><br><span class="line">d <span class="comment">// "l"</span></span><br><span class="line">e <span class="comment">// "o"</span></span><br></pre></td></tr></table></figure>
<p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><p>函数的参数也可以使用解构赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数就是<code>x</code>和<code>y</code>。</p>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="comment">// [ 3, 7 ]</span></span><br></pre></td></tr></table></figure>
<p>函数参数的解构也可以使用默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数<code>move</code>的参数是一个对象，通过对这个对象进行解构，得到变量<code>x</code>和<code>y</code>的值。如果解构失败，<code>x</code>和<code>y</code>等于默认值。</p>
<p>注意，下面的写法会得到不一样的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>
<p>上面代码是为函数<code>move</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值，所以会得到与前一种写法不同的结果。</p>
<p><code>undefined</code>就会触发函数参数的默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x = <span class="string">'yes'</span></span>) =&gt;</span> x);</span><br><span class="line"><span class="comment">// [ 1, 'yes', 3 ]</span></span><br></pre></td></tr></table></figure>
<h2 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h2><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p>
<p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>
<p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p>
<h3 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h3><p>以下三种解构赋值不得使用圆括号。</p>
<p>（1）变量声明语句</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p>
<p>（2）函数参数</p>
<p>函数参数也属于变量声明，因此不能带有圆括号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[z,(x</span>)]) </span>&#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure>
<p>（3）赋值语句的模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>上面代码将整个模式放在圆括号之中，导致报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure>
<p>上面代码将一部分模式放在圆括号之中，导致报错。</p>
<h3 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h3><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是<code>p</code>，而不是<code>d</code>；第三行语句与第一行语句的性质一致。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>变量的解构赋值用途很多。</p>
<p><strong>（1）交换变量的值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>
<p>上面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>
<p><strong>（2）从函数返回多个值</strong></p>
<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>
<p><strong>（3）函数参数的定义</strong></p>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>（4）提取 JSON 数据</strong></p>
<p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure>
<p>上面代码可以快速提取 JSON 数据的值。</p>
<p><strong>（5）函数参数的默认值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// ... more config</span></span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p>
<p><strong>（6）遍历 Map 结构</strong></p>
<p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（7）输入模块的指定方法</strong></p>
<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>http状态码有那些？分别代表是什么意思？</title>
    <url>/2019/11/11/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%835/http%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="http状态码是什么"><a href="#http状态码是什么" class="headerlink" title="http状态码是什么"></a>http状态码是什么</h1><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p><p><strong>说人话：三位数字代码分别代表着不同的请求状态</strong></p><h1 id="状态码概括"><a href="#状态码概括" class="headerlink" title="状态码概括"></a>状态码概括</h1><h2 id="1XX"><a href="#1XX" class="headerlink" title="1XX"></a>1XX</h2><p>被接受，需要继续处理。</p><p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。</p><a id="more"></a>



<h2 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h2><p>请求成功</p>
<p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受</p>
<h2 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h2><p>请求被重定向</p>
<p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。</p>
<h2 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h2><p>请求错误</p>
<p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。</p>
<h2 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h2><p>服务器错误</p>
<p>这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1xx ： Hold on (等着)</p>
<p>2xx ： Here you go (执行完了，没毛病，拿着结果回去吧)</p>
<p>3xx ： Go away (你要的不在我这儿，去别处找)</p>
<p>4xx ： You fucked up (你丫出问题了)</p>
<p>5xx ： I fucked up (我特么出问题了)</p>
<h1 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h1><ul>
<li>200 OK 服务器成功处理了请求（这个是我们见到最多的）</li>
<li>304 Not Modified：服务端的资源与客户端上一次请求的一致，不需要重新传输，客户端使用本地缓存的即可</li>
<li>400 Bad Request：用于告诉客户端它发送了一个错误的请求</li>
<li>404 Not Found(页面丢失)未找到资源</li>
<li>500 Internal Server Error：服务器内部出现了错误</li>
<li>501 Internal Server Error服务器遇到一个错误，使其无法对请求提供服务</li>
</ul>
<h1 id="http状态码详解"><a href="#http状态码详解" class="headerlink" title="http状态码详解"></a>http状态码详解</h1><p>这里是对每个http状态的主要作用进行简单介绍。</p>
<p>关于详细的http状态有兴趣了解的朋友们，可以点这里：<a href="http://baike.baidu.com/link?url=djR1a8qTw3slQRLhArsZ41zApZKHoqs56LdRx9AnRyOPiVsBhO71S0ejuhqlRl_IarKDo13eM-MIsBNPVuofcpnHdtfB8fVN3zuLA1DorljDkkwMRRDXu6Aw4A8uCk_F" target="_blank" rel="noopener">HTTP状态码</a>,这里是百度百科的对http状态码的详细解析，是我看到的最全的了。 </p>
<h2 id="1XX-被接受等待处理"><a href="#1XX-被接受等待处理" class="headerlink" title="1XX 被接受等待处理"></a>1XX 被接受等待处理</h2><p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以<strong>除非在某些试验条件下</strong>，<strong>服务器禁止向</strong>此类<strong>客户端</strong>发送 <strong>1xx</strong> 响应。</p>
<p><strong>100（客户端继续发送请求，这是临时响应）</strong> ：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</p>
<p><strong>101服务器根据客户端的请求切换协议。</strong> 只能切换到更高级的协议，例如，切换到HTTP的新版本协议。</p>
<p><strong>102 (代表处理将被继续执行)</strong> 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</p>
<h2 id="2XX-成功接收"><a href="#2XX-成功接收" class="headerlink" title="2XX 成功接收"></a>2XX 成功接收</h2><p><strong>200   （成功）</strong>  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 </p>
<p><strong>201   （已创建）</strong>  请求成功并且服务器创建了新的资源。 </p>
<p><strong>202   （已接受）</strong>  服务器已接受请求，但尚未处理。 </p>
<p><strong>203   （非授权信息）</strong>  服务器已成功处理了请求，但返回的信息可能来自另一来源。 </p>
<p><strong>204   （无内容）</strong>  服务器成功处理了请求，但没有返回任何内容。 </p>
<p><strong>205   （重置内容）</strong> 服务器成功处理了请求，但没有返回任何内容。</p>
<p><strong>206   （部分内容）</strong>  服务器成功处理了部分 GET 请求。</p>
<p><strong>207 (代表之后的消息体将是一个XML消息)</strong>，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</p>
<h2 id="3XX-请求被重定向"><a href="#3XX-请求被重定向" class="headerlink" title="3XX 请求被重定向"></a>3XX 请求被重定向</h2><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p>
<p><strong>300   （多种选择）</strong>  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 </p>
<p><strong>301   （永久移动）</strong>  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</p>
<p><strong>302   （临时移动）</strong>  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
<p><strong>303   （查看其他位置）</strong> 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</p>
<p><strong>304   （未修改）</strong> 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 </p>
<p><strong>305   （使用代理）</strong> 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 </p>
<p><strong>307   （临时重定向）</strong>  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
<h2 id="4XX-请求错误"><a href="#4XX-请求错误" class="headerlink" title="4XX 请求错误"></a>4XX 请求错误</h2><p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p>
<p><strong>400   （错误请求）</strong> 服务器不理解请求的语法。 </p>
<p><strong>401   （未授权）</strong> 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 </p>
<p><strong>403   （禁止）</strong> 服务器拒绝请求。</p>
<p><strong>404   （未找到）</strong> 服务器找不到请求的网页。</p>
<p><strong>405   （方法禁用）</strong> 禁用请求中指定的方法。 </p>
<p><strong>406   （不接受）</strong> 无法使用请求的内容特性响应请求的网页。 </p>
<p><strong>407   （需要代理授权）</strong> 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</p>
<p><strong>408   （请求超时）</strong>  服务器等候请求时发生超时。 </p>
<p><strong>409   （冲突）</strong>  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 </p>
<p><strong>410   （已删除）</strong>  如果请求的资源已永久删除，服务器就会返回此响应。 </p>
<p><strong>411   （需要有效长度）</strong> 服务器不接受不含有效内容长度标头字段的请求。 </p>
<p><strong>412   （未满足前提条件）</strong> 服务器未满足请求者在请求中设置的其中一个前提条件。 </p>
<p><strong>413   （请求实体过大）</strong> 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 </p>
<p><strong>414   （请求的 URI 过长）</strong> 请求的 URI（通常为网址）过长，服务器无法处理。 </p>
<p><strong>415   （不支持的媒体类型）</strong> 请求的格式不受请求页面的支持。 </p>
<p><strong>416   （请求范围不符合要求）</strong> 如果页面无法提供请求的范围，则服务器会返回此状态代码。 </p>
<p><strong>417   （未满足期望值）</strong> 服务器未满足”期望”请求标头字段的要求。</p>
<h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><p>这些状态代码表示服务器在尝试处理请求时发生内部错误。</p>
<p>这些错误可能是服务器本身的错误，而不是请求出错。</p>
<p><strong>500   （服务器内部错误）</strong>  服务器遇到错误，无法完成请求。 </p>
<p><strong>501   （尚未实施）</strong> 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 </p>
<p><strong>502   （错误网关）</strong> 服务器作为网关或代理，从上游服务器收到无效响应。 </p>
<p><strong>503   （服务不可用）</strong> 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 </p>
<p><strong>504   （网关超时）</strong>  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 </p>
<p><strong>505   （HTTP 版本不受支持）</strong> 服务器不支持请求中所用的 HTTP 协议版本。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://blog.csdn.net/dufufd/article/details/53112184" target="_blank" rel="noopener">常见的HTTP状态码(HTTP Status Code)说明</a> </p>
<p><a href="http://baike.baidu.com/link?url=djR1a8qTw3slQRLhArsZ41zApZKHoqs56LdRx9AnRyOPiVsBhO71S0ejuhqlRl_IarKDo13eM-MIsBNPVuofcpnHdtfB8fVN3zuLA1DorljDkkwMRRDXu6Aw4A8uCk_F" target="_blank" rel="noopener">百度百科HTTP状态码</a> </p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何使用正则表达式？</title>
    <url>/2019/11/11/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%835/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h1><p>字符是计算机软件处理文字时最基本的单位，可能是字母，数字，标点符号，空格，换行符，汉字等等。字符串是0个或更多个字符的序列。文本也就是文字，字符串。说某个字符串匹配某个正则表达式，通常是指这个字符串里有一部分（或几部分分别）能满足表达式给出的条件。</p><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。</p><a id="more"></a>

<h1 id="正则表达式-简介"><a href="#正则表达式-简介" class="headerlink" title="正则表达式 - 简介"></a>正则表达式 - 简介</h1><p>除非您以前使用过正则表达式，否则您可能不熟悉一些术语。但是，毫无疑问，您已经使用过不涉及脚本的某些正则表达式概念。</p>
<p>例如，您很可能使用 ? 和 <em> 通配符来查找硬盘上的文件。? 通配符匹配文件名中的 0 个或 1 个字符，而 </em> 通配符匹配零个或多个字符。像 data(\w)?.dat 这样的模式将查找下列文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data.dat</span><br><span class="line">data1.dat</span><br><span class="line">data2.dat</span><br><span class="line">datax.dat</span><br><span class="line">dataN.dat</span><br></pre></td></tr></table></figure>
<p>使用 <em> 字符代替 ? 字符扩大了找到的文件的数量。data.</em>.dat 匹配下列所有文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data.dat</span><br><span class="line">data1.dat</span><br><span class="line">data2.dat</span><br><span class="line">data12.dat</span><br><span class="line">datax.dat</span><br><span class="line">dataXYZ.dat</span><br></pre></td></tr></table></figure>
<p>尽管这种搜索方法很有用，但它还是有限的。通过理解 * 通配符的工作原理，引入了正则表达式所依赖的概念，但正则表达式功能更强大，而且更加灵活。</p>
<p>正则表达式的使用，可以通过简单的办法来实现强大的功能。下面先给出一个简单的示例：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/03/CEBB49BB-B1AD-4539-AC7A-B40DDC62D1B2.jpg" alt="img"></p>
<ul>
<li>^ 为匹配输入字符串的开始位置。</li>
<li>[0-9]+匹配多个数字， [0-9] 匹配单个数字，+ 匹配一个或者多个。</li>
<li>abc$匹配字母 abc 并以 abc 结尾，$ 为匹配输入字符串的结束位置。</li>
</ul>
<p>我们在写用户注册表单时，只允许用户名包含字符、数字、下划线和连接字符(-)，并设置用户名的长度，我们就可以使用以下正则表达式来设定。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/09/regexp-cn.png" alt="img"></p>
<p>以上的正则表达式可以匹配 <strong>runoob、runoob1、run-oob、run_oob</strong>， 但不匹配 <strong>ru</strong>，因为它包含的字母太短了，小于 3 个无法匹配。也不匹配 <strong>runoob$</strong>, 因为它包含特殊字符。</p>
<h1 id="js中使用正则表达式"><a href="#js中使用正则表达式" class="headerlink" title="js中使用正则表达式"></a>js中使用正则表达式</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"123abc"</span>;</span><br><span class="line"><span class="keyword">var</span> patt1 = <span class="regexp">/^[0-9]+abc$/</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.match(patt1));</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行结果：123abc</p>
<h1 id="为什么使用正则表达式"><a href="#为什么使用正则表达式" class="headerlink" title="为什么使用正则表达式"></a>为什么使用正则表达式</h1><p>典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。</p>
<p>通过使用正则表达式，可以：</p>
<ul>
<li>测试字符串内的模式。<br>例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</li>
<li>替换文本。<br>可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</li>
<li>基于模式匹配从字符串中提取子字符串。<br>可以查找文档内或输入域内特定的文本。</li>
</ul>
<p>例如，您可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。</p>
<h1 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h1><p><a href="https://tool.oschina.net/regex#" target="_blank" rel="noopener">正则表达式在线测试</a></p>
<p><a href="https://any86.github.io/any-rule/" target="_blank" rel="noopener">正则大全</a></p>
<h1 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h1><h2 id="统一社会信用代码"><a href="#统一社会信用代码" class="headerlink" title="统一社会信用代码"></a>统一社会信用代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/[0-9A-HJ-NPQRTUWXY]&#123;2&#125;\d&#123;6&#125;[0-9A-HJ-NPQRTUWXY]&#123;10&#125;/</span><br></pre></td></tr></table></figure>
<h2 id="迅雷链接"><a href="#迅雷链接" class="headerlink" title="迅雷链接"></a>迅雷链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^thunderx?:\/\/[a-zA-Z\d]+=$/</span><br></pre></td></tr></table></figure>
<h2 id="ed2k链接-宽松匹配"><a href="#ed2k链接-宽松匹配" class="headerlink" title="ed2k链接(宽松匹配)"></a>ed2k链接(宽松匹配)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^ed2k:\/\/\|file\|.+\|\/$/</span><br></pre></td></tr></table></figure>
<h2 id="磁力链接-宽松匹配"><a href="#磁力链接-宽松匹配" class="headerlink" title="磁力链接(宽松匹配)"></a>磁力链接(宽松匹配)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^magnet:\?xt=urn:btih:[0-9a-fA-F]&#123;40,&#125;.*$/</span><br></pre></td></tr></table></figure>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^(?:\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5])(?:\.(?:\d&#123;1,2&#125;|1\d\d|2[0-4]\d|25[0-5]))&#123;3&#125;$/</span><br></pre></td></tr></table></figure>
<h2 id="linux”文件夹”路径"><a href="#linux”文件夹”路径" class="headerlink" title="linux”文件夹”路径"></a>linux”文件夹”路径</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^\/(\w+\/?)+$/</span><br></pre></td></tr></table></figure>
<h2 id="linux”文件”路径"><a href="#linux”文件”路径" class="headerlink" title="linux”文件”路径"></a>linux”文件”路径</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^\/(\w+\/)+\w+\.\w+$/</span><br></pre></td></tr></table></figure>
<h2 id="window下”文件夹”路径"><a href="#window下”文件夹”路径" class="headerlink" title="window下”文件夹”路径"></a>window下”文件夹”路径</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^[a-zA-Z]:\\(?:\w+\\?)*$/</span><br></pre></td></tr></table></figure>
<h2 id="window下”文件”路径"><a href="#window下”文件”路径" class="headerlink" title="window下”文件”路径"></a>window下”文件”路径</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^[a-zA-Z]:\\(?:\w+\\)*\w+\.\w+$/</span><br></pre></td></tr></table></figure>
<h2 id="A股代码"><a href="#A股代码" class="headerlink" title="A股代码"></a>A股代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^(s[hz]|S[HZ])(000[\d]&#123;3&#125;|002[\d]&#123;3&#125;|300[\d]&#123;3&#125;|600[\d]&#123;3&#125;|60[\d]&#123;4&#125;)$/</span><br></pre></td></tr></table></figure>
<h2 id="大于等于0-小于等于150-支持小数位出现5-如145-5-用于判断考卷分数"><a href="#大于等于0-小于等于150-支持小数位出现5-如145-5-用于判断考卷分数" class="headerlink" title="大于等于0, 小于等于150, 支持小数位出现5, 如145.5, 用于判断考卷分数"></a>大于等于0, 小于等于150, 支持小数位出现5, 如145.5, 用于判断考卷分数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^150$|^(?:\d|[1-9]\d|1[0-4]\d)(?:.5)?$/</span><br></pre></td></tr></table></figure>
<h2 id="html注释"><a href="#html注释" class="headerlink" title="html注释"></a>html注释</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^&lt;!--[\s\S]*?--&gt;$/</span><br></pre></td></tr></table></figure>
<h2 id="md5格式-32位"><a href="#md5格式-32位" class="headerlink" title="md5格式(32位)"></a>md5格式(32位)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^[a-f0-9]&#123;32&#125;$/</span><br></pre></td></tr></table></figure>
<h2 id="版本号格式必须为X-Y-Z"><a href="#版本号格式必须为X-Y-Z" class="headerlink" title="版本号格式必须为X.Y.Z"></a>版本号格式必须为X.Y.Z</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^\d+(?:\.\d+)&#123;2&#125;$/</span><br></pre></td></tr></table></figure>
<h2 id="视频链接地址（视频格式可按需增删）"><a href="#视频链接地址（视频格式可按需增删）" class="headerlink" title="视频链接地址（视频格式可按需增删）"></a>视频链接地址（视频格式可按需增删）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^https?:\/\/.*?(?:swf|avi|flv|mpg|rm|mov|wav|asf|3gp|mkv|rmvb|mp4)$/i</span><br></pre></td></tr></table></figure>
<h2 id="图片链接地址（图片格式可按需增删）"><a href="#图片链接地址（图片格式可按需增删）" class="headerlink" title="图片链接地址（图片格式可按需增删）"></a>图片链接地址（图片格式可按需增删）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^https?:\/\/.*?(?:gif|png|jpg|jpeg|webp|svg|psd|bmp|tif)$/i</span><br></pre></td></tr></table></figure>
<h2 id="24小时制时间（HH-mm-ss）"><a href="#24小时制时间（HH-mm-ss）" class="headerlink" title="24小时制时间（HH:mm:ss）"></a>24小时制时间（HH:mm:ss）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d$/</span><br></pre></td></tr></table></figure>
<h2 id="12小时制时间（hh-mm-ss）"><a href="#12小时制时间（hh-mm-ss）" class="headerlink" title="12小时制时间（hh:mm:ss）"></a>12小时制时间（hh:mm:ss）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^(?:1[0-2]|0?[1-9]):[0-5]\d:[0-5]\d$/</span><br></pre></td></tr></table></figure>
<h2 id="base64格式"><a href="#base64格式" class="headerlink" title="base64格式"></a>base64格式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/^\s*data:(?:[a-z]+\/[a-z0-9-+.]+(?:;[a-z-]+=[a-z0-9-]+)?)?(?:;base64)?,([a-z0-9!$&amp;&apos;,()*+;=\-._~:@\/?%\s]*?)\s*$/i</span><br></pre></td></tr></table></figure>
<h2 id="数字-货币金额（支持负数、千分位分隔符）"><a href="#数字-货币金额（支持负数、千分位分隔符）" class="headerlink" title="数字/货币金额（支持负数、千分位分隔符）"></a>数字/货币金额（支持负数、千分位分隔符）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/(?:^[-]?[1-9]\d&#123;0,2&#125;(?:$|(?:,\d&#123;3&#125;)*(?:$|(\.\d&#123;1,2&#125;$))))|(?:(?:^[0](\.\d&#123;1,2&#125;)?)|(?:^[-][0]\.\d&#123;1,2&#125;))$/</span><br></pre></td></tr></table></figure>
<h2 id="数字-货币金额-只支持正数、不支持校验千分位分隔符"><a href="#数字-货币金额-只支持正数、不支持校验千分位分隔符" class="headerlink" title="数字/货币金额 (只支持正数、不支持校验千分位分隔符)"></a>数字/货币金额 (只支持正数、不支持校验千分位分隔符)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/(?:^[1-9]([0-9]+)?(?:\.[0-9]&#123;1,2&#125;)?$)|(?:^(?:0)&#123;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">菜鸟教程-正则表达式</a></p>
<p><a href="https://github.com/any86/any-rule" target="_blank" rel="noopener">常用正则大全</a></p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何使用PostMan？</title>
    <url>/2019/11/11/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%835/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8PostMan%EF%BC%9F/</url>
    <content><![CDATA[<p>原文链接：<a href="https://blog.csdn.net/u013613428/article/details/51557804" target="_blank" rel="noopener">https://blog.csdn.net/u013613428/article/details/51557804</a></p><p>版权声明：本文为CSDN博主「点火三周」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</p><h3 id="Postman介绍"><a href="#Postman介绍" class="headerlink" title="Postman介绍"></a>Postman介绍</h3><p>Postman是google开发的一款功能强大的网页调试与发送网页HTTP请求，并能运行测试用例的的Chrome插件。其主要功能包括：</p><a id="more"></a>


<ul>
<li><strong>模拟各种HTTP requests</strong></li>
</ul>
<p>从常用的 GET、POST 到 RESTful 的 PUT 、 DELETE …等等。 甚至还可以发送文件、送出额外的 header。</p>
<ul>
<li><strong>Collection 功能（测试集合）</strong></li>
</ul>
<p>Collection 是 requests的集合，在做完一個测试的時候， 你可以把這次的 request 存到特定的 Collection 里面，如此一來，下次要做同样的测试时，就不需要重新输入。而且一个collection可以包含多条request，如果我们把一个request当成一个test case，那collection就可以看成是一个test suite。通过collection的归类，我们可以良好的分类测试软件所提供的API.而且 Collection 还可以 Import 或是 Share 出來，让团队里面的所有人共享你建立起來的 Collection。</p>
<ul>
<li><strong>人性化的Response整理</strong></li>
</ul>
<p>一般在用其他工具來测试的時候，response的内容通常都是纯文字的 raw， 但如果是 JSON ，就是塞成一整行的 JSON。这会造成阅读的障碍 ，而 Postman 可以针对response内容的格式自动美化。 JSON、 XML 或是 HTML 都會整理成我们可以阅读的格式</p>
<ul>
<li><strong>内置测试脚本语言</strong></li>
</ul>
<p>Postman支持编写测试脚本，可以快速的检查request的结果，并返回测试结果</p>
<ul>
<li><strong>设定变量与环境</strong></li>
</ul>
<p>Postman 可以自由 设定变量与Environment，一般我们在编辑request，校验response的时候，总会需要重复输入某些字符，比如url，postman允许我们设定变量来保存这些值。并且把变量保存在不同的环境中。比如，我們可能会有多种环境， development 、 staging 或 local， 而这几种环境中的 request URL 也各不相同，但我们可以在不同的环境中设定同样的变量，只是变量的值不一样，这样我们就不用修改我们的测试脚本，而测试不同的环境。</p>
<h3 id="安装Postman"><a href="#安装Postman" class="headerlink" title="安装Postman"></a>安装Postman</h3><p>Postman作为一个chrome的插件，你可以打开chrome，在chrome webstore里面找到。当然，如果是在国内，你需要翻墙，否则的话，你只能百度一下，搜索postman的安装包自己安装到chrome上（这里就不赘述了，有很多类似的文章）。这里需要提一下的是，你可以不用打开chrome而直接使用Postman，具体的方法是：</p>
<p>选项-&gt;更多工具-&gt;扩展程序</p>
<p><img src="https://img-blog.csdn.net/20160601165759918" alt="img"> </p>
<h3 id="Postman-sending-requests"><a href="#Postman-sending-requests" class="headerlink" title="Postman sending requests"></a>Postman sending requests</h3><p>安装好之后，我们先打开Postman，可以看到界面分成左右两个部分，右边是我们后头要讲的collection，左边是现在要讲的request builder。在request builder中，我们可以通过Postman快速的随意组装出我们希望的request。一般来说，所有的HTTP Request都分成4个部分，URL, method, headers和body。而Postman针对这几部分都有针对性的工具。</p>
<p><img src="https://img-blog.csdn.net/20160601170546927" alt="img"> </p>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>要组装一条Request, URL永远是你首先要填的内容，在Postman里面你曾输入过的URL是可以通过下拉自动补全的哦。如果你点击<strong>Params</strong>按钮，Postman会弹出一个键值编辑器，你可以在哪里输入URL的Parameter，Postman会帮你自动加入到URL当中，反之，如果你的URL当中已经有了参数，那Postman会在你打开键值编辑器的时候把参数自动载入</p>
<p><img src="https://img-blog.csdn.net/20160601171111335" alt="这里写图片描述"> </p>
<h4 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h4><p>点击’Headers’按钮，Postman同样会弹出一个键值编辑器。在这里，你可以随意添加你想要的Header attribute，同样Postman为我们通过了很贴心的auto-complete功能，敲入一个字母，你可以从下拉菜单里选择你想要的标准atrribute</p>
<p><img src="https://img-blog.csdn.net/20160601172202011" alt="这里写图片描述">  </p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>要选择Request的Method是很简单的，Postman支持所有的Method，而一旦你选择了Method，Postman的request body编辑器会根据的你选择，自动的发生改变</p>
<p><img src="https://img-blog.csdn.net/20160601172720544" alt="这里写图片描述"> </p>
<h4 id="Request-Body"><a href="#Request-Body" class="headerlink" title="Request Body"></a>Request Body</h4><p>如果我们要创建的request是类似于POST，那我们就需要编辑Request Body，Postman根据body type的不同，提供了4中编辑方式：</p>
<ul>
<li>form-data</li>
<li>x-www-form-urlencoded</li>
<li>raw</li>
<li>binary</li>
</ul>
<p><img src="https://img-blog.csdn.net/20160601173348297" alt="img"> </p>
<p>（我们这里是可以传文件的哦）</p>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>我这里创建一条发送给google geocode的request，看看是啥结果：</p>
<p><img src="https://img-blog.csdn.net/20160601173955815" alt="这里写图片描述"> </p>
<p>注意，在URL里面我使用了变量googleMaps，并用模板语法双花括号调用它，这里是类似于AngulaJs的语法（果然是同一家人），其返回值是：<a href="http://maps.googleapis.com/maps/api/geocode/json" target="_blank" rel="noopener">http://maps.googleapis.com/maps/api/geocode/json</a>。而这个变量我是定义在我的环境GoogleApiTest里面的。这部分的内容会在接下来的文章里面讲到。</p>
<p>点击了Send之后，可以在Postman上直接看到response的内容，内容很漂亮，Postman根据内容检索自动按JSON的格式显示出来，同时我们可以清楚的看到status code和花费的时间。</p>
<p><img src="https://img-blog.csdn.net/20160601174202429" alt="这里写图片描述"> </p>
<p>写到这，我想大家已经能够了解如何用Postman组装Request并且查看Response的内容了，那我们怎么用Postman去做测试呢，且听下回分解</p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>什么是rest风格?get 与 post的区别?application json 与form表单的区别?</title>
    <url>/2019/11/11/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%835/%E4%BB%80%E4%B9%88%E6%98%AFrest%E9%A3%8E%E6%A0%BC-get-%E4%B8%8E-post%E7%9A%84%E5%8C%BA%E5%88%AB-application-json-%E4%B8%8Eform%E8%A1%A8%E5%8D%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="什么是rest风格"><a href="#什么是rest风格" class="headerlink" title="什么是rest风格"></a>什么是rest风格</h1><ul>
<li>看Url就知道要什么 </li>
<li>看http method就知道干什么 </li>
<li>看http status code就知道结果如何 </li>
</ul><p>相关资料： <a href="https://www.jianshu.com/p/350122cf63f2" target="_blank" rel="noopener">什么是rest</a></p><h1 id="get-与-post的区别"><a href="#get-与-post的区别" class="headerlink" title="get 与 post的区别"></a>get 与 post的区别</h1><h2 id="数据传输大小"><a href="#数据传输大小" class="headerlink" title="数据传输大小"></a>数据传输大小</h2><p>get传输数据的大小是2kb，而post一般没有限制，但是post会受内存大小影响，同时在PHP中可以通过修改php.ini配置文件来修改post传输的大小。</p><a id="more"></a>


<h2 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h2><p>get是通过url传递参数的，在url中可以查看到传递的参数。而post则不是，一般在表单提交中会使用到post方式。</p>
<h2 id="数据安全性"><a href="#数据安全性" class="headerlink" title="数据安全性"></a>数据安全性</h2><p>get方式提交，传递的参数在url中有显示，可以明显看到参数，数据不够安全。然而post则是隐式传递，是不能查看到传递的参数。</p>
<h1 id="application-json-与form表单的区别"><a href="#application-json-与form表单的区别" class="headerlink" title="application/json 与form表单的区别"></a>application/json 与form表单的区别</h1><h2 id="application-json"><a href="#application-json" class="headerlink" title="application/json"></a><strong>application/json</strong></h2><p>随着json规范的越来越流行，并且浏览器支持程度原来越好，许多开发人员以application/json作为请求content-type，告诉服务器请求的主题内容是json格式的字符串，服务器端会对json字符串进行解析，这种方式的好处就是前端人员不需要关心数据结构的复杂度，只要是标准的json格式就能提交成功，application/json数据格式越来越得到开发人员的青睐。</p>
<h2 id="application-x-www-form-urlencoded方式"><a href="#application-x-www-form-urlencoded方式" class="headerlink" title="application/x-www-form-urlencoded方式"></a><strong>application/x-www-form-urlencoded方式</strong></h2><p>是Jquery的Ajax请求默认方式，这种方式的好处就是浏览器都支持，在请求发送过程中会对数据进行序列化处理，以键值对形式？key1=value1&amp;key2=value2的方式发送到服务器，如果用Jquery，它内部已经进行了处理，如果自己写原生的Ajax请求，就需要自己对数据进行序列化。</p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>为什么有时我们需要配置hosts来本地测试？和什么有关？若不配置hosts会影响什么？</title>
    <url>/2019/11/11/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%835/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E9%85%8D%E7%BD%AEhosts%E6%9D%A5%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%EF%BC%9F%E5%92%8C%E4%BB%80%E4%B9%88%E6%9C%89%E5%85%B3%EF%BC%9F%E8%8B%A5%E4%B8%8D%E9%85%8D%E7%BD%AEhosts%E4%BC%9A%E5%BD%B1%E5%93%8D%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="知识剖析"><a href="#知识剖析" class="headerlink" title="知识剖析"></a>知识剖析</h1><h2 id="什么是ip"><a href="#什么是ip" class="headerlink" title="什么是ip"></a>什么是ip</h2><p>我们知道，在Internet上有千百万台主机，为了区分这些主机，人们给每台主机都分配了一个专门的地址，称为IP地址。通过IP地址就可以访问到每一台主机。</p><p>IP地址由4部分数字组成，每部分都不大于256，各部分之间用小数点分开。例如“百度搜索”主机的IP地址就是：“180.101.49.12”在浏览器上输入这个IP地址，就可以访问到百度的主页。</p><a id="more"></a>

<p>我们的每个虚拟主机用户，都分配一个永久的IP地址。</p>
<h2 id="什么是域名"><a href="#什么是域名" class="headerlink" title="什么是域名"></a>什么是域名</h2><p>虽然可以通过IP地址来访问每一台主机，但是要记住那么多枯糙的数字串显然是非常困难的，为此，Internet提供了域名(Domain Name）。</p>
<p>域名也由若干部分组成，各部分之间用小数点分开，例如“百度搜索”主机的域名是百度的拼音，就是“<a href="http://www.baidu.com”，显然域名比IP地址好记忆多了。" target="_blank" rel="noopener">www.baidu.com”，显然域名比IP地址好记忆多了。</a></p>
<p>域名前加上传输协议信息及主机类型信息就构成了网址(URL），例如“百度搜索”的www主机的URL就是：“<a href="http://www.baidu.com”。" target="_blank" rel="noopener">http://www.baidu.com”。</a></p>
<h2 id="什么是hosts"><a href="#什么是hosts" class="headerlink" title="什么是hosts"></a>什么是hosts</h2><p>Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开， 其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”， 当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址， 一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。</p>
<h2 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h2><p>浏览器访问网站，要首先通过DNS服务器把要访问的网站域名解析成其指定的IP地址，之后，浏览器才能对此网站进行定位并且访问其数据。 操作系统规定，在进行DNS请求以前，先检查系自己的Hosts文件中是否有这个域名和IP的映射关系。 如果有，则直接访问这个IP地址指定的网络位置，如果没有，再向已知的DNS服务器提出域名解析请求。也就是说Hosts的IP解析优先级比DNS要高。</p>
<h2 id="HOSTS与DNS服务器"><a href="#HOSTS与DNS服务器" class="headerlink" title="HOSTS与DNS服务器"></a>HOSTS与DNS服务器</h2><p>引入DNS（Domain NameSystem，域名系统）之前，网络中的主机是将容易记忆的域名映射到IP地址并将它保存在一个共享的静态文件hosts中， 再由hosts文件来实现网络中域名的管理。</p>
<p>最初Internet非常小，仅使用这个集中管理的文件就可以通过FTP为连入Internet的站点和主机提供域名的发布和下载。 每个Internet站点将定期地更新其主机文件的副本，并且发布主机文件的更新版本来反映网络的变化。</p>
<p>但是，当Internet上的计算机迅速增加时，通过一个中心授权机构为所有Internet主机管理一个主机文件的工作将无法进行。 文件会随着时间的推移而增大，这样按当前和更新的形式维持文件以及将文件分配至所有站点将变得非常困难，甚至无法完成，于是便产生了DNS服务器。</p>
<h1 id="本地测试配置hosts的意义"><a href="#本地测试配置hosts的意义" class="headerlink" title="本地测试配置hosts的意义"></a>本地测试配置hosts的意义</h1><p>   1、加快域名解析</p>
<p>​    对于要经常访问的网站，我们可以通过在Hosts中配置域名和IP的映射关系，这样当我们输入域名计算机就能很快解析出IP，而不用请求网络上的DNS服务器。</p>
<p>​    2、方便局域网用户</p>
<p>​    在很多单位的局域网中，会有服务器提供给用户使用。但由于局域网中一般很少架设DNS服务器，访问这些服务要输入难记的IP地址，对不少人来说相当麻烦。现在可以分别给这些服务器取个容易记住的名字，然后在Hosts中建立IP映射，这样以后访问的时候我们输入这个服务器的名字就行了。</p>
<p>​    3、屏蔽网站</p>
<p>​    现在有很多网站不经过用户同意就将各种各样的插件安装到你的计算机中，有些说不定就是木马或病毒。对于这些网站我们可以利用Hosts把该网站的域名映射到错误的IP或自己计算机的IP，这样就不用访问了。我们在Hosts写上以下内容：</p>
<p>​    127.0.0.1#屏蔽的网站<br>0.0.0.0#屏蔽的网站</p>
<p>​    这样计算机解析域名就解析到本机或错误的IP，达到了屏蔽的目的。</p>
<p>​    4、顺利连接系统</p>
<p>​    对于Lotus的服务器和一些数据库服务器，在访问时如果直接输入IP地址那是不能访问的，只能输入服务器名才能访问。那么我们配置好Hosts文件，这样输入服务器名就能顺利连接了。</p>
<p>​    最后要指出的是，Hosts文件配置的映射是静态的，如果网络上的计算机更改了请及时更新IP地址，否则将不能访问。</p>
<h1 id="修改hosts"><a href="#修改hosts" class="headerlink" title="修改hosts"></a>修改hosts</h1><h2 id="查找hosts文件"><a href="#查找hosts文件" class="headerlink" title="查找hosts文件"></a>查找hosts文件</h2><p>hosts文件的路径：C:\Windows\System32\Drivers\Etc </p>
<h2 id="打开hosts文件"><a href="#打开hosts文件" class="headerlink" title="打开hosts文件"></a>打开hosts文件</h2><p>使用记事本打开hosts文件（文件内容如下所示）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Copyright (c) 1993-2009 Microsoft Corp.</span><br><span class="line">#</span><br><span class="line"># This is a sample HOSTS file used by Microsoft TCP/IP for Windows.</span><br><span class="line">#</span><br><span class="line"># This file contains the mappings of IP addresses to host names. Each</span><br><span class="line"># entry should be kept on an individual line. The IP address should</span><br><span class="line"># be placed in the first column followed by the corresponding host name.</span><br><span class="line"># The IP address and the host name should be separated by at least one</span><br><span class="line"># space.</span><br><span class="line">#</span><br><span class="line"># Additionally, comments (such as these) may be inserted on individual</span><br><span class="line"># lines or following the machine name denoted by a &apos;#&apos; symbol.</span><br><span class="line">#</span><br><span class="line"># For example:</span><br><span class="line">#</span><br><span class="line">#      102.54.94.97     rhino.acme.com          # source server</span><br><span class="line">#       38.25.63.10     x.acme.com              # x client host</span><br><span class="line"></span><br><span class="line"># localhost name resolution is handled within DNS itself.</span><br><span class="line">#	127.0.0.1       localhost</span><br><span class="line">#	::1             localhost</span><br></pre></td></tr></table></figure>
<h2 id="查找域名对应ip"><a href="#查找域名对应ip" class="headerlink" title="查找域名对应ip"></a>查找域名对应ip</h2><ol>
<li>打开cmd命令行工具</li>
<li>输入<code>ping 你要查找的域名</code></li>
</ol>
<p>示例：查找百度对应的ip，180.101.49.12即为百度对应的ip地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\WINDOWS\system32&gt;ping www.baidu.com</span><br><span class="line"></span><br><span class="line">正在 Ping www.baidu.com [180.101.49.12] 具有 32 字节的数据:</span><br><span class="line">来自 180.101.49.12 的回复: 字节=32 时间=14ms TTL=52</span><br><span class="line">来自 180.101.49.12 的回复: 字节=32 时间=14ms TTL=52</span><br><span class="line">来自 180.101.49.12 的回复: 字节=32 时间=14ms TTL=52</span><br><span class="line">来自 180.101.49.12 的回复: 字节=32 时间=14ms TTL=52</span><br><span class="line"></span><br><span class="line">180.101.49.12 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = 14ms，最长 = 14ms，平均 = 14ms</span><br></pre></td></tr></table></figure>
<h2 id="修改hosts-1"><a href="#修改hosts-1" class="headerlink" title="修改hosts"></a>修改hosts</h2><p>在文件后面添加“IP地址 你的域名” ，注意IP与域名之间有个空格，然后保存即可  。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Copyright (c) 1993-2009 Microsoft Corp.</span><br><span class="line">#</span><br><span class="line"># This is a sample HOSTS file used by Microsoft TCP/IP for Windows.</span><br><span class="line">#</span><br><span class="line"># This file contains the mappings of IP addresses to host names. Each</span><br><span class="line"># entry should be kept on an individual line. The IP address should</span><br><span class="line"># be placed in the first column followed by the corresponding host name.</span><br><span class="line"># The IP address and the host name should be separated by at least one</span><br><span class="line"># space.</span><br><span class="line">#</span><br><span class="line"># Additionally, comments (such as these) may be inserted on individual</span><br><span class="line"># lines or following the machine name denoted by a &apos;#&apos; symbol.</span><br><span class="line">#</span><br><span class="line"># For example:</span><br><span class="line">#</span><br><span class="line">#      102.54.94.97     rhino.acme.com          # source server</span><br><span class="line">#       38.25.63.10     x.acme.com              # x client host</span><br><span class="line"></span><br><span class="line"># localhost name resolution is handled within DNS itself.</span><br><span class="line">#	127.0.0.1       localhost</span><br><span class="line">#	::1             localhost</span><br><span class="line">180.101.49.12 tianxintiandisheng.com</span><br></pre></td></tr></table></figure>
<p>分享一个比较便捷的打开HOSTS文件的方法</p>
<p>新建一个txt文件，在你其中输入：<br>notepad “%SystemRoot%\system32\drivers\etc\hosts”<br>ipconfig /flushdns<br>退出保存，将扩展名改成成.bat，之后双击这个bat文件就可以自动打开hosts文件进行修改了。</p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>前端跨域问题有哪些常用的解决方式？</title>
    <url>/2019/11/11/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%835/%E5%89%8D%E7%AB%AF%E5%9E%AE%E5%9F%9F%E9%97%AE%E9%A2%98%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="知识剖析"><a href="#知识剖析" class="headerlink" title="知识剖析"></a>知识剖析</h1><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 </p><h2 id="完整的URL包含部分"><a href="#完整的URL包含部分" class="headerlink" title="完整的URL包含部分"></a>完整的URL包含部分</h2><p><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name" target="_blank" rel="noopener">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></p><a id="more"></a>

<p>1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符 </p>
<p>2.域名部分：该URL的域名部分为“<a href="http://www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用" target="_blank" rel="noopener">www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</a> </p>
<p>3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口 </p>
<p>4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/” </p>
<p>5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名 </p>
<p>6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分 </p>
<h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>同源策略：它是由Netscape提出的一个著名的安全策略。同源是指，域名，协议，端口相同。浏览器执行javascript脚本时，会检查这个脚本属于那个页面，如果不是同源页面，就不会被执行。</p>
<p>跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。所谓同源是指，域名，协议，端口均相同。</p>
<p>不明白没关系，举几个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL                                      说明                    是否允许通信</span><br><span class="line">http://www.domain.com/a.js</span><br><span class="line">http://www.domain.com/b.js         同一域名，不同文件或路径           允许</span><br><span class="line">http://www.domain.com/lab/c.js</span><br><span class="line"></span><br><span class="line">http://www.domain.com:8000/a.js</span><br><span class="line">http://www.domain.com/b.js         同一域名，不同端口                不允许</span><br><span class="line"> </span><br><span class="line">http://www.domain.com/a.js</span><br><span class="line">https://www.domain.com/b.js        同一域名，不同协议                不允许</span><br><span class="line"> </span><br><span class="line">http://www.domain.com/a.js</span><br><span class="line">http://192.168.4.12/b.js           域名和域名对应相同ip              不允许</span><br><span class="line"> </span><br><span class="line">http://www.domain.com/a.js</span><br><span class="line">http://x.domain.com/b.js           主域相同，子域不同                不允许</span><br><span class="line">http://domain.com/c.js</span><br><span class="line"> </span><br><span class="line">http://www.domain1.com/a.js</span><br><span class="line">http://www.domain2.com/b.js        不同域名                         不允许</span><br></pre></td></tr></table></figure>
<p>请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。</p>
<h2 id="为什么需要跨域"><a href="#为什么需要跨域" class="headerlink" title="为什么需要跨域"></a>为什么需要跨域</h2><p>受浏览器同源策略的限制，本域的js不能操作其他域的页面对象（比如DOM）。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象（iframe之间）。</p>
<p>这里需要明确的一点是： 所谓的域跟js的存放服务器没有关系，比如baidu.com的页面加载了google.com的js，那么此js的所在域是baidu.com而不是google.com。也就是说此时该js能操作baidu.com的页面对象，而不能操作google.com的页面对象。</p>
<h1 id="前端垮域常用的解决方式"><a href="#前端垮域常用的解决方式" class="headerlink" title="前端垮域常用的解决方式"></a>前端垮域常用的解决方式</h1><ol>
<li>通过jsonp跨域</li>
<li>document.domain + iframe跨域</li>
<li>location.hash + iframe</li>
<li>window.name + iframe跨域</li>
<li>postMessage跨域</li>
<li>跨域资源共享（CORS）</li>
<li>nginx代理跨域</li>
<li>nodejs中间件代理跨域</li>
<li>WebSocket协议跨域</li>
</ol>
<h2 id="通过jsonp跨域"><a href="#通过jsonp跨域" class="headerlink" title="通过jsonp跨域"></a>通过jsonp跨域</h2><p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p>
<p>1.）原生实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">   script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span></span><br><span class="line">   script.src = <span class="string">'http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback'</span>;</span><br><span class="line">   <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 回调执行函数</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">handleCallback</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">       alert(<span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">   &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>服务端返回如下（返回时即执行全局函数）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleCallback(&#123;<span class="string">"status"</span>: <span class="literal">true</span>, <span class="string">"user"</span>: <span class="string">"admin"</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>2.）jquery ajax：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'http://www.domain2.com:8080/login'</span>,</span><br><span class="line">    type: <span class="string">'get'</span>,</span><br><span class="line">    dataType: <span class="string">'jsonp'</span>,  <span class="comment">// 请求方式为jsonp</span></span><br><span class="line">    jsonpCallback: <span class="string">"handleCallback"</span>,    <span class="comment">// 自定义回调函数名</span></span><br><span class="line">    data: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>3.）vue.js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$http.jsonp(<span class="string">'http://www.domain2.com:8080/login'</span>, &#123;</span><br><span class="line">    params: &#123;&#125;,</span><br><span class="line">    jsonp: <span class="string">'handleCallback'</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>后端node.js代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = qs.parse(req.url.split(<span class="string">'?'</span>)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">var</span> fn = params.callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jsonp返回设置</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/javascript'</span> &#125;);</span><br><span class="line">    res.write(fn + <span class="string">'('</span> + <span class="built_in">JSON</span>.stringify(params) + <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure>
<p>jsonp缺点：只能实现get一种请求。</p>
<h2 id="document-domain-iframe跨域"><a href="#document-domain-iframe跨域" class="headerlink" title="document.domain + iframe跨域"></a>document.domain + iframe跨域</h2><p>此方案仅限主域相同，子域不同的跨域应用场景。</p>
<p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>
<p>1.）父窗口：(<a href="http://www.domain.com/a.html)" target="_blank" rel="noopener">http://www.domain.com/a.html)</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://child.domain.com/b.html"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">document</span>.domain = <span class="string">'domain.com'</span>;</span><br><span class="line">    <span class="keyword">var</span> user = <span class="string">'admin'</span>;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.）子窗口：(<a href="http://child.domain.com/b.html)" target="_blank" rel="noopener">http://child.domain.com/b.html)</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">document</span>.domain = <span class="string">'domain.com'</span>;</span><br><span class="line">    <span class="comment">// 获取父窗口中变量</span></span><br><span class="line">    alert(<span class="string">'get js data from parent ---&gt; '</span> + <span class="built_in">window</span>.parent.user);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="location-hash-iframe跨域"><a href="#location-hash-iframe跨域" class="headerlink" title="location.hash + iframe跨域"></a>location.hash + iframe跨域</h2><p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>
<p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p>
<p>1.）a.html：(<a href="http://www.domain1.com/a.html)" target="_blank" rel="noopener">http://www.domain1.com/a.html)</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://www.domain2.com/b.html"</span> style=<span class="string">"display:none;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向b.html传hash值</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        iframe.src = iframe.src + <span class="string">'#user=admin'</span>;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开放给同域c.html的回调方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onCallback</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'data from c.html ---&gt; '</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.）b.html：(<a href="http://www.domain2.com/b.html)" target="_blank" rel="noopener">http://www.domain2.com/b.html)</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://www.domain1.com/c.html"</span> style=<span class="string">"display:none;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听a.html传来的hash值，再传给c.html</span></span><br><span class="line">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        iframe.src = iframe.src + location.hash;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.）c.html：(<a href="http://www.domain1.com/c.html)" target="_blank" rel="noopener">http://www.domain1.com/c.html)</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 监听b.html传来的hash值</span></span><br><span class="line">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 再通过操作同域a.html的js回调，将结果传回</span></span><br><span class="line">        <span class="built_in">window</span>.parent.parent.onCallback(<span class="string">'hello: '</span> + location.hash.replace(<span class="string">'#user='</span>, <span class="string">''</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="window-name-iframe跨域"><a href="#window-name-iframe跨域" class="headerlink" title="window.name + iframe跨域"></a>window.name + iframe跨域</h2><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>
<p>1.）a.html：(<a href="http://www.domain1.com/a.html)" target="_blank" rel="noopener">http://www.domain1.com/a.html)</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="function"><span class="keyword">function</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载跨域页面</span></span><br><span class="line">    iframe.src = url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span><br><span class="line">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span></span><br><span class="line">            callback(iframe.contentWindow.name);</span><br><span class="line">            destoryFrame();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span><br><span class="line">            iframe.contentWindow.location = <span class="string">'http://www.domain1.com/proxy.html'</span>;</span><br><span class="line">            state = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">destoryFrame</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        iframe.contentWindow.document.write(<span class="string">''</span>);</span><br><span class="line">        iframe.contentWindow.close();</span><br><span class="line">        <span class="built_in">document</span>.body.removeChild(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求跨域b页面数据</span></span><br><span class="line">proxy(<span class="string">'http://www.domain2.com/b.html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    alert(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>2.）proxy.html：(<a href="http://www.domain1.com/proxy.html" target="_blank" rel="noopener">http://www.domain1.com/proxy….</a>)<br>中间代理页，与a.html同域，内容为空即可。</p>
<p>3.）b.html：(<a href="http://www.domain2.com/b.html)" target="_blank" rel="noopener">http://www.domain2.com/b.html)</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">window</span>.name = <span class="string">'This is domain2 data!'</span>;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<h2 id="postMessage跨域"><a href="#postMessage跨域" class="headerlink" title="postMessage跨域"></a>postMessage跨域</h2><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：<br>a.） 页面和其打开的新窗口的数据传递<br>b.） 多窗口之间消息传递<br>c.） 页面与嵌套的iframe消息传递<br>d.） 上面三个场景的跨域数据传递</p>
<p>用法：postMessage(data,origin)方法接受两个参数<br>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。<br>origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p>
<p>1.）a.html：(<a href="http://www.domain1.com/a.html)" target="_blank" rel="noopener">http://www.domain1.com/a.html)</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;iframe id=<span class="string">"iframe"</span> src=<span class="string">"http://www.domain2.com/b.html"</span> style=<span class="string">"display:none;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;       </span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> data = &#123;</span><br><span class="line">            name: <span class="string">'aym'</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 向domain2传送跨域数据</span></span><br><span class="line">        iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">'http://www.domain2.com'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受domain2返回数据</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'data from domain2 ---&gt; '</span> + e.data);</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.）b.html：(<a href="http://www.domain2.com/b.html)" target="_blank" rel="noopener">http://www.domain2.com/b.html)</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 接收domain1的数据</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'data from domain1 ---&gt; '</span> + e.data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(e.data);</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            data.number = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理后再发回domain1</span></span><br><span class="line">            <span class="built_in">window</span>.parent.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">'http://www.domain1.com'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="跨域资源共享（CORS）"><a href="#跨域资源共享（CORS）" class="headerlink" title="跨域资源共享（CORS）"></a>跨域资源共享（CORS）</h2><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。</p>
<p>需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。</p>
<p>目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。</p>
<h3 id="前端设置"><a href="#前端设置" class="headerlink" title="前端设置"></a>前端设置</h3><p>1.）原生ajax</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>示例代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// IE8/9需用window.XDomainRequest兼容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'http://www.domain2.com:8080/login'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">xhr.send(<span class="string">'user=admin'</span>);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.）jQuery ajax</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    ...</span><br><span class="line">   xhrFields: &#123;</span><br><span class="line">       withCredentials: <span class="literal">true</span>    <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">   &#125;,</span><br><span class="line">   crossDomain: <span class="literal">true</span>,   <span class="comment">// 会让请求头中包含跨域的额外信息，但不会含cookie</span></span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>3.）vue框架</p>
<p>a.) axios设置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.defaults.withCredentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>b.) vue-resource设置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.http.options.credentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="服务端设置："><a href="#服务端设置：" class="headerlink" title="服务端设置："></a>服务端设置：</h3><p>若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。</p>
<p>1.）Java后台：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 导入包：import javax.servlet.http.HttpServletResponse;</span></span><br><span class="line"><span class="comment"> * 接口参数中定义：HttpServletResponse response</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加'/'</span></span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"http://www.domain1.com"</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许前端带认证cookie：启用此项后，上面的域名不能为'*'，必须指定具体的域名，否则浏览器会提示</span></span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 提示OPTIONS预检时，后端需要设置的两个常用自定义头</span></span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Content-Type,X-Requested-With"</span>);</span><br></pre></td></tr></table></figure>
<p>2.）Nodejs后台示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> postData = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据块接收中</span></span><br><span class="line">    req.addListener(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        postData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据接收完毕</span></span><br><span class="line">    req.addListener(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        postData = qs.parse(postData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨域后台设置</span></span><br><span class="line">        res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">'Access-Control-Allow-Credentials'</span>: <span class="string">'true'</span>,     <span class="comment">// 后端允许发送Cookie</span></span><br><span class="line">            <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'http://www.domain1.com'</span>,    <span class="comment">// 允许访问的域（协议+域名+端口）</span></span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，</span></span><br><span class="line"><span class="comment">             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>  <span class="comment">// HttpOnly的作用是让js无法读取cookie</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        res.write(<span class="built_in">JSON</span>.stringify(postData));</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="nginx代理跨域"><a href="#nginx代理跨域" class="headerlink" title="nginx代理跨域"></a>nginx代理跨域</h2><h3 id="1、-nginx配置解决iconfont跨域"><a href="#1、-nginx配置解决iconfont跨域" class="headerlink" title="1、 nginx配置解决iconfont跨域"></a><strong>1、 nginx配置解决iconfont跨域</strong></h3><p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  add_header Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、-nginx反向代理接口跨域"><a href="#2、-nginx反向代理接口跨域" class="headerlink" title="2、 nginx反向代理接口跨域"></a><strong>2、 nginx反向代理接口跨域</strong></h3><p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p>
<p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p>
<p>nginx具体配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">81</span>;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http:<span class="comment">//www.domain2.com:8080;  #反向代理</span></span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http:<span class="comment">//www.domain1.com;  #当前端只跨域不带cookie时，可为*</span></span><br><span class="line">        add_header Access-Control-Allow-Credentials <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.) 前端代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.domain1.com:81/?user=admin'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<p>2.) Nodejs后台示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = qs.parse(req.url.substring(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前台写cookie</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>   <span class="comment">// HttpOnly:脚本无法读取</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Nodejs中间件代理跨域"><a href="#Nodejs中间件代理跨域" class="headerlink" title="Nodejs中间件代理跨域"></a>Nodejs中间件代理跨域</h2><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p>
<h3 id="非vue框架的跨域（2次跨域）"><a href="#非vue框架的跨域（2次跨域）" class="headerlink" title="非vue框架的跨域（2次跨域）"></a>非vue框架的跨域（2次跨域）</h3><p>利用node + express + http-proxy-middleware搭建一个proxy服务器。</p>
<p>1.）前端代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问http-proxy-middleware代理服务器</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.domain1.com:3000/login?user=admin'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<p>2.）中间件服务器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/'</span>, proxy(&#123;</span><br><span class="line">    <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">    target: <span class="string">'http://www.domain2.com:8080'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改响应头信息，实现跨域并允许带cookie</span></span><br><span class="line">    onProxyRes: <span class="function"><span class="keyword">function</span>(<span class="params">proxyRes, req, res</span>) </span>&#123;</span><br><span class="line">        res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://www.domain1.com'</span>);</span><br><span class="line">        res.header(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="string">'true'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改响应信息中的cookie域名</span></span><br><span class="line">    cookieDomainRewrite: <span class="string">'www.domain1.com'</span>  <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Proxy server is listen at port 3000...'</span>);</span><br></pre></td></tr></table></figure>
<p>3.）Nodejs后台同（六：nginx）</p>
<h3 id="vue框架的跨域（1次跨域）"><a href="#vue框架的跨域（1次跨域）" class="headerlink" title="vue框架的跨域（1次跨域）"></a>vue框架的跨域（1次跨域）</h3><p>利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。</p>
<p>webpack.config.js部分配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;&#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">        proxy: [&#123;</span><br><span class="line">            context: <span class="string">'/login'</span>,</span><br><span class="line">            target: <span class="string">'http://www.domain2.com:8080'</span>,  <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">            changeOrigin: <span class="literal">true</span>,</span><br><span class="line">            secure: <span class="literal">false</span>,  <span class="comment">// 当代理某些https服务报错时用</span></span><br><span class="line">            cookieDomainRewrite: <span class="string">'www.domain1.com'</span>  <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">        &#125;],</span><br><span class="line">        noInfo: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="WebSocket协议跨域"><a href="#WebSocket协议跨域" class="headerlink" title="WebSocket协议跨域"></a>WebSocket协议跨域</h2><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。<br>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>
<p>1.）前端代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;user input：&lt;input type=<span class="string">"text"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> socket = io(<span class="string">'http://www.domain2.com:8080'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接成功处理</span></span><br><span class="line">socket.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 监听服务端消息</span></span><br><span class="line">    socket.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data from server: ---&gt; '</span> + msg); </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听服务端关闭</span></span><br><span class="line">    socket.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Server socket has closed.'</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)[<span class="number">0</span>].onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    socket.send(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.）Nodejs socket后台：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> socket = <span class="built_in">require</span>(<span class="string">'socket.io'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启http服务</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">'Content-type'</span>: <span class="string">'text/html'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听socket连接</span></span><br><span class="line">socket.listen(server).on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 接收信息</span></span><br><span class="line">    client.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">        client.send(<span class="string">'hello：'</span> + msg);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data from client: ---&gt; '</span> + msg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断开处理</span></span><br><span class="line">    client.on(<span class="string">'disconnect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Client socket has closed.'</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>怎么选择跨域的方法？</p>
<p>跨域的方法很多，不同的应用场景我们都可以找到一个最合适的解决方案。</p>
<ul>
<li>简单的跨域请求jsonp即可</li>
<li>复杂的CORS</li>
<li>窗口之间JS跨域postMessage</li>
<li>开发环境下接口跨域用nginx反向代理或node中间件比较方便</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">前端常见跨域解决方案（全）</a></p>
<p><a href="https://blog.csdn.net/tianxintiandisheng/article/details/81941293" target="_blank" rel="noopener">使用nginx反向代理发起跨域请求</a></p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>简述原型链是什么，有什么用处？若想访问一个对象的原型，应该使用什么方法？</title>
    <url>/2019/11/10/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%835/%E7%AE%80%E8%BF%B0%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E5%A4%84%EF%BC%9F%E8%8B%A5%E6%83%B3%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="原型链是什么"><a href="#原型链是什么" class="headerlink" title="原型链是什么"></a>原型链是什么</h1><p>ECMAScript中 原型链的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p><p>基本的实现是利用构造函数，原型和实例的关系。</p><p>即是每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针proto.由于构造函数，原型和实例存在这样的关系，如果我们让一个原型对象等于另一个构造函数的实例，那么此时这个原型对象将包含一个指向另一个原型对象的指针，这样的话，另一个原型原型中也包含着指向另一个构造函数的指针。如果另一个原型又是另一个类型的实例，那么上面的关系还是会成立。这样层层递进，就够成了实例与原型的链条，这就是所谓的原型链的基本概念。</p><a id="more"></a>


<h1 id="原型链的用途"><a href="#原型链的用途" class="headerlink" title="原型链的用途"></a>原型链的用途</h1><p>通过原型链来实现继承，通过继承实现面向对象编程。</p>
<h1 id="如何访问原型对象"><a href="#如何访问原型对象" class="headerlink" title="如何访问原型对象"></a>如何访问原型对象</h1><p>即是每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针proto.</p>
<p><img src="https://images2015.cnblogs.com/blog/1010198/201702/1010198-20170222151629288-2040292378.png" alt="img"> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.species = <span class="string">"动物"</span>;</span><br><span class="line">    <span class="keyword">this</span>.footers = [<span class="string">"一只"</span>, <span class="string">"两只"</span>, <span class="string">"三只"</span>]; </span><br><span class="line">    <span class="keyword">this</span>.seeHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我是"</span> + <span class="keyword">this</span>.name)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"cat"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();<span class="comment">//继承</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Cat构造函数是"</span> + Cat.constructor);<span class="comment">//&gt;Cat构造函数是function Function() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Cat原型对象是"</span> + Cat.prototype);<span class="comment">//&gt;Cat原型对象是[object Object]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat();<span class="comment">//创建实例</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"cat1构造函数是"</span> + cat1.constructor);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"cat1原型对象是"</span> + cat1.prototype); <span class="comment">//&gt;cat1原型对象是undefined;因为cat1是实例，cat1原型对象是undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"cat1原型对象是"</span> + cat1.__proto__); <span class="comment">//&gt;cat1原型对象是[object Object];因为cat1是实例，__proto_指针指向原型对象</span></span><br></pre></td></tr></table></figure>
<h1 id="js中实现继承"><a href="#js中实现继承" class="headerlink" title="js中实现继承"></a>js中实现继承</h1><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>ECMAScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原 型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每 个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型 对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的 原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数 的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实 例与原型的链条。这就是所谓原型链的基本概念。 </p>
<p>实现原型链有一种基本模式，其代码大致如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.species = <span class="string">"动物"</span>;</span><br><span class="line">    <span class="keyword">this</span>.footers = [<span class="string">"一只"</span>, <span class="string">"两只"</span>, <span class="string">"三只"</span>]; </span><br><span class="line">    <span class="keyword">this</span>.seeHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我是"</span> + <span class="keyword">this</span>.name)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"cat"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();<span class="comment">//继承</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Cat构造函数是"</span> + Cat.constructor);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Cat原型对象是"</span> + Cat.prototype);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat();<span class="comment">//创建实例</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"cat1构造函数是"</span> + cat1.constructor);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"cat1原型对象是"</span> + cat1.prototype); <span class="comment">//因为cat1是实例，&gt;cat1原型对象是undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"cat1原型对象是"</span> + cat1.__proto__); <span class="comment">//因为cat1是实例，__proto_指针指向原型对象</span></span><br><span class="line">cat1.footers.push(<span class="string">"四只"</span>); </span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat1.species);<span class="comment">//&gt;"动物"</span></span><br><span class="line"><span class="built_in">console</span>.log(cat1.footers);<span class="comment">//&gt;["一只", "两只", "三只"，"四只"]</span></span><br><span class="line"><span class="built_in">console</span>.log(cat2.species);<span class="comment">//&gt;"动物"</span></span><br><span class="line"><span class="built_in">console</span>.log(cat2.footers);<span class="comment">//&gt;["一只", "两只", "三只"，"四只"]</span></span><br></pre></td></tr></table></figure>
<h3 id="原型链继承的缺点"><a href="#原型链继承的缺点" class="headerlink" title="原型链继承的缺点"></a>原型链继承的缺点</h3><ol>
<li>原型中包含引用类型值，子类修改该值，会修改引用类型的值。</li>
<li>在创建子类型的实例时，不能向超类型的构造函数中传递参数。</li>
</ol>
<h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数 （constructor stealing）的技术（有时候也叫做伪造对象或经典继承）。这种技术的基本思想相当简单，即 在子类型构造函数的内部调用超类型构造函数。</p>
<p>所谓”<strong>构造函数</strong>“，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.species = <span class="string">"动物"</span>;</span><br><span class="line">    <span class="keyword">this</span>.footers = [<span class="string">"一只"</span>, <span class="string">"两只"</span>, <span class="string">"三只"</span>]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>);<span class="comment">//继承</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>,<span class="string">"黄色"</span>);</span><br><span class="line">cat1.footers.push(<span class="string">"四只"</span>); </span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">"二毛"</span>,<span class="string">"红色"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cat1.name);<span class="comment">//&gt;大毛</span></span><br><span class="line"><span class="built_in">console</span>.log(cat1.species);<span class="comment">//&gt;动物</span></span><br><span class="line"><span class="built_in">console</span>.log(cat1.footers);<span class="comment">// &gt;["一只", "两只", "三只"，"四只"]</span></span><br><span class="line"><span class="built_in">console</span>.log(cat2.name);<span class="comment">//&gt;二毛</span></span><br><span class="line"><span class="built_in">console</span>.log(cat2.species);<span class="comment">//&gt;动物</span></span><br><span class="line"><span class="built_in">console</span>.log(cat2.footers);<span class="comment">// &gt;["一只", "两只", "三只"]</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h3><p>如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定 义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结 果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的.</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的 技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方 法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数 复用，又能够保证每个实例都有它自己的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.species = <span class="string">"动物"</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.footers = [<span class="string">"一只"</span>, <span class="string">"两只"</span>, <span class="string">"三只"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.sayName =<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我的名字是"</span>+ <span class="keyword">this</span>.name)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>, name);<span class="comment">//继承属性</span></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();<span class="comment">//第一行</span></span><br><span class="line">Cat.prototype.constructor = Cat;<span class="comment">//第二行</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*第一行相当于完全删除了prototype 对象原先的值，然后赋予一个新值。</span></span><br><span class="line"><span class="comment">*任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有"Cat.prototype = new Animal();"这一行，Cat.prototype.constructor是指向Cat的；</span></span><br><span class="line"><span class="comment">* 加了这一行以后，Cat.prototype.constructor指向Animal。更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。</span></span><br><span class="line"><span class="comment">* 因此，在运行"Cat.prototype = new Animal();"这一行之后，cat1.constructor也指向Animal！</span></span><br><span class="line"><span class="comment">*这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Cat.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我的年龄是"</span>+ <span class="keyword">this</span>.age)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>,<span class="number">2</span>);</span><br><span class="line">cat1.footers.push(<span class="string">"四只"</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">"二毛"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cat1.name);<span class="comment">//&gt;大毛</span></span><br><span class="line"><span class="built_in">console</span>.log(cat1.sayAge());<span class="comment">//&gt;我的年龄是2</span></span><br><span class="line"><span class="built_in">console</span>.log(cat1.footers);<span class="comment">// &gt;["一只", "两只", "三只"，"四只"]</span></span><br><span class="line"><span class="built_in">console</span>.log(cat2.name);<span class="comment">//&gt;二毛</span></span><br><span class="line"><span class="built_in">console</span>.log(cat2.sayAge());<span class="comment">//&gt;我的年龄是1</span></span><br><span class="line"><span class="built_in">console</span>.log(cat2.footers);<span class="comment">// &gt;["一只", "两只", "三只"]</span></span><br></pre></td></tr></table></figure>
<p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中常用的继 承模式。而且，instanceof 和 isPrototypeOf()也能够用于识别基于组合继承创建的对象。 </p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>道格拉斯·克罗克福德在 2006年写了一篇文章，题为 Prototypal Inheritance in JavaScript （JavaScript 中的原型式继承）。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的 构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为 了达到这个目的，他给出了如下函数。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的 原型，后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次</p>
<p>浅复制。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>: <span class="string">"Nicholas"</span>, <span class="attr">friends</span>: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.friends); <span class="comment">//&gt;"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure>
<p>克罗克福德主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么 一个对象的话，可以把它传递给 object()函数，然后再根据具体需求对得到的对象加以修改即可。在这 个例子中，可以作为另一个对象基础的是 person 对象，于是我们把它传入到 object()函数中，然后该 函数就会返回一个新对象。这个新对象将 person 作为原型，所以它的原型中就包含一个基本类型值属性 和一个引用类型值属性。这意味着 person.friends 不仅属于 person 所有，而且也会被 anotherPerson 以及 yetAnotherPerson 共享。实际上，这就相当于又创建了 person 对象的两个副本。 </p>
<p>ECMAScript 5通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一 个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下， Object.create()与 object()方法的行为相同。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>: <span class="string">"Nicholas"</span>, <span class="attr">friends</span>: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line"></span><br><span class="line">alert(person.friends); <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure>
<p>Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相 同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属 性。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#123;</span><br><span class="line">            value: <span class="string">"Greg"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">alert(anotherPerson.name); <span class="comment">//"Greg"</span></span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>支持 Object.create()方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome。 在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式 继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模 式一样。 </p>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推而广 之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，后再像真地是它做了所有工作一样返回对象。以下代码示范了寄 生式继承模式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = object(original); <span class="comment">//通过调用函数创建一个新对象     </span></span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//以某种方式来增强这个对象         </span></span><br><span class="line">        alert(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone; <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，createAnother()函数接收了一个参数，也就是将要作为新对象基础的对象。然 后，把这个对象（original）传递给 object()函数，将返回的结果赋值给 clone。再为 clone 对象 添加一个新方法 sayHi()，后返回 clone 对象。可以像下面这样来使用 createAnother()函数： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); <span class="comment">//"hi"</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的代码基于 person 返回了一个新对象——anotherPerson。新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi()方法。 在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示 范继承模式时使用的 object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。 </p>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背 后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型 原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型 的原型。寄生组合式继承的基本模式如下所示。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">//创建对象     </span></span><br><span class="line">    prototype.constructor = subType; <span class="comment">//增强对象     </span></span><br><span class="line">    subType.prototype = prototype; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例中的 inheritPrototype()函数实现了寄生组合式继承的简单形式。这个函数接收两 个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二 步是为创建的副本添加 constructor 属性，从而弥补因重写原型而失去的默认的 constructor 属性。 后一步，将新创建的对象（即副本）赋值给子类型的原型。这样，我们就可以用调用 inherit- Prototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了，例如： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子的高效率体现在它只调用了一次 SuperType 构造函数，并且因此避免了在 SubType. prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型理想的继承范式。</p>
<h1 id="如何访问原型对象-1"><a href="#如何访问原型对象-1" class="headerlink" title="如何访问原型对象"></a>如何访问原型对象</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------原型链组合继承</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个Father函数，添加属性color</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.color = <span class="string">"皮肤是黄色"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.food = [<span class="string">'米饭'</span>,<span class="string">'面包'</span>]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//给 Father函数 添加原型方法</span></span><br><span class="line"></span><br><span class="line">    alert( <span class="keyword">this</span>.color);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,age</span>) </span>&#123;            <span class="comment">//构造一个Child函数，添加属性age</span></span><br><span class="line"></span><br><span class="line">Father.call(<span class="keyword">this</span>,name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Father(); <span class="comment">//将Father的实例 赋值给 Child的原型</span></span><br><span class="line"></span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line">Child.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="comment">//给 Child添加原型方法</span></span><br><span class="line"></span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newChild = <span class="keyword">new</span> Child(<span class="string">'小明同学'</span>,<span class="number">22</span>);  <span class="comment">//实例化一个 Child</span></span><br><span class="line"></span><br><span class="line">newChild.food.push(<span class="string">'猪肉'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newChild.food);</span><br><span class="line"></span><br><span class="line">newChild.eat();</span><br><span class="line"></span><br><span class="line">newChild.getAge();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherChild = <span class="keyword">new</span> Child(<span class="string">'比卡丘'</span>,<span class="number">22</span>);  <span class="comment">//实例化一个 Child</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(anotherChild.food);</span><br><span class="line"></span><br><span class="line">anotherChild.eat();</span><br><span class="line"></span><br><span class="line">anotherChild.getAge();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newChild.constructor);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Child.prototype.constructor);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newChild.getColor());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newChild.getEye());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(Child.prototype));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(newChild));</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/mingtan/p/6429332.html" target="_blank" rel="noopener">Javascript 原型链之原型对象、实例和构造函数三者之间的关系</a> </p>
<p><a href="https://www.cnblogs.com/mingtan/p/6429332.html" target="_blank" rel="noopener">编程思想：面向对象和面向过程</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">Javascript面向对象编程（二）：构造函数的继承</a></p>
<p>《JavaScript高级编程设计》 第三版</p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>network中的请求信息，headers中的每一项分别是什么意义?</title>
    <url>/2019/11/10/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%835/network%E4%B8%AD%E7%9A%84%E8%AF%B7%E6%B1%82%E4%BF%A1%E6%81%AF%EF%BC%8Cheaders%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E9%A1%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>作为一个Web开发人员，日常中与我们开发相关的，就是Chrome的开发者工具。 Network标签页对于分析网站请求的网络情况、查看某一请求的<strong>请求头</strong>和<strong>响 应头</strong>还有<strong>响应内容</strong>很有用，特别是在查看Ajax类请求的时候，非常有帮助。 今天就是要简要说说Chrome的开发者工具中Network中header部分。</p><a id="more"></a>
<h1 id="知识剖析"><a href="#知识剖析" class="headerlink" title="知识剖析"></a>知识剖析</h1><h2 id="HTTP请求的7个步骤"><a href="#HTTP请求的7个步骤" class="headerlink" title="HTTP请求的7个步骤"></a>HTTP请求的7个步骤</h2><p>1.建立TCP链接</p>
<p>2.浏览器发送请求（GET/sample/hello.jsp HTTP/1.1）</p>
<p>3.浏览器发送请求头（request header）</p>
<p>4.服务器发送应答（HTTP/1.1 200 OK）</p>
<p>5.服务器发送应答头（response header）</p>
<p>6.服务器发送数据</p>
<p>7.服务器关闭TCP连接</p>
<h2 id="Http报文结构"><a href="#Http报文结构" class="headerlink" title="Http报文结构"></a>Http报文结构</h2><p>用于HTTP协议交互的信息被称为HTTP报文，客户端的HTTP报文叫做请求报文，服务器端的叫做响应报文。 HTTP报文本身是由多行数据构成的字符串文本。</p>
<p>URI:uniform resource identifier,统一资源标识符。URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。</p>
<h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p><img src="https://img-blog.csdnimg.cn/20191110231546170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW54aW50aWFuZGlzaGVuZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p><img src="https://img-blog.csdnimg.cn/2019111023165569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW54aW50aWFuZGlzaGVuZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Network下的Header"><a href="#Network下的Header" class="headerlink" title="Network下的Header"></a>Network下的Header</h2><ol>
<li>首先我们打开chrome的开发者工具</li>
<li>选中network，再刷新页面，此时可以在下方看到一个Name，Name对应的是资源的名称及其路径，Status是请求服务器返回的状态码,当状态码为200时，则表示接口配置成功。</li>
<li>点击任一文件名，右侧则会出现Header选项。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20191110232555427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW54aW50aWFuZGlzaGVuZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Header中的各项的含义"><a href="#Header中的各项的含义" class="headerlink" title="Header中的各项的含义"></a>Header中的各项的含义</h2><h3 id="General部分"><a href="#General部分" class="headerlink" title="General部分"></a>General部分</h3><p>Request URL:资源的请求url</p>
<p>Request Method:HTTP方法</p>
<p>Status Code:响应状态码</p>
<ul>
<li>200（状态码） OK（原因短语）</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20191110232705165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW54aW50aWFuZGlzaGVuZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Response-Headers"><a href="#Response-Headers" class="headerlink" title="Response Headers"></a>Response Headers</h2><p>Content-Encoding:gzip ——压缩编码类型</p>
<p>Content-Type:text/html ——服务端发送的类型及采用的编码方式</p>
<p>Date:Tue, 14 Feb 2017 03:38:28 GMT ——客户端请求服务端的时间</p>
<p>Last-Modified:Fri, 10 Feb 2017 09:46:23 GMT ——服务端对该资源最后修改的时间，GMT是格林尼治标准时间</p>
<p>Server:nginx/1.2.4 ——服务端的Web服务端名</p>
<p>Transfer-Encoding:chunked ——分块传递数据到客户端</p>
<p><img src="https://img-blog.csdnimg.cn/20191110232739709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW54aW50aWFuZGlzaGVuZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Request-Headers"><a href="#Request-Headers" class="headerlink" title="Request Headers"></a>Request Headers</h2><p>Accept:text/html ——客户端能接收的资源类型</p>
<p>Accept-Encoding:gzip, deflate ——客户端能接收的压缩数据的类型</p>
<p>Accept-Language:en-US,en;q=0.8 ——客户端接收的语言类型</p>
<p>Cache-Control:no-cache ——服务端禁止客户端缓存页面数据</p>
<p>Connection:keep-alive ——维护客户端和服务端的连接关系</p>
<p>Cookie: ——客户端暂存服务端的信息</p>
<p>Host:<a href="http://www.jnshu.com" target="_blank" rel="noopener">www.jnshu.com</a> ——连接的目标主机和端口号</p>
<p>Pragma:no-cache ——服务端禁止客户端缓存页面数据</p>
<p>Referer:<a href="http://www.jnshu.com/daily/15052" target="_blank" rel="noopener">http://www.jnshu.com/daily/15052</a> ——来于哪里</p>
<p>User-Agent: ——客户端版本号的名字</p>
<p><img src="https://img-blog.csdnimg.cn/20191110232815392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW54aW50aWFuZGlzaGVuZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>使用post发送请求时如何设置content-type的值？</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ul>
<li>application/x-www-form-urlencoded 最常见的POST提交格式，使用这个编码格式post的数据会以键值对的方式提交</li>
<li>multipart/form-data 通常上传图片等文件会使用这种编码格式提交。</li>
<li>application/json 提交JSON格式的数据</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://link.jianshu.com?t=http://blog.csdn.net/ahuangtaoa/article/details/8666407" target="_blank" rel="noopener">http中请求头和响应头</a></p>
<p><a href="https://link.jianshu.com?t=http://blog.csdn.net/klarclm/article/details/7711021" target="_blank" rel="noopener">content-type说明</a></p>
<p><a href="https://link.jianshu.com?t=http://www.softwhy.com/forum.php?mod=viewthread&amp;tid=19118" target="_blank" rel="noopener">谷歌浏览器Timeline用法详解</a></p>
<p><a href="https://www.jianshu.com/p/6ba9273692c5" target="_blank" rel="noopener">network中的请求信息</a></p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>异步编程有哪几种方法来实现?</title>
    <url>/2019/11/10/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%835/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E6%9D%A5%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>Javascript语言的执行环境是”单线程”.所谓”单线程”，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。 </p><ul>
<li>这种模式的好处是实现起来比较简单，执行环境相对单纯；</li>
<li>坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。 </li>
</ul><a id="more"></a>

<p>异步就是让某个函数创建一个别的线程或进程，与JS主线程并行地做一些事情，并在事情做完后通知JS主线程。因此我们可以认为setTimeout这类JS规范之外的由运行环境提供的特殊函数做的事情是创建一个平行线程后立即返回，让JS主进程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数。但是即使平行线程完成工作了，通知JS主线程执行回调函数了，回调函数也要等到JS主线程空闲时才能开始执行。</p>
<h1 id="知识剖析"><a href="#知识剖析" class="headerlink" title="知识剖析"></a>知识剖析</h1><p>Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。 </p>
<ul>
<li>“同步模式”：后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的； </li>
<li>“异步模式”则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。非常重要。</li>
</ul>
<p>在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，”异步模式”甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。</p>
<h1 id="实现”异步模式”编程的方法"><a href="#实现”异步模式”编程的方法" class="headerlink" title="实现”异步模式”编程的方法"></a>实现”异步模式”编程的方法</h1><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>一般情况下，应用程序时常通过API调用库里所预先备好的函数。但是有些库函数却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"任务111111111执行"</span>);</span><br><span class="line">            callback();</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"任务2222222执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"任务333333执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    f1(f2);</span><br><span class="line">    f3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();<span class="comment">//依次打印3 1 2</span></span><br></pre></td></tr></table></figure>
<p>采用这种方式，我们把同步操作变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。 回调函数的优点是简单、容易理解和部署. </p>
<p>但是回调函数的方式存在如下的问题： </p>
<ol>
<li>缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。</li>
<li>可能形成万恶的嵌套金字塔，代码不易阅读；</li>
<li><strong>只能对应一个回调函数，在很多场景中成为一个限制。</strong></li>
</ol>
<h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。 <img src="https://upload-images.jianshu.io/upload_images/6325644-11002e5d7396ae89.png?imageMogr2/auto-orient/strip|imageView2/2/w/615/format/webp" alt="img"> </p>
<p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p>
<h2 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h2><p>我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。这个模式有多种实现，下面采用的是Ben Alman的Tiny Pub/Sub，这是jQuery的一个插件。<br>首先，f2向”信号中心”jQuery订阅”done”信号。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6325644-786543a853f98a89.png?imageMogr2/auto-orient/strip|imageView2/2/w/568/format/webp" alt="img"> </p>
<p>jQuery.publish(“done”)的意思是，f1执行完成后，向”信号中心”jQuery发布”done”信号，从而引发f2的执行。 此外，f2完成执行后，也可以取消订阅（unsubscribe）。<br>这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise象征着一个异步操作的最终结果。Promises交互主要通过它的then方法， then方法接受一个回调函数，这个回调函数接受执行成功的返回值或执行失败的错误原因， 错误原因一般是Error对象。Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。 简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。<br>Promise有以下几种状态：<br>1.pending: 初始状态, 既不是 fulfilled 也不是 rejected。<br>2.fulfilled: 表示操作被成功完成。<br>3.rejected: 表示该操作失败。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6325644-8e847934e800d8ea.png?imageMogr2/auto-orient/strip|imageView2/2/w/521/format/webp" alt="img"> </p>
<p>而且，它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。这种方法的缺点就是编写和理解，都相对比较难。</p>
<h1 id="Promise的基本使用"><a href="#Promise的基本使用" class="headerlink" title="Promise的基本使用"></a>Promise的基本使用</h1><p>复杂的概念先不讲，我们先简单粗暴地把Promise用一下，有个直观感受。那么第一个问题来了，Promise是什么玩意呢？是一个类？对象？数组？函数？ </p>
<p>别猜了，直接打印出来看看吧，console.dir(Promise)，就这么简单粗暴。</p>
<p><img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311003722741-755677508.png" alt="img"></p>
<p>这么一看就明白了，Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。这么说用Promise new出来的对象肯定就有then、catch方法喽，没错。</p>
<p>那就new一个玩玩吧。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//做一些异步操作</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'执行完成'</span>);</span><br><span class="line">        resolve(<span class="string">'随便什么数据'</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。不过在我们开始阶段可以先这么理解，后面再细究概念。</p>
<p>在上面的代码中，我们执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，并且调用resolve方法。</p>
<p>运行代码，会在2秒后输出“执行完成”。注意！我只是new了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'执行完成'</span>);</span><br><span class="line">            resolve(<span class="string">'随便什么数据'</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line">runAsync()</span><br></pre></td></tr></table></figure>
<p>这时候你应该有两个疑问：1.包装这么一个函数有毛线用？2.resolve(‘随便什么数据’);这是干毛的？</p>
<p>我们继续来讲。在我们包装好的函数最后，会return出Promise对象，也就是说，执行这个函数我们得到了一个Promise对象。还记得Promise对象上有then、catch方法吧？这就是强大之处了，看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">runAsync().then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="comment">//后面可以用传过来的数据做些其他操作</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的的参数。运行这段代码，会在2秒后输出“执行完成”，紧接着输出“随便什么数据”。</p>
<p>这时候你应该有所领悟了，原来then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。</p>
<p>你可能会不屑一顾，那么牛逼轰轰的Promise就这点能耐？我把回调函数封装一下，给runAsync传进去不也一样吗，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'执行完成'</span>);</span><br><span class="line">        callback(<span class="string">'随便什么数据'</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runAsync(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>效果也是一样的，还费劲用Promise干嘛。那么问题来了，有多层回调该怎么办？如果callback也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个callback2，然后给callback传进去吧。而Promise的优势在于，可以在then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。</p>
<h2 id="链式操作的用法"><a href="#链式操作的用法" class="headerlink" title="链式操作的用法"></a><strong>链式操作的用法</strong></h2><p>所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">runAsync1()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> runAsync2();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> runAsync3();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样能够按顺序，每隔两秒输出每个异步回调中的内容，在runAsync2中传给resolve的数据，能在接下来的then方法中拿到。运行结果如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004311507-221152206.png" alt="img"></p>
<p>猜猜runAsync1、runAsync2、runAsync3这三个函数都是如何定义的？没错，就是下面这样（代码较长请自行展开）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'异步任务1执行完成'</span>);</span><br><span class="line">            resolve(<span class="string">'随便什么数据1'</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'异步任务2执行完成'</span>);</span><br><span class="line">            resolve(<span class="string">'随便什么数据2'</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//做一些异步操作</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'异步任务3执行完成'</span>);</span><br><span class="line">            resolve(<span class="string">'随便什么数据3'</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了，比如我们把上面的代码修改成这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">runAsync1()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> runAsync2();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'直接返回数据'</span>;  <span class="comment">//这里直接返回数据</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>那么输出就变成了这样：</p>
<p><img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004444163-67067993.png" alt="img"></p>
<h2 id="reject的用法"><a href="#reject的用法" class="headerlink" title="reject的用法"></a><strong>reject的用法</strong></h2><p>到这里，你应该对“Promise是什么玩意”有了最基本的了解。那么我们接着来看看ES6的Promise还有哪些功能。我们光用了resolve，还没用reject呢，它是做什么的呢？事实上，我们前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，reject的作用就是把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。</p>
<p>按 Ctrl+C 复制代码</p>
<p>按 Ctrl+C 复制代码</p>
<p>getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。</p>
<p>运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：</p>
<p><img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004607960-1156803894.png" alt="img"> 或者 <img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004616257-1024778840.png" alt="img"></p>
<h2 id="catch的用法"><a href="#catch的用法" class="headerlink" title="catch的用法"></a><strong>catch的用法</strong></h2><p>我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调，用法是这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getNumber()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'resolved'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。请看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getNumber()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'resolved'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="built_in">console</span>.log(somedata); <span class="comment">//此处的somedata未定义</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：</p>
<p><img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004747147-1508291069.png" alt="img"></p>
<p>也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能。</p>
<h2 id="all的用法"><a href="#all的用法" class="headerlink" title="all的用法"></a><strong>all的用法</strong></h2><p>Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。我们仍旧使用上面定义好的runAsync1、runAsync2、runAsync3这三个函数，看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span></span><br><span class="line">.all([runAsync1(), runAsync2(), runAsync3()])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>用Promise.all来执行，all接收一个数组参数，里面的值最终都算返回Promise对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到then里面。那么，三个异步操作返回的数据哪里去了呢？都在then里面呢，all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。所以上面代码的输出结果就是：</p>
<p><img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004843491-346782307.png" alt="img"></p>
<p>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</p>
<h2 id="race的用法"><a href="#race的用法" class="headerlink" title="race的用法"></a><strong>race的用法</strong></h2><p>all方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是race方法，这个词本来就是赛跑的意思。race的用法与all一样，我们把上面runAsync1的延时改为1秒来看一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span></span><br><span class="line">.race([runAsync1(), runAsync2(), runAsync3()])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这三个异步操作同样是并行执行的。结果你应该可以猜到，1秒后runAsync1已经执行完了，此时then里面的就执行了。结果是这样的：</p>
<p><img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311004946022-706413123.png" alt="img"></p>
<p>你猜对了吗？不完全，是吧。在then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧再执行。于是再过1秒后，输出了他们结束的标志。</p>
<p>这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求某个图片资源</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestImg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            resolve(img);</span><br><span class="line">        &#125;</span><br><span class="line">        img.src = <span class="string">'xxxxxx'</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//延时函数，用于给请求计时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            reject(<span class="string">'图片请求超时'</span>);</span><br><span class="line">        &#125;, <span class="number">5000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span></span><br><span class="line">.race([requestImg(), timeout()])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>requestImg函数会异步请求一张图片，我把地址写为”xxxxxx”，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。运行结果如下：</p>
<p><img src="https://images2015.cnblogs.com/blog/520134/201603/520134-20160311005040272-341718790.png" alt="img"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/e424f7a71a50" target="_blank" rel="noopener">异步编程的实现方法</a></p>
<p><a href="https://www.cnblogs.com/lvdabao/p/es6-promise-1.html" target="_blank" rel="noopener">大白话讲解Promise</a></p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>Ajax异步请求之设置Content-Type</title>
    <url>/2019/11/10/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%835/Ajax%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E4%B9%8B%E8%AE%BE%E7%BD%AEContent-Type/</url>
    <content><![CDATA[<h1 id="什么是AJAX"><a href="#什么是AJAX" class="headerlink" title="什么是AJAX"></a><strong>什么是AJAX</strong></h1><p> 先给出结论——我们每日用到的AJAX，是通过javascript的XMLHttpRequest对象，使用HTTP请求，来直接与服务器通信。<br> 而angular的$http服务，其内部代码也是使用XMLHttpRequest对象来连接服务器。</p><p>问题：为什么这个post请求不能成功，服务器返回码虽然是200，但它值总是不对？？？</p><a id="more"></a>

<p>答案：除开请求参数，请求地址等基本错误外，还有可能有一个非常重要的原因就是请求头中的Content-Type不对。</p>
<h1 id="基础知识Http"><a href="#基础知识Http" class="headerlink" title="基础知识Http"></a>基础知识Http</h1><p>HTTP，是一套网络通信规则，让我们可以通过浏览器等客户端请求和发送数据到服务器。</p>
<h2 id="HTTP通信步骤"><a href="#HTTP通信步骤" class="headerlink" title="HTTP通信步骤"></a>HTTP通信步骤</h2><p>每次HTTP通信需要完成7个步骤</p>
<ol>
<li>建立TCP连接 </li>
<li>浏览器向服务器发送请求命令 </li>
<li>浏览器发送请求头信息 </li>
<li>服务器应答 </li>
<li>服务器发送应答头信息 </li>
<li>服务器向浏览器发送数据 </li>
<li>关闭TCP连接</li>
</ol>
<p>进一步诠释HTTP（可以不看的部分）：</p>
<h2 id="请求头声明"><a href="#请求头声明" class="headerlink" title="请求头声明"></a>请求头声明</h2><p>请求头声明有关浏览器和正文的一些相关信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Encoding:gzip</span><br><span class="line">Content-Language:zh-CN</span><br><span class="line">Content-Type:text/html; charset=utf-8</span><br><span class="line">Date:Wed, 11 Jan 2017 01:48:38 GMT</span><br><span class="line">Pragma:no-cache``Server:nginx/1.4.6 (Ubuntu)</span><br><span class="line">Transfer-Encoding:chunked</span><br></pre></td></tr></table></figure>
<h2 id="应答码"><a href="#应答码" class="headerlink" title="应答码"></a>应答码</h2><p>1XX 收到请求，正在处理</p>
<p>2XX 成功类</p>
<p>3XX 重定向类</p>
<p>4XX 客户端错误类（著名的404，表示请求的页面不存在）</p>
<p>5XX 服务器错误类</p>
<h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><p>响应头包含的服务信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept:application/json, text/plain, /</span><br><span class="line"></span><br><span class="line">Accept-Encoding:gzip, deflate, sdch</span><br><span class="line"></span><br><span class="line">Accept-Language:zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4</span><br><span class="line"></span><br><span class="line">Connection:keep-alive</span><br><span class="line"></span><br><span class="line">Cookie:JSESSIONID=aaa6A1XXqQ-QbbwfPOZGv</span><br><span class="line"></span><br><span class="line">Host:59.110.159.108</span><br><span class="line"></span><br><span class="line">Referer:http://59.110.159.108/luoboduo/html/index.html</span><br><span class="line"></span><br><span class="line">User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36</span><br></pre></td></tr></table></figure>
<h2 id="服务器返回的数据（JSON-XML-…-）"><a href="#服务器返回的数据（JSON-XML-…-）" class="headerlink" title="服务器返回的数据（JSON/XML/….）"></a>服务器返回的数据（JSON/XML/….）</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"code"</span>:<span class="number">0</span>,<span class="string">"message"</span>:<span class="string">"success"</span>,<span class="string">"onlineUserCount"</span>:<span class="string">""</span>,<span class="string">"classCount"</span>:<span class="number">308</span>,<span class="string">"userCount"</span>:<span class="number">8507</span>&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Content-Type设置"><a href="#Content-Type设置" class="headerlink" title="Content-Type设置"></a>Content-Type设置</h1><p>因为POST请求的协议并没有规定数据必须使用什么编码方式，而数据发送出去，还要服务器解析成功才行。服务器则通常根据请求头里的Content-Type字段来获知消息是以什么方式编码，再以对应方式解析。而有的接口服务器则不能解析某些编码方式的数据。因此需要对Content-Type进行设置。</p>
<p>最常见的Content-Type列出如下：</p>
<h2 id="1-application-x-www-form-urlencoded"><a href="#1-application-x-www-form-urlencoded" class="headerlink" title="1. application/x-www-form-urlencoded"></a>1. application/x-www-form-urlencoded</h2><p><strong>应用场景：</strong>  最常见的POST提交格式，使用这个编码格式post的数据会以这种方式提交：key1=value1&amp;key2=value2。而我们的任务中所用到的大多数接口都只支持这种编码格式。</p>
<p><strong>注意：</strong> jquery的POST默认就是application/x-www-form-urlencoded；而angular默认是application/json，而且若是提交的数据格式为json则需要序列化$.param(json)</p>
<h2 id="2-multipart-form-data"><a href="#2-multipart-form-data" class="headerlink" title="2. multipart/form-data"></a>2. multipart/form-data</h2><p><strong>应用场景：</strong>  通常上传图片等文件会使用这种编码格式提交。</p>
<p><strong>使用方法：</strong> <code>var fd = new FormData(); fd.append(key, value);</code></p>
<p><strong>注意：</strong> 若使用jquery，Content-Type设置为false；若使用angular，Content-Type设置为undefind</p>
<h2 id="3-application-json"><a href="#3-application-json" class="headerlink" title="3. application/json"></a>3. application/json</h2><p><strong>应用场景：</strong> 提交JSON格式的数据</p>
<p><strong>注意：</strong> 若使用jquery，json数据需要字符串化JSON.stringify()；若使用angular，直接使用json即可</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>什么是Ajax？</title>
    <url>/2019/11/10/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%835/%E4%BB%80%E4%B9%88%E6%98%AFAjax%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>2005，一一篇题为“Ajax： A new Approach to Web Applications”，这篇文章介绍了一种叫做Ajax新技术，是对Asynchronous JavaScript +XML的简写。这一技术能够向服务器请求额外的数据而无序卸载页面，会带来更好的用户体验。</p><p><strong>负责Ajax运作的核心对象是XMLHttpRequest（XHR）对象。</strong></p><a id="more"></a>

<p>在使用XHR对象时，要调用的第一个方法时open（），它接受三个参数：要发送的请求的类型（“get”、“post”等）、请求的URL、表示是否发送异步请求的布尔值。</p>
<h2 id="Ajax与传统工作方式的对比"><a href="#Ajax与传统工作方式的对比" class="headerlink" title="Ajax与传统工作方式的对比"></a>Ajax与传统工作方式的对比</h2><ul>
<li>a. 传统的工作方式：传统的web应用程序中，用户向服务器发送一个请求，然后等待，服务器接受到用户的请求然后响应。在这段时间内，页面会进行整体刷新，产生一个等待新页面加载完成的时间，这是因为这种传输方式为同步处理方式。长久以来我们对这种web交互模式已经习惯了，并且以使用者的角度来讲已经觉得是理所当然的事情了。</li>
<li>b. Ajax的工作方式：和传统的web应用不同，Ajax采取了异步交互避免了用户请求-等待-应答交互方式的缺点。Ajax在应用程序和服务器中引入了一个中间层—Ajax引擎，它是用Javascript编写的，在一个隐藏的框架中运行。Ajax引擎负责呈现用户界面，以及代表用户和服务器进行交互。Ajax引擎允许用户和服务器进行异步的交互。用户无需等待页面的整体重新加载。</li>
</ul>
<p>总结：传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。使用Ajax技术，可以节省网络带宽，提高页面的加载速度，从而缩短用户等待时间，改善用户体验</p>
<h1 id="Ajax如何发起HTTP请求？"><a href="#Ajax如何发起HTTP请求？" class="headerlink" title="Ajax如何发起HTTP请求？"></a>Ajax如何发起HTTP请求？</h1><p>Ajax通过XMLHttpRequest对象发出HTTP请求，得到服务器返回的数据后再进行处理。XMLHttpRequest对象用来在浏览器与服务器之间传送数据。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、创建创建Ajax对象</span></span><br><span class="line"><span class="keyword">var</span> oAjax = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">//2、连接服务器（打开和服务器的连接）</span></span><br><span class="line">oAjax.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);<span class="comment">//HTTP方法、连接地址、同步或异步，true为异步</span></span><br><span class="line"><span class="comment">//3、发送数据</span></span><br><span class="line">oAjax.send();</span><br><span class="line"><span class="comment">//4、接收数据</span></span><br><span class="line">oAjax.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 通信成功时，状态值为4</span></span><br><span class="line">  <span class="keyword">if</span> (oAjax.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (oAjax.status === <span class="number">200</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(oAjax.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(oAjax.statusText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="open方法"><a href="#open方法" class="headerlink" title="open方法"></a>open方法</h2><p>XMLHttpRequest对象的open方法用于指定发送HTTP请求的参数：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> open(</span><br><span class="line">   string method, <span class="comment">//method：表示HTTP动词/方法，比如“GET”、“POST”、“PUT”和“DELETE”</span></span><br><span class="line">   string url, <span class="comment">//url: 表示请求发送的网址</span></span><br><span class="line">   optional boolean <span class="keyword">async</span>, <span class="comment">//async: 格式为布尔值，默认为true，表示请求是否为异步</span></span><br><span class="line">   optional string user, <span class="comment">//user：表示用于认证的用户名，默认为空字符串</span></span><br><span class="line">   optional string password <span class="comment">//password：表示用于认证的密码，默认为空字符串</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h2 id="send方法"><a href="#send方法" class="headerlink" title="send方法"></a>send方法</h2><p>send方法用于实际发出HTTP请求。<br>如果不带参数，就表示HTTP请求只包含头信息，也就是只有一个URL，典型例子就是GET请求（get请求本身是通过URL传递数据的）；如果带有参数，就表示除了头信息，还带有包含具体数据的信息体，典型例子就是POST请求。send可以传递多种格式的数据。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">oAjax.open(<span class="string">'POST'</span>, <span class="string">'http://www.example.com/somepage.php'</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="onreadystatechange监控请求状态"><a href="#onreadystatechange监控请求状态" class="headerlink" title="onreadystatechange监控请求状态"></a>onreadystatechange监控请求状态</h2><p>onreadystatechange监控请求状态，readyState就是请求状态，readyState的值就代表不同的状态：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0    （未初始化）还没有调用open()方法</span><br><span class="line">1    （载入）已调用send()方法，正在发送请求</span><br><span class="line">2    （载入完成）send()方法完成，已收到全部响应内容</span><br><span class="line">3    （解析）正在解析响应内容</span><br><span class="line">4    （完成）响应内容解析完成，可以在客户端调用了</span><br></pre></td></tr></table></figure></p>
<h2 id="status属性"><a href="#status属性" class="headerlink" title="status属性"></a>status属性</h2><p>status属性表示请求得到的HTTP状态码，<br>如果通信成功就是200。statusText属性返回一个字符串，表示服务器发送的状态提示。不同于status属性，该属性包含整个状态信息，比如“200 OK”。</p>
<h2 id="responseText属性"><a href="#responseText属性" class="headerlink" title="responseText属性"></a>responseText属性</h2><p>responseText属性返回从服务器接收到的字符串。</p>
<h1 id="编码实战"><a href="#编码实战" class="headerlink" title="编码实战"></a>编码实战</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> 1<span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"> 2<span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"> 3</span><br><span class="line"> 4<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> 5    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"> 6    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> 7    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"index.css"</span>&gt;</span></span><br><span class="line"> 8    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> 9<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">10</span><br><span class="line">11<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">12    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"login"</span> &gt;</span></span><br><span class="line">13        <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"用户名"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"text"</span> &gt;</span></span><br><span class="line">14        <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"密码"</span> <span class="attr">name</span>=<span class="string">"pwd"</span> <span class="attr">type</span>=<span class="string">"password"</span> &gt;</span></span><br><span class="line">15        <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">16        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span> <span class="attr">type</span>=<span class="string">"submit"</span> &gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">17    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">18    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"ajax.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">19<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">20</span><br><span class="line">21<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="JavaScript-amp-Ajax"><a href="#JavaScript-amp-Ajax" class="headerlink" title="JavaScript &amp; Ajax"></a>JavaScript &amp; Ajax</h2><h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span><span class="comment">//IE9+</span></span><br><span class="line"> <span class="number">2</span><span class="keyword">var</span> aValue = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>);</span><br><span class="line"> <span class="number">3</span><span class="keyword">var</span> oMsg = <span class="built_in">document</span>.getElementById(<span class="string">'msg'</span>);</span><br><span class="line"> <span class="number">4</span><span class="keyword">var</span> oBtn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"> <span class="number">5</span><span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"> <span class="number">6</span></span><br><span class="line"> <span class="number">7</span>oBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"> <span class="number">8</span>    event.preventDefault();</span><br><span class="line"> <span class="number">9</span></span><br><span class="line"><span class="number">10</span>    <span class="keyword">var</span> name = aValue[<span class="number">0</span>].value;</span><br><span class="line"><span class="number">11</span>    <span class="keyword">var</span> pwd = aValue[<span class="number">1</span>].value;</span><br><span class="line"><span class="number">12</span>    <span class="keyword">var</span> data = <span class="string">"name="</span> + name + <span class="string">"&amp;pwd="</span> + pwd;</span><br><span class="line"><span class="number">13</span>    <span class="keyword">var</span> oAjax = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span>    oAjax.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="number">16</span>        <span class="keyword">if</span> (oAjax.readyState == <span class="number">4</span> &amp;&amp; oAjax.status == <span class="number">200</span>) &#123;</span><br><span class="line"><span class="number">17</span>            <span class="keyword">var</span> resdata = <span class="built_in">JSON</span>.parse(oAjax.responseText);</span><br><span class="line"><span class="number">18</span>            <span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="number">19</span>            <span class="built_in">console</span>.log(pwd);</span><br><span class="line"><span class="number">20</span>            <span class="built_in">console</span>.log(resdata);</span><br><span class="line"><span class="number">21</span>            <span class="keyword">if</span> (resdata.code === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">22</span>                <span class="built_in">window</span>.location.href = <span class="string">"http://dev.admin.carrots.ptteng.com/"</span>;</span><br><span class="line"><span class="number">23</span>            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">24</span>                clearInterval(timer);</span><br><span class="line"><span class="number">25</span>                oMsg.innerHTML = resdata.message;</span><br><span class="line"><span class="number">26</span>                timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="number">27</span>                    oMsg.innerHTML = <span class="string">''</span>;</span><br><span class="line"><span class="number">28</span>                &#125;, <span class="number">3000</span>)</span><br><span class="line"><span class="number">29</span>            &#125;</span><br><span class="line"><span class="number">30</span>        &#125;</span><br><span class="line"><span class="number">31</span>    &#125;</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">33</span>    oAjax.open(<span class="string">'POST'</span>, <span class="string">'/carrots-admin-ajax/a/login'</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">35</span>    oAjax.setRequestHeader(<span class="string">'content-type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">37</span>    oAjax.send(data);</span><br><span class="line"><span class="number">38</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用FormData"><a href="#使用FormData" class="headerlink" title="使用FormData"></a>使用FormData</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span><span class="comment">//IE10+</span></span><br><span class="line"> <span class="number">2</span><span class="keyword">var</span> oForm = <span class="built_in">document</span>.getElementById(<span class="string">'login'</span>);</span><br><span class="line"> <span class="number">3</span><span class="keyword">var</span> oMsg = <span class="built_in">document</span>.getElementById(<span class="string">'msg'</span>);</span><br><span class="line"> <span class="number">4</span><span class="keyword">var</span> oBtn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"> <span class="number">5</span><span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"> <span class="number">6</span></span><br><span class="line"> <span class="number">7</span>oBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"> <span class="number">8</span>    event.preventDefault();</span><br><span class="line"> <span class="number">9</span></span><br><span class="line"><span class="number">10</span>    <span class="keyword">var</span> data = <span class="keyword">new</span> FormData(oForm);</span><br><span class="line"><span class="number">11</span>    <span class="keyword">var</span> oAjax = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span>    oAjax.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span>        <span class="keyword">if</span> (oAjax.readyState == <span class="number">4</span> &amp;&amp; oAjax.status == <span class="number">200</span>) &#123;</span><br><span class="line"><span class="number">16</span>            <span class="keyword">var</span> resdata = <span class="built_in">JSON</span>.parse(oAjax.responseText);</span><br><span class="line"><span class="number">17</span>            <span class="comment">//console.log(data.get('name')); //IE不支持FormData的get方法</span></span><br><span class="line"><span class="number">18</span>            <span class="comment">//console.log(data.get('pwd'));</span></span><br><span class="line"><span class="number">19</span>            <span class="built_in">console</span>.log(resdata);</span><br><span class="line"><span class="number">20</span>            <span class="keyword">if</span> (resdata.code === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">21</span>                <span class="built_in">window</span>.location.href = <span class="string">"http://dev.admin.carrots.ptteng.com/"</span>;</span><br><span class="line"><span class="number">22</span>            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">23</span>                clearInterval(timer);</span><br><span class="line"><span class="number">24</span>                oMsg.innerHTML = resdata.message;</span><br><span class="line"><span class="number">25</span>                timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="number">26</span>                    oMsg.innerHTML = <span class="string">''</span>;</span><br><span class="line"><span class="number">27</span>                &#125;, <span class="number">3000</span>)</span><br><span class="line"><span class="number">28</span>            &#125;</span><br><span class="line"><span class="number">29</span>        &#125;</span><br><span class="line"><span class="number">30</span>    &#125;</span><br><span class="line"><span class="number">31</span></span><br><span class="line"><span class="number">32</span>    oAjax.open(<span class="string">'POST'</span>, <span class="string">'/carrots-admin-ajax/a/login'</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">34</span>    oAjax.send(data);</span><br><span class="line"><span class="number">35</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="jQuery-amp-Ajax"><a href="#jQuery-amp-Ajax" class="headerlink" title="jQuery &amp; Ajax"></a>jQuery &amp; Ajax</h2><h3 id="IE9-jQuery-post"><a href="#IE9-jQuery-post" class="headerlink" title="IE9+ jQuery.post()"></a>IE9+ jQuery.post()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span><span class="comment">//IE9+ jQuery.post()</span></span><br><span class="line"> <span class="number">2</span>$(<span class="string">"form"</span>).on(<span class="string">"submit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="number">3</span>    <span class="keyword">var</span> url = <span class="string">'/carrots-admin-ajax/a/login'</span>;</span><br><span class="line"> <span class="number">4</span>    <span class="keyword">var</span> formdata = $(<span class="keyword">this</span>).serialize();</span><br><span class="line"> <span class="number">5</span>    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"> <span class="number">6</span>    $.post(url, formdata,</span><br><span class="line"> <span class="number">7</span>        <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"> <span class="number">8</span>            <span class="built_in">console</span>.log(formdata);</span><br><span class="line"> <span class="number">9</span>            <span class="built_in">console</span>.log(data);</span><br><span class="line"><span class="number">10</span>            <span class="keyword">if</span> (data.code === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">11</span>                <span class="built_in">window</span>.location.href = <span class="string">"http://dev.admin.carrots.ptteng.com/"</span>;</span><br><span class="line"><span class="number">12</span>            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">13</span>                clearInterval(timer);</span><br><span class="line"><span class="number">14</span>                $(<span class="string">'#msg'</span>).html(data.message);</span><br><span class="line"><span class="number">15</span>                timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="number">16</span>                    $(<span class="string">'#msg'</span>).html(<span class="string">''</span>);</span><br><span class="line"><span class="number">17</span>                &#125;, <span class="number">3000</span>)</span><br><span class="line"><span class="number">18</span>            &#125;</span><br><span class="line"><span class="number">19</span>        &#125;, <span class="string">'json'</span>);</span><br><span class="line"><span class="number">20</span>    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//阻止表单默认提交行为</span></span><br><span class="line"><span class="number">21</span>&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="IE9-jQuery-ajax"><a href="#IE9-jQuery-ajax" class="headerlink" title="IE9+ jQuery.ajax()"></a>IE9+ jQuery.ajax()</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>$(<span class="string">"form"</span>).on(<span class="string">"submit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="number">2</span>    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"> <span class="number">3</span>    $.ajax(&#123;</span><br><span class="line"> <span class="number">4</span>        type: <span class="string">'POST'</span>,</span><br><span class="line"> <span class="number">5</span>        url: <span class="string">'/carrots-admin-ajax/a/login'</span>,</span><br><span class="line"> <span class="number">6</span>        data: $(<span class="string">'#login'</span>).serialize(),</span><br><span class="line"> <span class="number">7</span>        dataType: <span class="string">'json'</span>,</span><br><span class="line"> <span class="number">8</span>        success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"> <span class="number">9</span>            <span class="built_in">console</span>.log(data);</span><br><span class="line"><span class="number">10</span>            <span class="keyword">if</span> (data.code === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">11</span>                <span class="built_in">window</span>.location.href = <span class="string">"http://dev.admin.carrots.ptteng.com/"</span>;</span><br><span class="line"><span class="number">12</span>            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">13</span>               $(<span class="string">'#msg'</span>).html(data.message);</span><br><span class="line"><span class="number">14</span>                timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="number">15</span>                    $(<span class="string">'#msg'</span>).html(<span class="string">''</span>);</span><br><span class="line"><span class="number">16</span>                &#125;, <span class="number">3000</span>)</span><br><span class="line"><span class="number">17</span>            &#125;</span><br><span class="line"><span class="number">18</span>        &#125;</span><br><span class="line"><span class="number">19</span>    &#125;)</span><br><span class="line"><span class="number">20</span>    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//阻止表单默认提交行为</span></span><br><span class="line"><span class="number">21</span>&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="IE10-jQuery-ajax-amp-FormData"><a href="#IE10-jQuery-ajax-amp-FormData" class="headerlink" title="IE10+ jQuery.ajax() &amp; FormData"></a>IE10+ jQuery.ajax() &amp; FormData</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>$(<span class="string">"form"</span>).on(<span class="string">"submit"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="number">2</span>    <span class="keyword">var</span> formdata = <span class="keyword">new</span> FormData($(<span class="string">'#login'</span>)[<span class="number">0</span>]);</span><br><span class="line"> <span class="number">3</span>    $.ajax(&#123;</span><br><span class="line"> <span class="number">4</span>        type: <span class="string">'POST'</span>,</span><br><span class="line"> <span class="number">5</span>        url: <span class="string">'/carrots-admin-ajax/a/login'</span>,</span><br><span class="line"> <span class="number">6</span>        data: formdata,</span><br><span class="line"> <span class="number">7</span>        processData: <span class="literal">false</span>,</span><br><span class="line"> <span class="number">8</span>        contentType: <span class="literal">false</span>,</span><br><span class="line"> <span class="number">9</span>        dataType: <span class="string">'json'</span>,</span><br><span class="line"><span class="number">10</span>        success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="number">11</span>            <span class="built_in">console</span>.log(data);</span><br><span class="line"><span class="number">12</span>            <span class="keyword">if</span> (data.code === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">13</span>                <span class="built_in">window</span>.location.href = <span class="string">"http://dev.admin.carrots.ptteng.com/"</span>;</span><br><span class="line"><span class="number">14</span>            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">15</span>                $(<span class="string">'#msg'</span>).html(data.message);</span><br><span class="line"><span class="number">16</span>                timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="number">17</span>                    $(<span class="string">'#msg'</span>).html(<span class="string">''</span>);</span><br><span class="line"><span class="number">18</span>                &#125;, <span class="number">3000</span>)</span><br><span class="line"><span class="number">19</span>            &#125;</span><br><span class="line"><span class="number">20</span>        &#125;</span><br><span class="line"><span class="number">21</span>    &#125;)</span><br><span class="line"><span class="number">22</span>    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//阻止表单默认提交行为</span></span><br><span class="line"><span class="number">23</span>&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>使用post提交的时候需要进行的设置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//content-Type: application/x-www-form-urlencoded;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//jQuery中，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//content-Type: application/x-www-form-urlencoded;charset=utf-8;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//AngularJS中$http</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//content-Type: application/json; charset=utf-8;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用原生Ajax需要在open以后才能使用xhr.setRequestHeader()方法，否则出错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//xhr.open("post","xxxx.aspx",true);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//xhr.setRequestHeader("content-type","application/x-www-form-urlencoded")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用原生写时必须在open()方法之后send()方法之前调用</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://yuque.com/docs/share/14187470-4ab5-4e4e-bb01-3b1da19ed538#n80mxo" target="_blank" rel="noopener">不知名师弟的Task 5修炼秘籍 </a></p>
<p><a href="https://blog.csdn.net/tianxintiandisheng/article/details/82049402" target="_blank" rel="noopener">异步请求之设置Content-Type</a></p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>js操作符</title>
    <url>/2019/11/09/JS/js%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<p>ECMA-262描述了一组用于操作数据值的操作符，包括算数操作符、位操作符、关系操作符和相等操作符。<br>ECMAScript操作符的与众不同之处在于，它们能够使用于很多值，例如字符串、数字值、布尔值，甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的valueof()和tostring()方法，以便取得可以操作的值。</p><a id="more"></a>
<h1 id="一-一元操作符"><a href="#一-一元操作符" class="headerlink" title="一.一元操作符"></a>一.一元操作符</h1><p>只能操作一个值的操作符叫做一元操作符。</p>
<h3 id="1-递增和递减操作符-–"><a href="#1-递增和递减操作符-–" class="headerlink" title="1.递增和递减操作符 ++ –"></a>1.递增和递减操作符 ++ –</h3><p>递增和递减操作符各有两个版本：前置型和后置型<br>前置型：变量的值在语句被求值以前改变。<br>后置型：变量的值在语句被求值之后改变。</p>
<h3 id="2-一元加和一元减操作符"><a href="#2-一元加和一元减操作符" class="headerlink" title="2.一元加和一元减操作符"></a>2.一元加和一元减操作符</h3><p>一元加和一元减操作符主要用于基本的的算术运算，也可以用于转换数据类型。</p>
<h1 id="二-位操作符"><a href="#二-位操作符" class="headerlink" title="二.位操作符"></a>二.位操作符</h1><p>感觉没用到，跳过阅读。</p>
<h1 id="三-布尔操作符"><a href="#三-布尔操作符" class="headerlink" title="三.布尔操作符"></a>三.布尔操作符</h1><p>布尔操作符一共有三个：非、与、或</p>
<h3 id="1-逻辑非-！"><a href="#1-逻辑非-！" class="headerlink" title="1.逻辑非 ！"></a>1.逻辑非 ！</h3><p>逻辑非操作符（！）可以应用于ECMAScript中的任何值，无论这个值是什么数据类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后在对其求反。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(!&quot;blue&quot;)  //false</span><br></pre></td></tr></table></figure></p>
<p>逻辑非操作符（！）也可以用于将一个值转换为与其对应的布尔值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alert(!!&quot;blue&quot;)  //true 模拟Boolean()转型函数的行为</span><br></pre></td></tr></table></figure></p>
<h3 id="2-逻辑与-amp-amp"><a href="#2-逻辑与-amp-amp" class="headerlink" title="2.逻辑与 &amp;&amp;"></a>2.逻辑与 &amp;&amp;</h3><p>逻辑与操作符由两个和号表示（&amp;&amp;），有两个操作数。<br>逻辑与操作符可以应用与任何类型的操作数。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值。<br>逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会对第二个操作数求值。</p>
<h3 id="3-逻辑或"><a href="#3-逻辑或" class="headerlink" title="3.逻辑或 ||"></a>3.逻辑或 ||</h3><p>逻辑或操作符由两个竖线符号表示（||），有两个操作数。<br>逻辑或操作符可以应用与任何类型的操作数。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值。<br>逻辑或操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会对第二个操作数求值。</p>
<p>可以利用逻辑或的行为来避免为变量赋null或undefined值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myobject=preferredobject || backupobject</span><br></pre></td></tr></table></figure></p>
<h1 id="四、乘性操作符"><a href="#四、乘性操作符" class="headerlink" title="四、乘性操作符"></a>四、乘性操作符</h1><p>ECMAScript定义了3个乘性操作符：乘法、除法和求模。<br>这些操作符与java、C中的相应操作符用途类似，只不过在操作数为非数值的情况下会执行自动的类型转化。如果参与乘性计算的某个操作数不是数值，后台会先使用Number()转型函数将其转换为数值。</p>
<h3 id="1-乘法（-）"><a href="#1-乘法（-）" class="headerlink" title="1.乘法（*）"></a>1.乘法（*）</h3><p>乘法操作符由一个星号（*）表示，用于计算两个数的乘积。<br>在处理特殊值的的情况下，乘法操作符遵循一些特殊的规则。</p>
<h3 id="2-除法（-）"><a href="#2-除法（-）" class="headerlink" title="2.除法（/）"></a>2.除法（/）</h3><p>除法操作符由一个斜线符号（*）表示，用于计算两个数的商。<br>在处理特殊值的的情况下，除法操作符遵循一些特殊的规则。</p>
<h3 id="3-求模（-）"><a href="#3-求模（-）" class="headerlink" title="3.求模（%）"></a>3.求模（%）</h3><p>求模操作符由一个百分号（*）表示<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var result=26%5     //等于1</span><br></pre></td></tr></table></figure></p>
<p>在处理特殊值的的情况下，除法操作符遵循一些特殊的规则。</p>
<p>#五、加性操作符<br>与乘性操作符类似，加性操作符也会在后台转换不同的数据类型，然而对于加性操作符，相应的转换规则稍微有些复杂。</p>
<h3 id="1-加法（-）"><a href="#1-加法（-）" class="headerlink" title="1.加法（+）"></a>1.加法（+）</h3><p>如果两个操作数都是数值，执行常规的算数加法操作并返回结果。<br>在处理特殊值的的情况下，加性操作符遵循一些特殊的规则。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var result=5+&quot;5&quot;    //等于&quot;55&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-减法（-）"><a href="#2-减法（-）" class="headerlink" title="2.减法（-）"></a>2.减法（-）</h3><p>如果两个操作数都是数值，执行常规的算数减法操作并返回结果。<br>在处理特殊值的的情况下，加性操作符遵循一些特殊的规则。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var result1=5-true    //等于4,因为true被转换为1</span><br><span class="line">var result2=5-&quot;&quot;    //等于5,因为&quot;&quot;被转换为0</span><br><span class="line">var result3=5-&quot;2&quot;    //等于3,因为&quot;2&quot;被转换为2</span><br><span class="line">var result4=5-NaN    //等于NaN</span><br></pre></td></tr></table></figure></p>
<h1 id="六、关系操作符"><a href="#六、关系操作符" class="headerlink" title="六、关系操作符"></a>六、关系操作符</h1><p>ECMAScript定义了4个关系操作符：小于（&lt;）、大于（&gt;）、小于等于（&lt;=）、大于等于（&gt;=）<br>关系操作符用于对两个值进行比较，这几个操作符都返回一个布尔值。</p>
<p>当关系操作符的操作数使用了非数值时，要进行数据转换或者完成某些奇怪的操作。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var result1=&quot;a&quot;&lt; 3    //false,因为&quot;a&quot;被转换为了NaN</span><br><span class="line">var result2=NaN &lt;  3  //false，任何数与NaN进行比较，结果都是false</span><br><span class="line">var result3=NaN&gt; =  3  //false，任何数与NaN进行比较，结果都是false</span><br></pre></td></tr></table></figure></p>
<h1 id="七、相等操作符"><a href="#七、相等操作符" class="headerlink" title="七、相等操作符"></a>七、相等操作符</h1><p>ECMAScript提供两组操作符：相等和不相等—先转换再比较、全等和不全等—仅比较而不转换</p>
<h3 id="1-相等和不相等（-）、（！-）"><a href="#1-相等和不相等（-）、（！-）" class="headerlink" title="1.相等和不相等（==）、（！=）"></a>1.相等和不相等（==）、（！=）</h3><p>这两个操作符都会先转换操作数，然后再比较它们的相等性。</p>
<h3 id="2-全等和不全等（-）、（！-）"><a href="#2-全等和不全等（-）、（！-）" class="headerlink" title="2.全等和不全等（===）、（！==）"></a>2.全等和不全等（===）、（！==）</h3><p>这两个操作符不会转换操作数，直接比较它们的相等性。</p>
<h1 id="八、条件操作符"><a href="#八、条件操作符" class="headerlink" title="八、条件操作符"></a>八、条件操作符</h1><p>条件（三元）运算符是 JavaScript 仅有的使用三个操作数的运算符。本运算符经常作为if语句的简短形式来使用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var iMax = (iNum1 &gt; iNum2) ? iNum1 : iNum2;</span><br></pre></td></tr></table></figure></p>
<p>在这里例子中，iMax 将被赋予数字中的最大值。表达式声明如果 iNum1 大于 iNum2，则把 iNum1 赋予 iMax。但如果表达式为 false（即 iNum2 大于或等于 iNum1），则把 iNum2 赋予 iMax。</p>
<h1 id="九、赋值操作符-（-）"><a href="#九、赋值操作符-（-）" class="headerlink" title="九、赋值操作符 （=）"></a>九、赋值操作符 （=）</h1><p>赋值操作符由等于号（=）表示，其作用就是把右侧的值赋给左侧的变量。</p>
<h1 id="十、逗号操作符"><a href="#十、逗号操作符" class="headerlink" title="十、逗号操作符"></a>十、逗号操作符</h1><p>使用逗号操作符可以在一条语句中执行多个操作。<br>逗号操作符多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>js数据类型</title>
    <url>/2019/11/09/JS/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>  ECMAscript中有五种简单数据类型（也称基本数据类型）：Undefined、Null、Boolean、Number和String,还有一种复杂数据类型——Object，Object本质上是由一组无序的名值对组成的。</p><p>  ECMAscript不支持任何创建自定义类型的机制，而所有值最终都将是上述六种数据类型之一。</p><a id="more"></a>

<h2 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h2><p>Undefine类型只有一个值，即特殊的undefined。</p>
<h2 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h2><p>Null类型只有一个值，即特殊的null。从逻辑角度来看，null表示一个空对象指针，所以使用typeof操作符检测null时会返回“object”。</p>
<p>如果定义的变量准备在将来用于保存对象，那么最好将变量初始化为null而不是其他值。这样不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。</p>
<h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><p>Boolean只有两个字面值：true和false。</p>
<p>虽然Boolean类型的字面值只有两个，但是ECMAScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean（）。</p>
<p>流控制语句会自动执行相应的Boolean转换</p>
<h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><p>Number类型用IEEE754来表示正点数和浮点数值。</p>
<p>1.浮点数值</p>
<p>所为浮点数值，就是该数值中必须包括一个小数点，并且小数点后面必须至少有一位数字。</p>
<p>2.数值范围</p>
<p>由于内存的限制，EVMAScript不能保存世界上所有的数值。</p>
<p>3.NaN</p>
<p>NaN，即非数值（Not a Number）是一个特殊数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误）。</p>
<p>NaN有两个特点：首先，任何涉及NaN的操作都会返回NaN。其次，NaN与任何值都不相等，包括NaN本身。</p>
<p>针对这两个特点，ECMAScript定义了isNaN函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。</p>
<p>4.数值转换</p>
<p>有三个函数可以把非数值转换为数值：Number（），parseInt（）和parseFloat（）。</p>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String类型用于表示由零或多个16为Unicod字符组成的字符序列，即字符串。</p>
<p>1.字符表面量</p>
<p>String数据类型包含一些特殊的字符表面量，也叫转义序列，用于表示非打印字符，或者具有其他作用的字符。</p>
<p>2.字符串的特点</p>
<p>ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，他们的值就不能改变。</p>
<p>要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用一个包含新值的字符串填充该变量。</p>
<p>3.转换为字符串</p>
<p>要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的tostring（）方法。</p>
<p>在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String（），这个函数能将任何类型的值转换为字符串。</p>
<p>要把某个值转换为字符串，可以使用加号操作符把它与一个字符串（“”）加在一起。</p>
<h2 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h2><p>ECMAScript中的对象其实就是一组数据和功能的集合。</p>
<p>在ECMAScript中，object类型是所有它的实例的的基础。换句话说，object类型所具有的任何属性和方法也同样存在于更具体的对象中。</p>
<p>object的每个实例都具有下列属性和方法：</p>
<ul>
<li><p>constructor 保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是 Object() 。</p>
</li>
<li><p>hasOwnProperty（propertyName）:用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（ propertyName ）必须以字符串形式指定（例如o.hasOwnProperty(“name”) ）。</p>
</li>
<li><p>isPrototypeOf（object）:用于检查传入的对象是否是传入对象的原型（第 5 章将讨论原型）。</p>
</li>
<li><p>propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用 for-in 语句（本章后面将会讨论）来枚举。与 hasOwnProperty() 方法一样，作为参数的属性名必须以字符串形式指定。</p>
</li>
<li><p>toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应。</p>
</li>
<li><p>toString():返回对象的字符串表示。</p>
</li>
<li><p>valueOf():返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值</p>
</li>
</ul>
<p>相同。</p>
<h1 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h1><p>由于ECMASrcipt是松散类型的，因此需要有一种手段来检测给定变量的数据类型——typeof就是负责提供这方面信息的操作符。</p>
<p>对一个值使用typeof操作符可能返回下列某个字符串：</p>
<p>1.undefined——如果这个值未定义；</p>
<p>2.boolean——如果这个值是布尔值；</p>
<p>3.string——如果这个值是字符串；</p>
<p>4.number——如果这个值是数值；</p>
<p>5.object——如果这个值是对象或者null；</p>
<p>6.function——如果这个值是函数。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>js对象常用的方法和对象的深拷贝</title>
    <url>/2019/11/09/JS/js%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h1><p>Object.keys(obj)     返回对象的key组成的数组</p><p>返回一个所有元素为字符串的数组，其元素来自于从给定的object上面可直接枚举的属性,不会返回原型上的方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	firstname:<span class="string">"John"</span>,</span><br><span class="line">	lastname:<span class="string">"Doe"</span>,</span><br><span class="line">	age:<span class="number">50</span>,</span><br><span class="line">	eyecolor:<span class="string">"blue"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj))</span><br><span class="line">[<span class="string">'firstname'</span>, <span class="string">'lastname'</span>, <span class="string">'age'</span>, <span class="string">'eyecolor'</span>] <span class="comment">//返回key组成的数组</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<h1 id="Object-values-obj"><a href="#Object-values-obj" class="headerlink" title="Object.values(obj)"></a>Object.values(obj)</h1><p>Object.values(obj)  返回对象的value组成的数组</p>
<p>返回一个由value组成的数组，其元素是在对象上找到的可枚举属性值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	firstname:<span class="string">"John"</span>,</span><br><span class="line">	lastname:<span class="string">"Doe"</span>,</span><br><span class="line">	age:<span class="number">50</span>,</span><br><span class="line">	eyecolor:<span class="string">"blue"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj))</span><br><span class="line">[<span class="string">'John'</span>, <span class="string">'Doe'</span>, <span class="number">50</span>, <span class="string">'blue'</span>]   <span class="comment">//返回value组成的数组</span></span><br></pre></td></tr></table></figure>
<p>#Object.assign() </p>
<p>Object.assign() 可以将源对象复制到目标对象中</p>
<p>Object.assign(target, …sources)<br> <code>target</code> 为目标对象，<code>...sources</code> 为源对象(可以为多个对象)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  浅拷贝对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	firstname:<span class="string">"John"</span>,</span><br><span class="line">	lastname:<span class="string">"Doe"</span>,</span><br><span class="line">	age:<span class="number">50</span>,</span><br><span class="line">	love:&#123;</span><br><span class="line">		color: <span class="string">"blue"</span>,</span><br><span class="line">		sport: <span class="string">"football"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(copy) <span class="comment">// 返回浅拷贝的对象，修该obj会同时修改copy的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并多个对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	firstname:<span class="string">"John"</span>,</span><br><span class="line">	lastname:<span class="string">"Doe"</span>,</span><br><span class="line">	age:<span class="number">50</span>,</span><br><span class="line">	love:&#123;</span><br><span class="line">		color: <span class="string">"blue"</span>,</span><br><span class="line">		sport: <span class="string">"football"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">other</span>: <span class="string">"cat"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj3 = &#123; <span class="attr">car</span>: <span class="string">"Benz"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>  compose = <span class="built_in">Object</span>.assign(obj, obj2, obj3); <span class="comment">// 返回三个对象合并组成的对象，如有相同属性则会被后续参数中具有相同属性覆盖。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深拷贝对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	firstname:<span class="string">"John"</span>,</span><br><span class="line">	lastname:<span class="string">"Doe"</span>,</span><br><span class="line">	age:<span class="number">50</span>,</span><br><span class="line">	love:&#123;</span><br><span class="line">		color: <span class="string">"blue"</span>,</span><br><span class="line">		sport: <span class="string">"football"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// 返回深拷贝的对象，修改obj不会影响该对象</span></span><br></pre></td></tr></table></figure>
<h1 id="Object-entries-obj"><a href="#Object-entries-obj" class="headerlink" title="Object.entries(obj)"></a>Object.entries(obj)</h1><p>Object.entries(obj)     返回对象的key和value组成的数组</p>
<p>Object.entries(obj) 方法返回一个对象key和value键值对组成的数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj));</span><br><span class="line"><span class="comment">// [["foo", "bar"], ["baz", 42]]</span></span><br></pre></td></tr></table></figure>
<h1 id="obj-hasOwnProperty"><a href="#obj-hasOwnProperty" class="headerlink" title="obj.hasOwnProperty()"></a>obj.hasOwnProperty()</h1><p>obj.hasOwnProperty() 方法判断对象中属性是否存在</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	firstname:<span class="string">"John"</span>,</span><br><span class="line">	lastname:<span class="string">"Doe"</span>,</span><br><span class="line">	age:<span class="number">50</span>,</span><br><span class="line">	love:&#123;</span><br><span class="line">		color: <span class="string">"blue"</span>,</span><br><span class="line">		sport: <span class="string">"football"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">'love'</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>vuex基本使用和购物车demo</title>
    <url>/2019/11/08/Vue/vuex%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E8%B4%AD%E7%89%A9%E8%BD%A6demo-md/</url>
    <content><![CDATA[<h1 id="什么是Vuex"><a href="#什么是Vuex" class="headerlink" title="什么是Vuex"></a>什么是Vuex</h1><p>在Vue官方网站的解释是： Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。 它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化   。</p><h1 id="使用Vuex常见的关键词"><a href="#使用Vuex常见的关键词" class="headerlink" title="使用Vuex常见的关键词"></a>使用Vuex常见的关键词</h1><ul>
<li>store：仓库容器，  包含应用中大部分的状态 (state)</li>
<li>state：数据状态</li>
<li>mutations：更改 Vuex 的 store 中状态的唯一方法是提交 mutation</li>
<li>commit：  调用 store.commit 方法，触发  mutation</li>
<li>mapState：借助mapState辅助函数获取store中保存的状态，避免当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性时代码冗余</li>
</ul><a id="more"></a>

<h1 id="Vuex基本使用"><a href="#Vuex基本使用" class="headerlink" title="Vuex基本使用"></a>Vuex基本使用</h1><p>前提条件：使用vue-cli创建项目，并安装vuex插件<code>npm install --save-dev  vuex</code> </p>
<h2 id="min-js"><a href="#min-js" class="headerlink" title="min.js"></a>min.js</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span> <span class="comment">// 导入vue-router 库</span></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span> <span class="comment">// 导入vuex</span></span><br><span class="line">Vue.use(Vuex);<span class="comment">//将状态从根组件“注入”到每一个子组件中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//组件引入</span></span><br><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'./components/HelloWorld.vue'</span></span><br><span class="line"><span class="keyword">import</span> Ajax <span class="keyword">from</span> <span class="string">'./components/Ajax.vue'</span></span><br><span class="line"><span class="keyword">import</span> count <span class="keyword">from</span> <span class="string">'./components/count.vue'</span></span><br><span class="line"><span class="keyword">import</span> father <span class="keyword">from</span> <span class="string">'./components/fatherAndChild/father.vue'</span></span><br><span class="line"><span class="keyword">import</span> vuexBase <span class="keyword">from</span> <span class="string">'./components/vuexDemo/baseVuexCount.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    <span class="comment">//利用重定向设置默认路由</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">redirect</span>: <span class="string">'/HelloWorld'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/HelloWorld'</span>, <span class="attr">component</span>: HelloWorld &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/Ajax'</span>, <span class="attr">component</span>: Ajax &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/father'</span>, <span class="attr">component</span>: father &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/count'</span>, <span class="attr">component</span>: count &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/vuexBase'</span>, <span class="attr">component</span>: vuexBase &#125;,</span><br><span class="line"></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//vuex状态管理商店</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span>,</span><br><span class="line">        todos: [</span><br><span class="line">            &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'我是真的'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'我是假的'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        <span class="comment">//异步操作</span></span><br><span class="line">        incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                commit(<span class="string">'increment'</span>)</span><br><span class="line">            &#125;, <span class="number">2000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment (state) &#123;</span><br><span class="line">            <span class="comment">// 变更状态</span></span><br><span class="line">            state.count =  state.count + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    store,</span><br><span class="line">    router,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="baseVuexCount-vue"><a href="#baseVuexCount-vue" class="headerlink" title="baseVuexCount.vue"></a>baseVuexCount.vue</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button v-on:click="setCount"&gt;设置count的值&lt;/</span>button&gt;</span><br><span class="line">        &lt;button v-on:click=<span class="string">"request"</span>&gt;异步操作&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;过滤后的数据：&#123;&#123; doneTodosCount &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;child-count&gt;<span class="xml"><span class="tag">&lt;/<span class="name">child-count</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    import childCount from "./</span>childCount<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    export default &#123;</span></span><br><span class="line"><span class="string">        name: "</span>baseVuexCount<span class="string">",</span></span><br><span class="line"><span class="string">        components: &#123;</span></span><br><span class="line"><span class="string">            childCount</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        computed: &#123;</span></span><br><span class="line"><span class="string">            count() &#123;</span></span><br><span class="line"><span class="string">                return this.$store.state.count</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            doneTodosCount() &#123;</span></span><br><span class="line"><span class="string">                return this.$store.getters.doneTodos[0].text</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        methods: &#123;</span></span><br><span class="line"><span class="string">            setCount() &#123;</span></span><br><span class="line"><span class="string">                this.$store.commit('increment');//mutations，显式调用法法来改变数据</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            request() &#123;</span></span><br><span class="line"><span class="string">                this.$store.dispatch('incrementAsync')//actions，模拟发送请求，异步操作</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;style scoped&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="购物车demo-不使用辅助函数"><a href="#购物车demo-不使用辅助函数" class="headerlink" title="购物车demo(不使用辅助函数)"></a>购物车demo(不使用辅助函数)</h1><h2 id="项目结构示例"><a href="#项目结构示例" class="headerlink" title="项目结构示例"></a>项目结构示例</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">├── api</span><br><span class="line">│   └── ... <span class="comment"># 抽取出API请求</span></span><br><span class="line">├── components</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   └── ...</span><br><span class="line">└── store</span><br><span class="line">    ├── index.js          <span class="comment"># 我们组装模块并导出 store 的地方</span></span><br><span class="line">    ├── actions.js        <span class="comment"># 根级别的 action</span></span><br><span class="line">    ├── mutations.js      <span class="comment"># 根级别的 mutation</span></span><br><span class="line">    └── modules</span><br><span class="line">        ├── cart.js       <span class="comment"># 购物车模块</span></span><br><span class="line">        └── products.js   <span class="comment"># 产品模块</span></span><br></pre></td></tr></table></figure>
<h2 id="min-js-1"><a href="#min-js-1" class="headerlink" title="min.js"></a>min.js</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span> <span class="comment">// 导入vue-router 库</span></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/index'</span> <span class="comment">//导入 store 对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//组件引入</span></span><br><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'./components/HelloWorld.vue'</span></span><br><span class="line"><span class="keyword">import</span> Ajax <span class="keyword">from</span> <span class="string">'./components/Ajax.vue'</span></span><br><span class="line"><span class="keyword">import</span> count <span class="keyword">from</span> <span class="string">'./components/count.vue'</span></span><br><span class="line"><span class="keyword">import</span> father <span class="keyword">from</span> <span class="string">'./components/fatherAndChild/father.vue'</span></span><br><span class="line"><span class="keyword">import</span> shop <span class="keyword">from</span> <span class="string">'./components/vuexDemo/shop.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    <span class="comment">//利用重定向设置默认路由</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">redirect</span>: <span class="string">'/HelloWorld'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/HelloWorld'</span>, <span class="attr">component</span>: HelloWorld &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/Ajax'</span>, <span class="attr">component</span>: Ajax &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/father'</span>, <span class="attr">component</span>: father &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/count'</span>, <span class="attr">component</span>: count &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/shop'</span>, <span class="attr">component</span>: shop &#125;,</span><br><span class="line"></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    store,</span><br><span class="line">    router,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> shop <span class="keyword">from</span> <span class="string">'./modules/shop'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules: &#123;</span><br><span class="line">       shop</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>
<h2 id="shop-js"><a href="#shop-js" class="headerlink" title="shop.js"></a>shop.js</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据存储</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shop = &#123;</span><br><span class="line">    namespaced: <span class="literal">true</span>,<span class="comment">//注意 模块化管理数据请不要忘了命名空间的开启</span></span><br><span class="line">    state: &#123;</span><br><span class="line">        articles: [</span><br><span class="line">            &#123;</span><br><span class="line">                id: <span class="number">1</span>,</span><br><span class="line">                name: <span class="string">"可乐"</span>,</span><br><span class="line">                price: <span class="number">3</span>,</span><br><span class="line">                count: <span class="number">1</span>,</span><br><span class="line">                status: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                id: <span class="number">2</span>,</span><br><span class="line">                name: <span class="string">"炸鸡"</span>,</span><br><span class="line">                price: <span class="number">12</span>,</span><br><span class="line">                count: <span class="number">1</span>,</span><br><span class="line">                status: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                id: <span class="number">3</span>,</span><br><span class="line">                name: <span class="string">"汉堡"</span>,</span><br><span class="line">                price: <span class="number">6</span>,</span><br><span class="line">                count: <span class="number">1</span>,</span><br><span class="line">                status: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        totalPrice: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        addCount: <span class="function"><span class="keyword">function</span> (<span class="params">state, id</span>) </span>&#123;</span><br><span class="line">            state.articles[id - <span class="number">1</span>].count++;</span><br><span class="line">            <span class="keyword">this</span>.commit(<span class="string">"shop/setTotalPrice"</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        decreaseCount: <span class="function"><span class="keyword">function</span> (<span class="params">state, id</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (state.articles[id - <span class="number">1</span>].count === <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"商品数量已经无法减少"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state.articles[id - <span class="number">1</span>].count--</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.commit(<span class="string">"shop/setTotalPrice"</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        setTotalPrice: <span class="function"><span class="keyword">function</span> (<span class="params">state</span>) </span>&#123;</span><br><span class="line">            state.totalPrice = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.getters[<span class="string">"shop/getShopList"</span>].length; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> price = <span class="keyword">this</span>.getters[<span class="string">"shop/getShopList"</span>][i].count * <span class="keyword">this</span>.getters[<span class="string">"shop/getShopList"</span>][i].price;</span><br><span class="line">                state.totalPrice = state.totalPrice + price</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        incrementAsync: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"异步操作"</span>)</span><br><span class="line">            &#125;, <span class="number">2000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        getShopList: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> state.articles.filter(<span class="function"><span class="params">article</span> =&gt;</span> article.status)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> shop;</span><br></pre></td></tr></table></figure>
<h2 id="shop-vue"><a href="#shop-vue" class="headerlink" title="shop.vue"></a>shop.vue</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in articles"</span> <span class="attr">:key</span>=<span class="string">'item.id'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>商品名：&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>价格：&#123;&#123;item.price&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> &gt;</span>数量：&#123;&#123;item.count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add(item.id)"</span> &gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"decrease(item.id)"</span>&gt;</span>减少<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>总价：&#123;&#123;totalPrice&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">        name: <span class="string">"shop"</span>,</span></span><br><span class="line"><span class="undefined">        computed: &#123;</span></span><br><span class="line"><span class="undefined">            totalPrice() &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.shop.totalPrice</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            articles()&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters[<span class="string">"shop/getShopList"</span>]<span class="comment">//很奇怪，过滤器的key中间有斜杠，不是像state那样通过.shop访问</span></span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            demo()&#123;</span></span><br><span class="line"><span class="javascript">               <span class="keyword">return</span> <span class="keyword">this</span>.$store.commit</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        data ()&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        mounted()&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.incrementAsync();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.setTotalPrice();</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        methods:&#123;</span></span><br><span class="line"><span class="undefined">            add(id)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(id);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.$store.commit(<span class="string">'shop/addCount'</span>,id)</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            decrease(id)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.$store.commit(<span class="string">'shop/decreaseCount'</span>,id)</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            setTotalPrice()&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.$store.commit(<span class="string">'shop/setTotalPrice'</span>)</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            incrementAsync()&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.$store.dispatch(<span class="string">'shop/incrementAsync'</span>)<span class="comment">//actions，模拟发送请求，异步操作</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="购物车demo-使用辅助函数"><a href="#购物车demo-使用辅助函数" class="headerlink" title="购物车demo(使用辅助函数)"></a>购物车demo(使用辅助函数)</h1><p> <strong>使用辅助函数只需修改shop.vue</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in getShopList"</span> <span class="attr">:key</span>=<span class="string">'item.id'</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>商品名：&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>价格：&#123;&#123;item.price&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> &gt;</span>数量：&#123;&#123;item.count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"add(item.id)"</span> &gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"decrease(item.id)"</span>&gt;</span>减少<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>总价：&#123;&#123;totalPrice&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;getShopList&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> &#123; mapGetters, mapMutations,mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">        name: <span class="string">"shop"</span>,</span></span><br><span class="line"><span class="undefined">        computed: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//第一个参数为模块的名字，数组内为方法的名字</span></span></span><br><span class="line"><span class="javascript">            ...mapGetters(<span class="string">'shop'</span>,[<span class="string">'getShopList'</span>]),</span></span><br><span class="line"><span class="undefined">            totalPrice() &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.shop.totalPrice</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        data ()&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        mounted()&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.incrementAsync();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.setTotalPrice();</span></span><br><span class="line"><span class="undefined">        &#125;,</span></span><br><span class="line"><span class="undefined">        methods:&#123;</span></span><br><span class="line"><span class="javascript">            ...mapMutations(<span class="string">'shop'</span>,[<span class="string">'addCount'</span>,<span class="string">'decreaseCount'</span>,<span class="string">'setTotalPrice'</span>]),</span></span><br><span class="line"><span class="javascript">            ...mapActions(<span class="string">'shop'</span>,[<span class="string">'incrementAsync'</span>]),</span></span><br><span class="line"><span class="undefined">            add(id)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.addCount(id);</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            decrease(id)&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.decreaseCount(id);</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">vuex官方文档</a></p>
<p><a href="https://juejin.im/post/5c997e59f265da60f6731774" target="_blank" rel="noopener">如何更好的使用module vuex？</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>vue中js数据改变视图层数据未更新</title>
    <url>/2019/11/07/Vue/vue%E4%B8%ADjs%E6%95%B0%E6%8D%AE%E6%94%B9%E5%8F%98%E8%A7%86%E5%9B%BE%E5%B1%82%E6%95%B0%E6%8D%AE%E6%9C%AA%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>vue中js数据改变视图层数据未更新,点击改变欢迎语按钮，控制台显示hi已经变化，但是视图层中的hi没有变化。</p><p>father.vue</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;!--v-bind来绑定动态数据，静态数据可以不用v-bind指令(:是v-bind的简写)--&gt;</span><br><span class="line">        &lt;h1&gt;以下内容为父组件内容&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p &gt;&#123;&#123;hi&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;button v-on:click=<span class="string">"changeHi"</span>&gt;改变欢迎语&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;child-component :message='message' @listenToChild='getChildData'&gt;&lt;/</span>child-component&gt;</span><br><span class="line"></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">'./child.vue'</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        name: <span class="string">"father"</span>,</span><br><span class="line">        data() &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                message: <span class="string">'我是父组件的数据'</span>,</span><br><span class="line">                hi:<span class="string">"你好，我来自父组件"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            <span class="string">'child-component'</span>: child</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted()&#123;</span><br><span class="line">            <span class="comment">// this.changeHi();</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            getChildData (val) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.hi);</span><br><span class="line">                <span class="keyword">this</span>.hi = val;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.hi);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`子组件传递过来的数据: <span class="subst">$&#123;val&#125;</span>`</span>); <span class="comment">// hello</span></span><br><span class="line">            &#125;,</span><br><span class="line">            changeHi()&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.hi);</span><br><span class="line">                <span class="keyword">this</span>.hi = <span class="string">"你好，我来自父组件，但我改变了"</span>;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.hi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<p>child.vue</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div &gt;</span><br><span class="line">        &lt;h1&gt;以下内容为子组件内容&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt; &#123;&#123; message &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;button v-on:click=<span class="string">"sendData"</span>&gt;发送数据至父组件&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">       &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    export default &#123;</span></span><br><span class="line"><span class="regexp">        name: "child",</span></span><br><span class="line"><span class="regexp">        props: &#123;</span></span><br><span class="line"><span class="regexp">            message: [String, Number]</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">        created () &#123;</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ 在需要的传递数据的时候调用sendData方法，这里模拟调用</span></span><br><span class="line"><span class="regexp">            /</span><span class="regexp">/ this.sendData();</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">        methods: &#123;</span></span><br><span class="line"><span class="regexp">            sendData () &#123;</span></span><br><span class="line"><span class="regexp">                this.$emit('listenToChild', '你好！我来自子组件');</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="问题解决过程"><a href="#问题解决过程" class="headerlink" title="问题解决过程"></a>问题解决过程</h1><p>step1 使用搜索引擎搜索“vue中js数据改变视图层数据未更新”，得到的结果均为改变对象或者数组中的值视图未更新，与我的问题无关。</p>
<p>step2 查看vue官方文档关于数据绑定的内容。</p>
<p>step3 只保留问题相关代码，写一个demo</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>vue生命周期学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.4.2/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"edit me"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="undefined">        data: &#123;</span></span><br><span class="line"><span class="javascript">            message: <span class="string">'Hello Vue!'</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果，h1标签和p标签中的数据均无法做到与input中的数据同步改变，不可思议啊！</p>
<p>step4 页面加载的时候，我发现我写的hello world 被翻译成了你好世界，然后就不再变化</p>
<p>所以我猜测是不是自动翻译的插件影响了视图的数据变化。</p>
<h1 id="问题出现原因"><a href="#问题出现原因" class="headerlink" title="问题出现原因"></a>问题出现原因</h1><p>谷歌浏览器的自动翻译，影响了视图的数据更新</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>关闭谷歌浏览器的自动翻译功能</p>
<h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><p>关于解决bug的一般流程的第七步，我觉得可以加上<strong>更换浏览器，更换电脑进行测试</strong></p>
<ol>
<li>确认Bug是否在本地可以重现。</li>
<li>确认Bug在哪一段代码中。</li>
<li>去除掉所有无关代码，只去调试和Bug相关的代码。</li>
<li>和之前正常运行的版本对比，尝试恢复到之前可以正常运行的代码。</li>
<li>重新写一个小Demo，确认是否可以正常运行，可以的话，移动代码到原有的代码中。</li>
<li>如果本地无法重现，打日志，观察线上行为。</li>
<li>重启服务，重启IDE，重启笔记本，重启服务器。</li>
<li>跟产品经理说这个Bug解决不了，花费的代价很大，不值得。</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
        <category>遇到的问题</category>
      </categories>
  </entry>
  <entry>
    <title>vue的生命周期简介</title>
    <url>/2019/11/07/Vue/vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。 </p><p>使用vue框架，需要在合适的时机做合适的事情，了解了vue对象的生命周期和钩子函数，才能知道，哪些事情应该咋哪个函数里做。</p><a id="more"></a>

<p>Vue生命周期经历哪些阶段：</p>
<ol>
<li>总体来说：初始化、运行中、销毁</li>
<li>详细来说：开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程</li>
</ol>
<h1 id="vue的生命周期与生命周期钩子"><a href="#vue的生命周期与生命周期钩子" class="headerlink" title="vue的生命周期与生命周期钩子"></a>vue的生命周期与生命周期钩子</h1><h2 id="实例化vue-组件-对象"><a href="#实例化vue-组件-对象" class="headerlink" title="实例化vue(组件)对象"></a>实例化vue(组件)对象</h2><p><code>new Vue()</code></p>
<h2 id="初始化事件和生命周期"><a href="#初始化事件和生命周期" class="headerlink" title="初始化事件和生命周期"></a>初始化事件和生命周期</h2><p><code>init events</code>和 <code>init cycle</code></p>
<h2 id="beforeCreate函数"><a href="#beforeCreate函数" class="headerlink" title="beforeCreate函数"></a>beforeCreate函数</h2><p>​       在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p>
<p>​       即此时vue（组件）对象被创建了，但是vue对象的属性还没有绑定，如data属性，computed属性还没有绑定，即没有值。</p>
<p>​       此时还没有数据和真实DOM。</p>
<p>即：属性还没有赋值，也没有动态创建template属性对应的HTML元素（二阶段的createUI函数还没有执行）</p>
<h2 id="挂载数据（属性赋值）"><a href="#挂载数据（属性赋值）" class="headerlink" title="挂载数据（属性赋值）"></a>挂载数据（属性赋值）</h2><p>包括 属性和computed的运算，</p>
<p>在这个生命周期之间，进行<strong>初始化事件，进行数据的观测</strong>，可以看到在<strong>created</strong>的时候数据已经和<strong>data属性进行绑定</strong>（放在data中的属性当值发生改变的同时，视图也会改变）。 注意看下：此时还是没有el选项 </p>
<h2 id="Created函数"><a href="#Created函数" class="headerlink" title="Created函数"></a>Created函数</h2><p>vue对象的属性有值了，但是DOM还没有生成，$el属性还不存在。</p>
<p>此时有数据了，但是还没有真实的DOM</p>
<p>即：data，computed都执行了。属性已经赋值，但没有动态创建template属性对应的HTML元素，所以，此时如果更改数据不会触发updated函数</p>
<p>如果：数据的初始值就来自于后端，可以发送ajax，或者fetch请求获取数据，但是，此时不会触发updated函数</p>
<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><ol>
<li>检查是否有el属性</li>
</ol>
<p>检查vue配置，即<code>new Vue{}</code>里面的el项是否存在，有就继续检查template项。没有则等到手动绑定调用<code>vm.$mount()</code></p>
<p>完成了全局变量$el的绑定。</p>
<ol start="2">
<li>检查是否有template属性</li>
</ol>
<p>检查配置中的template项，如果没有template进行填充被绑定区域，则被绑定区域的el对象的outerHTML（即整个#app DOM对象，包括<code>&lt;div id=”app” &gt;和&lt;/div&gt;标签）</code>都作为被填充对象替换掉填充区域</p>
<p>即：如果vue对象中有 template属性，那么，template后面的HTML会替换$el对应的内容。如果有render属性，那么render就会替换template。</p>
<p><strong>即：优先关系时： render  &gt;  template &gt; el</strong></p>
<h2 id="beforeMount函数"><a href="#beforeMount函数" class="headerlink" title="beforeMount函数"></a>beforeMount函数</h2><p>模板编译(template)、数据挂载(把数据显示在模板里)之前执行的钩子函数</p>
<p>此时 this.$el有值，但是数据还没有挂载到页面上。即此时页面中的里的绑定的变量<code>&lt;h1&gt;&lt;/h1&gt;</code>还没有被数据替换</p>
<h2 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h2><p>用vue对象的数据（属性）替换模板中的内容</p>
<p>可以看到此时是给vue实例对象添加<strong>$el成员</strong>，并且替换掉挂在的DOM元素。因为在之前console中打印的结果可以看到<strong>beforeMount</strong>之前el上还是undefined。 </p>
<h2 id="Monuted函数"><a href="#Monuted函数" class="headerlink" title="Monuted函数"></a>Monuted函数</h2><p>模板编译完成，数据挂载完毕</p>
<p>即：此时已经把数据挂载到了页面上，所以，页面上能够看到正确的数据了。</p>
<p><strong>应用场景：一般来说，我们在此处发送异步请求（ajax，fetch，axios等），获取服务器上的数据，显示在DOM里。</strong></p>
<h2 id="beforeUpdate函数"><a href="#beforeUpdate函数" class="headerlink" title="beforeUpdate函数"></a>beforeUpdate函数</h2><p>组件更新之前执行的函数</p>
<p>数据更新了，但是，vue（组件）对象对应的dom中的内部（innerHTML）没有变，所以叫作组件更新前</p>
<h2 id="befoUpdeated函数"><a href="#befoUpdeated函数" class="headerlink" title="befoUpdeated函数"></a>befoUpdeated函数</h2><p>组件更新之前执行的函数</p>
<h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><p>当vue发现data中的数据发生了改变，会<strong>触发对应组件的重新渲染</strong>，先后调用<strong>beforeUpdate</strong>和<strong>updated</strong>钩子函数。 </p>
<h2 id="updated函数"><a href="#updated函数" class="headerlink" title="updated函数"></a>updated函数</h2><p>组件更新之后执行的函数</p>
<p>vue（组件）对象对应的dom中的内部（innerHTML）改变了，所以，叫作组件更新之后</p>
<h1 id="beforeDestroy函数"><a href="#beforeDestroy函数" class="headerlink" title="beforeDestroy函数"></a>beforeDestroy函数</h1><p>vue（组件）对象销毁之前</p>
<h1 id="destroyed函数"><a href="#destroyed函数" class="headerlink" title="destroyed函数"></a>destroyed函数</h1><p>vue组件销毁后</p>
<h1 id="编码实战"><a href="#编码实战" class="headerlink" title="编码实战"></a>编码实战</h1><p>各位复制在浏览器中运行，打开控制台查看console即可： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">  &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">  &lt;title&gt;vue生命周期学习&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;script src="https:/</span><span class="regexp">/cdn.bootcss.com/</span>vue/<span class="number">2.4</span><span class="number">.2</span>/vue.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">  &lt;div id="</span>app<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">  var vm = new Vue(&#123;</span></span><br><span class="line"><span class="string">    el: '#app',</span></span><br><span class="line"><span class="string">    data: &#123;</span></span><br><span class="line"><span class="string">      message: 'Vue的生命周期'</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    beforeCreate: function() &#123;</span></span><br><span class="line"><span class="string">      console.group('------beforeCreate创建前状态------');</span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">" , "</span>el     : <span class="string">" + this.$el); //undefined</span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>data   : <span class="string">" + this.$data); //undefined </span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>message: <span class="string">" + this.message) </span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    created: function() &#123;</span></span><br><span class="line"><span class="string">      console.group('------created创建完毕状态------');</span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>el     : <span class="string">" + this.$el); //undefined</span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>data   : <span class="string">" + this.$data); //已被初始化 </span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>message: <span class="string">" + this.message); //已被初始化</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    beforeMount: function() &#123;</span></span><br><span class="line"><span class="string">      console.group('------beforeMount挂载前状态------');</span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>el     : <span class="string">" + (this.$el)); //已被初始化</span></span><br><span class="line"><span class="string">      console.log(this.$el);</span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>data   : <span class="string">" + this.$data); //已被初始化  </span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>message: <span class="string">" + this.message); //已被初始化  </span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    mounted: function() &#123;</span></span><br><span class="line"><span class="string">      console.group('------mounted 挂载结束状态------');</span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>el     : <span class="string">" + this.$el); //已被初始化</span></span><br><span class="line"><span class="string">      console.log(this.$el);    </span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>data   : <span class="string">" + this.$data); //已被初始化</span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>message: <span class="string">" + this.message); //已被初始化 </span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    beforeUpdate: function () &#123;</span></span><br><span class="line"><span class="string">      console.group('beforeUpdate 更新前状态===============》');</span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>el     : <span class="string">" + this.$el);</span></span><br><span class="line"><span class="string">      console.log(this.$el);   </span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>data   : <span class="string">" + this.$data); </span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>message: <span class="string">" + this.message); </span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    updated: function () &#123;</span></span><br><span class="line"><span class="string">      console.group('updated 更新完成状态===============》');</span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>el     : <span class="string">" + this.$el);</span></span><br><span class="line"><span class="string">      console.log(this.$el); </span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>data   : <span class="string">" + this.$data); </span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>message: <span class="string">" + this.message); </span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    beforeDestroy: function () &#123;</span></span><br><span class="line"><span class="string">      console.group('beforeDestroy 销毁前状态===============》');</span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>el     : <span class="string">" + this.$el);</span></span><br><span class="line"><span class="string">      console.log(this.$el);    </span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>data   : <span class="string">" + this.$data); </span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>message: <span class="string">" + this.message); </span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    destroyed: function () &#123;</span></span><br><span class="line"><span class="string">      console.group('destroyed 销毁完成状态===============》');</span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>el     : <span class="string">" + this.$el);</span></span><br><span class="line"><span class="string">      console.log(this.$el);  </span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>data   : <span class="string">" + this.$data); </span></span><br><span class="line"><span class="string">      console.log("</span>%c%s<span class="string">", "</span>color:red<span class="string">","</span>message: <span class="string">" + this.message)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="官方生命周期图示"><a href="#官方生命周期图示" class="headerlink" title="官方生命周期图示"></a>官方生命周期图示</h1><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue 实例生命周期"> </p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/jiang7701037/article/details/83118665" target="_blank" rel="noopener">彻底理解vue的钩子函数，vue的生命周期理解，什么是vue的生命周期，钩子函数</a></p>
<p><a href="https://segmentfault.com/a/1190000011381906" target="_blank" rel="noopener">详解vue生命周期</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>如何阻止事件冒泡和默认事件？</title>
    <url>/2019/11/05/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%834/%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a><strong>事件冒泡</strong></h2><p>在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。</p><a id="more"></a>
<h2 id="默认行为"><a href="#默认行为" class="headerlink" title="默认行为"></a><strong>默认行为</strong></h2><p>浏览器的一些默认的行为。例如：点击超链接跳转，点击右键会弹出菜单，滑动滚轮控制滚动条等</p>
<h2 id="事件冒泡有什么作用"><a href="#事件冒泡有什么作用" class="headerlink" title="事件冒泡有什么作用"></a><strong>事件冒泡有什么作用</strong></h2><p>事件冒泡允许多个操作被集中处理（把事件处理器添加到一个父级元素上，避免把事件处理器添加到多个子级元素上），它还可以让你在对象层的不同级别捕获事件。</p>
<h2 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a><strong>阻止事件冒泡</strong></h2><p>DOM中提供stopPropagation()方法，但IE不支持，使用event对象在事件函数中调用就行。<br>IE中提供的是，cancelBubble属性，默认为false，当它设置为true时，就是阻止事件冒泡，也是用event对象在事件函数中调用<br>jQuery中提供了stopPropagation()方法来停止事件冒泡，当需要时，只需用用event对象来调用就行，即event.stopPropagation()</p>
<p>代码写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopBubble</span>(<span class="params">e</span>) </span>&#123;  </span><br><span class="line"> <span class="keyword">if</span>(e &amp;&amp; e.stopPropagation)&#123;  </span><br><span class="line">      e.stopPropagation();  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a><strong>阻止默认行为</strong></h2><p>DOM中提供preventDefault()方法来取消事件默认行为，但是只有当cancelable属性设置为true的事件，才可以使用preventDefault()来取消事件默认行为，使用event对象在事件函数中调用就行<br>IE中提供的是returnValue属性，默认为true，当它设置为false时，就是取消事件默认行为，也是用event对象在事件函数中调用<br>jQuery中提供了preventDefault()方法来阻止元素的默认行为，只需要用event对象来调用就好，即event.preventDefault()</p>
<p>// 阻止浏览器的默认事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopDefault</span>(<span class="params">e</span>)</span>&#123;  </span><br><span class="line">   <span class="keyword">if</span>(e &amp;&amp; e.preventDefault) &#123;  </span><br><span class="line">      e.preventDefault();  </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">      <span class="built_in">window</span>.event.returnValue = <span class="literal">false</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何理解JS作用域与作用域链？</title>
    <url>/2019/11/05/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%834/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3JS%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%9F/</url>
    <content><![CDATA[<p>执行环境是JavaScript 中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。</p><p>#一. 背景介绍</p><h2 id="执行环境是什么"><a href="#执行环境是什么" class="headerlink" title="执行环境是什么"></a>执行环境是什么</h2><p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。 每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。 我们编写的代码是无法访问这个对象的，但解析器在处理数据时会在后台使用它。</p><a id="more"></a>


<h2 id="全局执行环境"><a href="#全局执行环境" class="headerlink" title="全局执行环境"></a>全局执行环境</h2><p>全局执行环境是最外围的一个执行环境，在Web浏览器中，全局执行环境被认为是window对象， 因此所有全局变量和函数都是作为window对象的属性和方法来创建的。 某个执行环境中的所有代码执行完毕后，该环境就会被销毁，保存在其中的所有变量和函数定义也随之销毁。</p>
<h1 id="二-知识剖析"><a href="#二-知识剖析" class="headerlink" title="二.知识剖析"></a>二.知识剖析</h1><p>如果所在环境是函数，那么就会把这个函数的活动对象作为变量对象(在函数中，变量对象==活动对象)。 </p>
<p><strong>一般而言，函数执行过程，可以分成两步：1.进入执行环境；2.执行代码。</strong></p>
<h2 id="环境栈的定义"><a href="#环境栈的定义" class="headerlink" title="环境栈的定义"></a>环境栈的定义</h2><p>当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。执行之后， 再从环境栈中弹出。</p>
<h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p>JavaScript解释器在浏览器中是单线程的，这意味着浏览器在同一时间内只执行一个事件， 对于其他的事件我们把它们排队在一个称为 执行栈的地方。</p>
<p> 我们已经知道，当浏览器第一次加载你的script，它默认的进了全局执行环境。 如果在你的全局代码中你调用了一个函数，那么顺序流就会进入到你调用的函数当中， 创建一个新的执行环境并且把这个环境添加到执行栈的顶部。</p>
<p> 如果你在当前的函数中调用了其他函数，同样的事会再次发生。 执行流进入内部函数，并且创建一个新的执行环境，把它添加到已经存在的执行栈的顶部。 浏览器始终执行当前在栈顶部的执行环境。一旦函数完成了当前的执行环境，它就会被弹出栈的顶部, 把控制权返回给当前执行环境的下个执行环境。</p>
<h1 id="三-问题与讨论"><a href="#三-问题与讨论" class="headerlink" title="三.问题与讨论"></a>三.问题与讨论</h1><h2 id="什么是作用域链"><a href="#什么是作用域链" class="headerlink" title="什么是作用域链"></a>什么是作用域链</h2><p>作用域链与执行上下文相关，是内部上下文所有变量对象（包括父变量对象）的列表，用于变量查询。 作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。</p>
<ul>
<li>代码在执行环境中执行时，执行环境会为变量对象创建作用域链。</li>
<li>作用域链是由变量对象组成的数据对象链。</li>
<li>作用域链的前端，始终是当前函数执行环境的变量对象。</li>
<li>作用域链的最后端，始终是全局执行环境的变量对象。</li>
</ul>
<h2 id="函数创建的过程"><a href="#函数创建的过程" class="headerlink" title="函数创建的过程"></a>函数创建的过程</h2><ul>
<li>在一个函数被定义的时候, 会将它定义时刻的scope chain链接到这个函数对象的</li>
<li>[[Scopes]]属性，函数可以通过这个属性来访问更高层的作用域。</li>
<li>[[Scopes]]是所有父变量对象的层级链，处于当前函数上下文之上，在函数创建时存于其中。</li>
<li>[[Scopes]]在函数创建时被存储－－静态（不变的），永远永远，直至函数销毁。</li>
<li>[[Scopes]]存储的是定义时刻的作用域链，是函数本身所依赖的变量对象其所在环境的 [[Scopes]]组成的。</li>
</ul>
<h2 id="什么是标识符的解析"><a href="#什么是标识符的解析" class="headerlink" title="什么是标识符的解析"></a>什么是标识符的解析</h2><p>标识符解析是沿着作用域链一级一级向上(外)搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级向后回溯，直至找到标识符为止。</p>
<p>其中内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部变量环境中的任何变量和函数。这些环境之间的练习是线性的，有次序的。每个环境变量都可以向上搜索作用域链，以查询变量和函数名；反之则是不行。</p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>杀人和投票的业务逻辑上有什么区别？</title>
    <url>/2019/11/05/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%834/%E6%9D%80%E4%BA%BA%E5%92%8C%E6%8A%95%E7%A5%A8%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E4%B8%8A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="业务逻辑是什么？"><a href="#业务逻辑是什么？" class="headerlink" title="业务逻辑是什么？"></a>业务逻辑是什么？</h1><p><strong>不同的项目有不同的功能，不同的功能需要不同的实现，实现这些核心功能的代码就叫业务逻辑。</strong></p><p>让你实现一个功能，给你两个数，让你获取它的和，你所写的如何才能获得任意给定的两个数的和，这个程序实现过程称为业务逻辑处理。</p><p>就像家里规矩–“吃饭前必须洗手”“有客人来要起立”-就是业务逻辑的生活化实例。<br>简单来就是在怎么做事（how to do）, 比方说你去餐馆吃饭, 你点了个炒米粉，服务员给你下单，厨房见到单后下锅给你炒，你吃完后付账。这一些列动作都可以说是业务逻辑。</p><a id="more"></a>


<p>业务逻辑就是客户的逻辑。在 N 层架构的系统中，经常会提到这些名词。</p>
<ul>
<li><p>表现层（Presentation layer） </p>
</li>
<li><p>业务逻辑层（Application layer）</p>
</li>
<li><p>数据访问层（Data layer） ，</p>
</li>
</ul>
<p>在一个系统开发过程中，后台做一些处理，如果成功，则跳转到 success_xxx 页面，如果失败，则跳转到fail_xxx 页面，如果系统抛出了异常，则跳转到 5xx 页面，…… 这些属于页面逻辑。</p>
<p>还有一些持久层的逻辑，也就是对数据库的操作。<br>业务逻辑是核心逻辑，只关注用户的业务，比如管理系统和财务系统，需要处理的业务肯定不一样，但是页面的跳转大致相同，对于持久层的操作也差不多。如果你使用了 SSH 框架，那么 hibernate 和 struts 的代码有很大一部分可以复用<br>业务逻辑（BL Action）不关心页面如何跳转，只是简单的返回成功，或是失败，或是异常，struts 框架根据配置文件跳转到相应的页面。<br>业务逻辑也不关心数据如何存储，是存储在文件系统，还是存储在数据库系统。是存储在MySQL，还是NoSQL。也不关系到底用没用缓存。</p>
<h1 id="杀人和投票的业务逻辑上有什么区别"><a href="#杀人和投票的业务逻辑上有什么区别" class="headerlink" title="杀人和投票的业务逻辑上有什么区别"></a>杀人和投票的业务逻辑上有什么区别</h1><h2 id="杀人和投票页面区别之处"><a href="#杀人和投票页面区别之处" class="headerlink" title="杀人和投票页面区别之处"></a>杀人和投票页面区别之处</h2><p>杀人：点击杀手弹出提示框；<br>投票：杀手，平民都可以点击；<br>杀人：确定后传值用于刷新法官页面到步骤1完成的状态<br>投票：确定后传值用于重置有限状态机状态<br>杀人：确定后天数不变，如果游戏结束天数+1且传个值用于隐藏游戏进程当天白天的信息</p>
<p>投票：确定后天数+1，如果胜利天数不变</p>
<h2 id="杀人和投票页面相同之处"><a href="#杀人和投票页面相同之处" class="headerlink" title="杀人和投票页面相同之处"></a>杀人和投票页面相同之处</h2><p>1.根据法官页面传来值改变文本<br>2.点击玩家提取序号，确定后存入死亡玩家数组，存活杀手或平民-1<br>3.不选择玩家不能离开<br>4.死亡玩家变色，且移除点击事件<br>5.胜利判断</p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何实现数组深拷贝和浅拷贝？</title>
    <url>/2019/11/05/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%834/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F/</url>
    <content><![CDATA[<p>在使用JavaScript对数组进行操作的时候，我们经常需要将数组进行备份，事实证明如果只是简单的将它赋予其他变量，那么我们只要更改其中的任何一个，然后其它的也会跟着改变，这就导致了问题的发生。原因是内存中仅保留一份数据。这时候需要制作一份数据的副本。只有复杂类型变量（引用类型）存在深拷贝与浅拷贝的问题，而基本类型没有深拷贝的概念。</p><a id="more"></a>
<h1 id="“堆内存”和“栈内存”"><a href="#“堆内存”和“栈内存”" class="headerlink" title="“堆内存”和“栈内存”"></a><strong>“堆内存”和“栈内存”</strong></h1><p>首先JavaScript中的变量分为基本类型和引用类型。基本类型就是保存在栈内存中的简单数据段，而引用类型指的是那些保存在堆内存中的对象。</p>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>基本类型有Undefined、Null、Boolean、Number 和String。这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。栈内存中存放的只是该对象的访问地址，在堆内存中为这个值分配空间。由于这种值的大小不固定，因此不能把它们保存到栈内存中。但内存地址大小的固定的，因此可以将内存地址保存在栈内存中。这样，当查询引用类型的变量时，先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。</p>
<p>当我们看到一个变量类型是已知的，就分配在栈里面，比如INT,Double等。其他未知的类型，比如自定义的类型，因为系统不知道需要多大，所以程序自己申请，这样就分配在堆里面。</p>
<h1 id="JS数组的浅拷贝"><a href="#JS数组的浅拷贝" class="headerlink" title="JS数组的浅拷贝"></a><strong>JS数组的浅拷贝</strong></h1><p>简单的赋值就是浅拷贝。因为对象和数组在赋值的时候都是引用传递。赋值的时候只是传递一个指针。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b =a ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = &#123;<span class="attr">name</span>:<span class="string">'xiaohong'</span>, <span class="attr">age</span>:<span class="number">15</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = test;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'-------------------'</span>);</span><br><span class="line"></span><br><span class="line">b[<span class="number">0</span>] =<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">c.age = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a,b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br></pre></td></tr></table></figure>
<p>浅拷贝很容易，但是很多时候我们需要原样的把数组或者对象复制一份，在修改值的时候，不改变初始对象的值。这个时候就需要使用深拷贝。</p>
<h1 id="JS数组的深拷贝"><a href="#JS数组的深拷贝" class="headerlink" title="JS数组的深拷贝"></a><strong>JS数组的深拷贝</strong></h1><h2 id="js的slice函数"><a href="#js的slice函数" class="headerlink" title="js的slice函数"></a>js的slice函数</h2><p><strong>slice() 方法可从已有的数组中返回选定的元素。</strong></p>
<p>【语法】arrayObject.slice(start,end)</p>
<p>【参数】arrayObj–必选项：一个Array对象。start–必选项：arrayObj中所指定的部分的开始元素是从零开始计算的下标。end–可选项：arrayObj中所指定的部分的结束元素是从零开始计算的下标。</p>
<p>【说明】</p>
<p>slice 方法返回一个Array对象，其中包含了arrayObj的指定部分。slice方法一直复制到end所指定的元素，但是不包括该元素。如果start为负，将它作为length + start处理，此处length为数组的长度。如果end为负，就将它作为length + end处理，此处length为数组的长度。如果省略end ，那么slice方法将一直复制到 arrayObj 的结尾。如果end出现在start之前，不复制任何元素到新数组中。</p>
<p>实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a.slice(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = a.slice(<span class="number">-3</span>,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = a.slice(<span class="number">-1</span>,<span class="number">-3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b,c,d);</span><br></pre></td></tr></table></figure>
<h2 id="js的concat函数"><a href="#js的concat函数" class="headerlink" title="js的concat函数"></a><strong>js的concat函数</strong></h2><p><strong>concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</strong></p>
<p>【语法】arrayObject.concat(arrayX,arrayX,……,arrayX)</p>
<p>【参数】arrayX–必需：该参数可以是具体的值，也可以是数组对象。可以是任意多个。</p>
<p>【说明】</p>
<p>返回一个新的数组。该数组是通过把所有 arrayX 参数添加到 arrayObject 中生成的。如果要进行 concat()操作的参数是数组，那么添加的是数组中的元素，而不是数组。</p>
<p>实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a.concat(<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">6</span>,<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = a.concat(c);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(d);</span><br></pre></td></tr></table></figure>
<p>\<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## js遍历数组的方法</span><br><span class="line"></span><br><span class="line">js遍历数组的方法</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">var a = [1,2,3];</span><br><span class="line"></span><br><span class="line">var b = [];</span><br><span class="line"></span><br><span class="line">function deepCopy(arry1,arry2) &#123;</span><br><span class="line"></span><br><span class="line">for(i=0;i &lt; arry1.length;i++) &#123;</span><br><span class="line"></span><br><span class="line">arry2[i] = arry1[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deepCopy(a,b);</span><br><span class="line"></span><br><span class="line">a[0] = &quot;A&quot;;</span><br><span class="line"></span><br><span class="line">console.log(a,b);</span><br></pre></td></tr></table></figure></p>
<h1 id="slice-、concat-的局限性"><a href="#slice-、concat-的局限性" class="headerlink" title="slice()、concat()的局限性"></a>slice()、concat()的局限性</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = [1,2,&#123;&quot;name&quot;:&quot;张三&quot;&#125;,&#123;&quot;name&quot;:&quot;李四&quot;&#125;,[4,5]];</span><br><span class="line"></span><br><span class="line">var b = a.slice(0);</span><br><span class="line"></span><br><span class="line">var c = [].concat(a);</span><br><span class="line"></span><br><span class="line">a[2].name=&quot;王五&quot;;</span><br><span class="line"></span><br><span class="line">a = &quot;A&quot;;</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">console.log(b);</span><br><span class="line"></span><br><span class="line">console.log(c);</span><br></pre></td></tr></table></figure>
<p>由上面的例子可以看出，由于数组内部存在对象和数组，当改变对象属性和内部数组的元素后，深拷贝的b和c同样也发生了改变。因此，<strong>slice和concat这两个方法，仅适用于对不包含引用对象的一维数组的深拷贝。</strong></p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>简述JS中的面向对象编程</title>
    <url>/2019/11/05/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%834/%E7%AE%80%E8%BF%B0JS%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>在 JavaScript 中，大多数事物都是对象, 从作为核心功能的字符串和数组，到建立在 JavaScript 之上的浏览器 API。你甚至可以自己创建对象，将相关的函数和变量封装打包成便捷的数据容器。理解这种面向对象 (object-oriented, OO) 的特性对于进一步学习 JavaScript 语言知识是必不可少的。这个模块将帮助你了解“对象”，先详细介绍对象的设计思想和语法，再说明如何创建对象。 </p><a id="more"></a>
<h1 id="js中的对象是什么"><a href="#js中的对象是什么" class="headerlink" title="js中的对象是什么"></a>js中的对象是什么</h1><p>面向对象（Object-Oriented，OO）的语言有一个标志，那就是它们都有类的概念，而通过类可 以创建任意多个具有相同属性和方法的对象。前面提到过，ECMAScript中没有类的概念，因 此它的对象也与基于类的语言中的对象有所不同。 </p>
<p>ECMA-262把对象定义为：<strong>“无序属性的集合，其属性可以包含基本值、对象或者函数。”</strong>严格来讲， 这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射 到一个值。正因为这样（以及其他将要讨论的原因），我们可以把 ECMAScript的对象想象成散列表：无 非就是一组名值对，其中值可以是数据或函数。 每个对象都是基于一个引用类型创建的，这个引用类型可以是第 5章讨论的原生类型，也可以是开 发人员定义的类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"天地生"</span>,</span><br><span class="line">    age: <span class="number">24</span>,</span><br><span class="line">    gender: <span class="string">'男'</span>,</span><br><span class="line">    interests: [<span class="string">'音乐'</span>, <span class="string">'游戏'</span>],</span><br><span class="line">    seeHi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'你好! 我是 '</span> + <span class="keyword">this</span>.name+ <span class="string">'！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//点表示法访问属性，控制台打印“天地生”</span></span><br><span class="line">person.seeHi();<span class="comment">//点表示法访问方法，控制台打印“你好！我是天地生！”</span></span><br><span class="line"><span class="keyword">var</span> ageDifferent = <span class="string">"age"</span></span><br><span class="line"><span class="built_in">console</span>.log(person[ageDifferent])<span class="comment">//括号表示法，控制台打印“24”（可以动态的去设置对象成员的值，还可以动态的去设置成员的名字）</span></span><br></pre></td></tr></table></figure>
<h1 id="什么是面向对象编程"><a href="#什么是面向对象编程" class="headerlink" title="什么是面向对象编程"></a>什么是面向对象编程</h1><p>面向对象编程是一种通用思想，主要概念为： 把一组数据结构和处理它们的方法组成对象（object）， 把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节， 通过继承（inheritance）实现类的特化（specialization）／泛化（generalization）， 通过多态（polymorphism）实现基于对象类型的动态分派（dynamic dispatch）。</p>
<p>最基本的面向思想就是我们想要在我们的程序中使用对象来表示现实世界模型, 并提供一个简单的方式来访问它的功能,否则很难甚至不能实现.</p>
<p>对象可以包含相关的数据和代码,这些代表现实世界模型的一些信息或者功能,或者它特有的一些行为.</p>
<p>对于一个人（person）来说，我们能在他们身上获取到很多信息（他们的住址，身高，鞋码，基因图谱，护照信息，显著的性格特征等等），然而，我们仅仅需要他们的名字，年龄，性别，兴趣 这些信息，然后，我们会基于他们的这些信息写一个简短的介绍关于他们自己，在最后我们还需要教会他们打招呼。以上的方式被称为抽象-为了我们编程的目标而利用事物的一些重要特性去把复杂的事物简单化</p>
<h1 id="为什么要面向对象编程"><a href="#为什么要面向对象编程" class="headerlink" title="为什么要面向对象编程"></a>为什么要面向对象编程</h1><p>在小型项目中或者刚开始学习时 - 因为当不需要对象和继承的时候，仅仅为了使用而使用它们只是在浪费时间而已。但是随着代码量的增大，你就会越来越发现它的必要性。当我们开始创建一系列拥有相似特性的对象时，那么创建一个包含所有共有功能的通用对象，然后在更特殊的对象类型中继承这些特性，将会变得更加方便有用。 </p>
<h1 id="js中如何面向对象编程"><a href="#js中如何面向对象编程" class="headerlink" title="js中如何面向对象编程"></a>js中如何面向对象编程</h1><p><strong>js中通过继承实现面向对象编程。</strong></p>
<p>JavaScript 常被描述为一种基于原型的语言 (prototype-based language)——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p>
<p><img src="https://images2015.cnblogs.com/blog/1010198/201702/1010198-20170222151629288-2040292378.png" alt="img"> </p>
<p>比如当我们调用person1.valueOf方法的时候，先是在person1里查找valueOf()方法，没找到，继续找它的原型，也就是构造函数Person,还是没找到，接着去对象的方法里去找，找到了，然后就成功调用了。 </p>
<h1 id="js中实现继承"><a href="#js中实现继承" class="headerlink" title="js中实现继承"></a>js中实现继承</h1><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>ECMAScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原 型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每 个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型 对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的 原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数 的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实 例与原型的链条。这就是所谓原型链的基本概念。 </p>
<p>实现原型链有一种基本模式，其代码大致如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.species = <span class="string">"动物"</span>;</span><br><span class="line">    <span class="keyword">this</span>.footers = [<span class="string">"一只"</span>, <span class="string">"两只"</span>, <span class="string">"三只"</span>]; </span><br><span class="line">    <span class="keyword">this</span>.seeHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我是"</span> + <span class="keyword">this</span>.name)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"cat"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();<span class="comment">//继承</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Cat构造函数是"</span> + Cat.constructor);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Cat原型对象是"</span> + Cat.prototype);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat();<span class="comment">//创建实例</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"cat1构造函数是"</span> + cat1.constructor);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"cat1原型对象是"</span> + cat1.prototype); <span class="comment">//因为cat1是实例，&gt;cat1原型对象是undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"cat1原型对象是"</span> + cat1.__proto__); <span class="comment">//因为cat1是实例，__proto_指针指向原型对象</span></span><br><span class="line">cat1.footers.push(<span class="string">"四只"</span>); </span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="built_in">console</span>.log(cat1.species);<span class="comment">//&gt;"动物"</span></span><br><span class="line"><span class="built_in">console</span>.log(cat1.footers);<span class="comment">//&gt;["一只", "两只", "三只"，"四只"]</span></span><br><span class="line"><span class="built_in">console</span>.log(cat2.species);<span class="comment">//&gt;"动物"</span></span><br><span class="line"><span class="built_in">console</span>.log(cat2.footers);<span class="comment">//&gt;["一只", "两只", "三只"，"四只"]</span></span><br></pre></td></tr></table></figure>
<h3 id="原型链继承的缺点"><a href="#原型链继承的缺点" class="headerlink" title="原型链继承的缺点"></a>原型链继承的缺点</h3><ol>
<li>原型中包含引用类型值，子类修改该值，会修改引用类型的值。</li>
<li>在创建子类型的实例时，不能向超类型的构造函数中传递参数。</li>
</ol>
<h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数 （constructor stealing）的技术（有时候也叫做伪造对象或经典继承）。这种技术的基本思想相当简单，即 在子类型构造函数的内部调用超类型构造函数。</p>
<p>所谓”<strong>构造函数</strong>“，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.species = <span class="string">"动物"</span>;</span><br><span class="line">    <span class="keyword">this</span>.footers = [<span class="string">"一只"</span>, <span class="string">"两只"</span>, <span class="string">"三只"</span>]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, color</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>);<span class="comment">//继承</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>,<span class="string">"黄色"</span>);</span><br><span class="line">cat1.footers.push(<span class="string">"四只"</span>); </span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">"二毛"</span>,<span class="string">"红色"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cat1.name);<span class="comment">//&gt;大毛</span></span><br><span class="line"><span class="built_in">console</span>.log(cat1.species);<span class="comment">//&gt;动物</span></span><br><span class="line"><span class="built_in">console</span>.log(cat1.footers);<span class="comment">// &gt;["一只", "两只", "三只"，"四只"]</span></span><br><span class="line"><span class="built_in">console</span>.log(cat2.name);<span class="comment">//&gt;二毛</span></span><br><span class="line"><span class="built_in">console</span>.log(cat2.species);<span class="comment">//&gt;动物</span></span><br><span class="line"><span class="built_in">console</span>.log(cat2.footers);<span class="comment">// &gt;["一只", "两只", "三只"]</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h3><p>如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定 义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结 果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的.</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的 技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方 法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数 复用，又能够保证每个实例都有它自己的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.species = <span class="string">"动物"</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.footers = [<span class="string">"一只"</span>, <span class="string">"两只"</span>, <span class="string">"三只"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.sayName =<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我的名字是"</span>+ <span class="keyword">this</span>.name)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>, name);<span class="comment">//继承属性</span></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal();<span class="comment">//第一行</span></span><br><span class="line">Cat.prototype.constructor = Cat;<span class="comment">//第二行</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*第一行相当于完全删除了prototype 对象原先的值，然后赋予一个新值。</span></span><br><span class="line"><span class="comment">*任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有"Cat.prototype = new Animal();"这一行，Cat.prototype.constructor是指向Cat的；</span></span><br><span class="line"><span class="comment">* 加了这一行以后，Cat.prototype.constructor指向Animal。更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。</span></span><br><span class="line"><span class="comment">* 因此，在运行"Cat.prototype = new Animal();"这一行之后，cat1.constructor也指向Animal！</span></span><br><span class="line"><span class="comment">*这显然会导致继承链的紊乱（cat1明明是用构造函数Cat生成的），因此我们必须手动纠正，将Cat.prototype对象的constructor值改为Cat。这就是第二行的意思。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Cat.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我的年龄是"</span>+ <span class="keyword">this</span>.age)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">"大毛"</span>,<span class="number">2</span>);</span><br><span class="line">cat1.footers.push(<span class="string">"四只"</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">"二毛"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cat1.name);<span class="comment">//&gt;大毛</span></span><br><span class="line"><span class="built_in">console</span>.log(cat1.sayAge());<span class="comment">//&gt;我的年龄是2</span></span><br><span class="line"><span class="built_in">console</span>.log(cat1.footers);<span class="comment">// &gt;["一只", "两只", "三只"，"四只"]</span></span><br><span class="line"><span class="built_in">console</span>.log(cat2.name);<span class="comment">//&gt;二毛</span></span><br><span class="line"><span class="built_in">console</span>.log(cat2.sayAge());<span class="comment">//&gt;我的年龄是1</span></span><br><span class="line"><span class="built_in">console</span>.log(cat2.footers);<span class="comment">// &gt;["一只", "两只", "三只"]</span></span><br></pre></td></tr></table></figure>
<p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中常用的继 承模式。而且，instanceof 和 isPrototypeOf()也能够用于识别基于组合继承创建的对象。 </p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>道格拉斯·克罗克福德在 2006年写了一篇文章，题为 Prototypal Inheritance in JavaScript （JavaScript 中的原型式继承）。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的 构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为 了达到这个目的，他给出了如下函数。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的 原型，后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次</p>
<p>浅复制。来看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>: <span class="string">"Nicholas"</span>, <span class="attr">friends</span>: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.friends);   <span class="comment">//&gt;"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure>
<p>克罗克福德主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么 一个对象的话，可以把它传递给 object()函数，然后再根据具体需求对得到的对象加以修改即可。在这 个例子中，可以作为另一个对象基础的是 person 对象，于是我们把它传入到 object()函数中，然后该 函数就会返回一个新对象。这个新对象将 person 作为原型，所以它的原型中就包含一个基本类型值属性 和一个引用类型值属性。这意味着 person.friends 不仅属于 person 所有，而且也会被 anotherPerson 以及 yetAnotherPerson 共享。实际上，这就相当于又创建了 person 对象的两个副本。 </p>
<p>ECMAScript 5通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一 个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下， Object.create()与 object()方法的行为相同。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>: <span class="string">"Nicholas"</span>, <span class="attr">friends</span>: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="built_in">Object</span>.create(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line"></span><br><span class="line">alert(person.friends); <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure>
<p>Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相 同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属 性。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#123;</span><br><span class="line">            value: <span class="string">"Greg"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">alert(anotherPerson.name); <span class="comment">//"Greg"</span></span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>支持 Object.create()方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome。 在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式 继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模 式一样。 </p>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推而广 之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，后再像真地是它做了所有工作一样返回对象。以下代码示范了寄 生式继承模式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = object(original);  <span class="comment">//通过调用函数创建一个新对象     </span></span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;      <span class="comment">//以某种方式来增强这个对象         </span></span><br><span class="line">        alert(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;         <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，createAnother()函数接收了一个参数，也就是将要作为新对象基础的对象。然 后，把这个对象（original）传递给 object()函数，将返回的结果赋值给 clone。再为 clone 对象 添加一个新方法 sayHi()，后返回 clone 对象。可以像下面这样来使用 createAnother()函数： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); <span class="comment">//"hi"</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的代码基于 person 返回了一个新对象——anotherPerson。新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi()方法。 在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示 范继承模式时使用的 object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。 </p>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背 后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型 原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型 的原型。寄生组合式继承的基本模式如下所示。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype);     <span class="comment">//创建对象     </span></span><br><span class="line">    prototype.constructor = subType;              <span class="comment">//增强对象     </span></span><br><span class="line">    subType.prototype = prototype;               <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例中的 inheritPrototype()函数实现了寄生组合式继承的简单形式。这个函数接收两 个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二 步是为创建的副本添加 constructor 属性，从而弥补因重写原型而失去的默认的 constructor 属性。 后一步，将新创建的对象（即副本）赋值给子类型的原型。这样，我们就可以用调用 inherit- Prototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了，例如： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子的高效率体现在它只调用了一次 SuperType 构造函数，并且因此避免了在 SubType. prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型理想的继承范式。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/mingtan/p/6429332.html" target="_blank" rel="noopener">Javascript 原型链之原型对象、实例和构造函数三者之间的关系</a> </p>
<p><a href="https://www.cnblogs.com/mingtan/p/6429332.html" target="_blank" rel="noopener">编程思想：面向对象和面向过程</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">Javascript面向对象编程（二）：构造函数的继承</a></p>
<p>《JavaScript高级编程设计》 第三版</p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>let 和 const 命令</title>
    <url>/2019/11/05/JS/ES6/let-%E5%92%8C-const-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><a id="more"></a>

<p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p>
<p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">// ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外引用就会报错。</p>
<p>下面的代码如果使用<code>var</code>，最后输出的是<code>10</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>i</code>是<code>var</code>命令声明的，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是 10。</p>
<p>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是 6。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是<code>6</code>。你可能会问，如果每一轮循环的变量<code>i</code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量<code>i</code>时，就在上一轮循环的基础上进行计算。</p>
<p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure>
<p>上面代码正确运行，输出了 3 次<code>abc</code>。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域。</p>
<h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p><code>var</code>命令会发生“变量提升”现象，即变量可以在声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p>
<p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p>
<p>ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"> </span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。</p>
<p>“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>x</code>使用<code>let</code>命令声明，所以在声明之前，都属于<code>x</code>的“死区”，只要用到该变量就会报错。因此，<code>typeof</code>运行时就会抛出一个<code>ReferenceError</code>。</p>
<p>作为比较，如果一个变量根本没有被声明，使用<code>typeof</code>反而不会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclared_variable <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>undeclared_variable</code>是一个不存在的变量名，结果返回“undefined”。所以，在没有<code>let</code>之前，<code>typeof</code>运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p>
<p>有些“死区”比较隐蔽，不太容易发现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bar(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，调用<code>bar</code>函数之所以报错（某些实现可能不报错），是因为参数<code>x</code>默认值等于另一个参数<code>y</code>，而此时<code>y</code>还没有声明，属于“死区”。如果<code>y</code>的默认值是<code>x</code>，就不会报错，因为此时<code>x</code>已经声明了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = <span class="number">2</span>, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure>
<p>另外，下面的代码也会报错，与<code>var</code>的行为不同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> x = x;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> x = x;</span><br><span class="line"><span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码报错，也是因为暂时性死区。使用<code>let</code>声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量<code>x</code>的声明语句还没有执行完成前，就去取<code>x</code>的值，导致报错”x 未定义“。</p>
<p>ES6 规定暂时性死区和<code>let</code>、<code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p>
<p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，不能在函数内部重新声明参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arg;</span><br><span class="line">&#125;</span><br><span class="line">func() <span class="comment">// 报错</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">func() <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><h3 id="为什么需要块级作用域？"><a href="#为什么需要块级作用域？" class="headerlink" title="为什么需要块级作用域？"></a>为什么需要块级作用域？</h3><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>
<p>第一种场景，内层变量可能会覆盖外层变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">'hello world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">f(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是，函数<code>f</code>执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量。</p>
<p>第二种场景，用来计数的循环变量泄露为全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<h3 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h3><p><code>let</code>实际上为 JavaScript 新增了块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用<code>var</code>定义变量<code>n</code>，最后输出的值才是 10。</p>
<p>ES6 允许块级作用域的任意嵌套。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(insane); <span class="comment">// 报错</span></span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。</p>
<p>内层作用域可以定义外层作用域的同名变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  <span class="keyword">let</span> insane = <span class="string">'Hello World'</span>;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</p>
<p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两种函数声明，根据 ES5 的规定都是非法的。</p>
<p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p>
<p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"> </span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>上面代码在 ES5 中运行，会得到“I am inside!”，因为在<code>if</code>内声明的函数<code>f</code>会被提升到函数头部，实际运行的代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"> </span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于<code>let</code>，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"> </span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面的代码在 ES6 浏览器中，都会报错。</p>
<p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics" target="_blank" rel="noopener">附录 B</a>里面规定，浏览器的实现可以不遵守上面的规定，有自己的<a href="http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6" target="_blank" rel="noopener">行为方式</a>。</p>
<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<p>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作<code>let</code>处理。</p>
<p>根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于<code>var</code>声明的变量。上面的例子实际运行的代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>
<p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 块级作用域内部的函数声明语句，建议不要使用</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 块级作用域内部，优先使用函数表达式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种写法，报错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第二种写法，不报错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，第一种写法没有大括号，所以不存在块级作用域，而<code>let</code>只能出现在当前作用域的顶层，所以报错。第二种写法有大括号，所以块级作用域成立。</p>
<p>函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</span><br><span class="line">PI <span class="comment">// 3.1415</span></span><br><span class="line"> </span><br><span class="line">PI = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>
<p>上面代码表明改变常量的值会报错。</p>
<p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo;</span><br><span class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，对于<code>const</code>来说，只声明不赋值，就会报错。</p>
<p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> MAX = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">MAX <span class="comment">// Uncaught ReferenceError: MAX is not defined</span></span><br></pre></td></tr></table></figure>
<p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(MAX); <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">const</span> MAX = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码在常量<code>MAX</code>声明之前就调用，结果报错。</p>
<p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 以下两行都会报错</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">"Goodbye!"</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line">foo.prop <span class="comment">// 123</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: "foo" is read-only</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); <span class="comment">// 可执行</span></span><br><span class="line">a.length = <span class="number">0</span>;    <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">'Dave'</span>];    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>，就会报错。</p>
<p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p>
<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h3><p>ES5 只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6 除了添加<code>let</code>和<code>const</code>命令，后面章节还会提到，另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，ES6 一共有 6 种声明变量的方法。</p>
<h2 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h2><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在 Node 指的是<code>global</code>对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p>
<p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p>
<p>ES6 为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，全局变量<code>a</code>由<code>var</code>命令声明，所以它是顶层对象的属性；全局变量<code>b</code>由<code>let</code>命令声明，所以它不是顶层对象的属性，返回<code>undefined</code>。</p>
<h2 id="globalThis-对象"><a href="#globalThis-对象" class="headerlink" title="globalThis 对象"></a>globalThis 对象</h2><p>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。</p>
<ul>
<li>浏览器里面，顶层对象是<code>window</code>，但 Node 和 Web Worker 没有<code>window</code>。</li>
<li>浏览器和 Web Worker 里面，<code>self</code>也指向顶层对象，但是 Node 没有<code>self</code>。</li>
<li>Node 里面，顶层对象是<code>global</code>，但其他环境都不支持。</li>
</ul>
<p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用<code>this</code>变量，但是有局限性。</p>
<ul>
<li>全局环境中，<code>this</code>会返回顶层对象。但是，Node 模块和 ES6 模块中，<code>this</code>返回的是当前模块。</li>
<li>函数里面的<code>this</code>，如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这时<code>this</code>会返回<code>undefined</code>。</li>
<li>不管是严格模式，还是普通模式，<code>new Function(&#39;return this&#39;)()</code>，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么<code>eval</code>、<code>new Function</code>这些方法都可能无法使用。</li>
</ul>
<p>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span></span><br><span class="line">   ? <span class="built_in">window</span></span><br><span class="line">   : (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">require</span> === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> global === <span class="string">'object'</span>)</span><br><span class="line">     ? global</span><br><span class="line">     : <span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global; &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在有一个<a href="https://github.com/tc39/proposal-global" target="_blank" rel="noopener">提案</a>，在语言标准的层面，引入<code>globalThis</code>作为顶层对象。也就是说，任何环境下，<code>globalThis</code>都是存在的，都可以从它拿到顶层对象，指向全局环境下的<code>this</code>。</p>
<p>垫片库<a href="https://github.com/ungap/global-this" target="_blank" rel="noopener"><code>global-this</code></a>模拟了这个提案，可以在所有环境拿到<code>globalThis</code>。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript 6 简介</title>
    <url>/2019/11/05/JS/ECMAScript-6-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="ECMAScript-6-简介"><a href="#ECMAScript-6-简介" class="headerlink" title="ECMAScript 6 简介"></a>ECMAScript 6 简介</h1><ol>
<li><a href="#docs/intro#ECMAScript 和 JavaScript 的关系">ECMAScript 和 JavaScript 的关系</a></li>
<li><a href="#docs/intro#ES6 与 ECMAScript 2015 的关系">ES6 与 ECMAScript 2015 的关系</a></li>
<li><a href="#docs/intro#语法提案的批准流程">语法提案的批准流程</a></li>
<li><a href="#docs/intro#ECMAScript 的历史">ECMAScript 的历史</a></li>
<li><a href="#docs/intro#部署进度">部署进度</a></li>
<li><a href="#docs/intro#Babel 转码器">Babel 转码器</a></li>
<li><a href="#docs/intro#Traceur 转码器">Traceur 转码器</a></li>
</ol><p>《ES6 实战教程》 深入学习一线大厂必备 ES6 技能。VIP 教程限时免费领取。 ⇐ 立即查看</p><a id="more"></a>

<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
<h2 id="ECMAScript-和-JavaScript-的关系"><a href="#ECMAScript-和-JavaScript-的关系" class="headerlink" title="ECMAScript 和 JavaScript 的关系"></a>ECMAScript 和 JavaScript 的关系</h2><p>一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？</p>
<p>要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。</p>
<p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p>
<p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。</p>
<h2 id="ES6-与-ECMAScript-2015-的关系"><a href="#ES6-与-ECMAScript-2015-的关系" class="headerlink" title="ES6 与 ECMAScript 2015 的关系"></a>ES6 与 ECMAScript 2015 的关系</h2><p>ECMAScript 2015（简称 ES2015）这个词，也是经常可以看到的。它与 ES6 是什么关系呢？</p>
<p>2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。</p>
<p>但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。</p>
<p>但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。</p>
<p>标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。</p>
<p>ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的<code>includes</code>方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。</p>
<p>因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。</p>
<h2 id="语法提案的批准流程"><a href="#语法提案的批准流程" class="headerlink" title="语法提案的批准流程"></a>语法提案的批准流程</h2><p>任何人都可以向标准委员会（又称 TC39 委员会）提案，要求修改语言标准。</p>
<p>一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 TC39 委员会批准。</p>
<ul>
<li>Stage 0 - Strawman（展示阶段）</li>
<li>Stage 1 - Proposal（征求意见阶段）</li>
<li>Stage 2 - Draft（草案阶段）</li>
<li>Stage 3 - Candidate（候选人阶段）</li>
<li>Stage 4 - Finished（定案阶段）</li>
</ul>
<p>一个提案只要能进入 Stage 2，就差不多肯定会包括在以后的正式标准里面。ECMAScript 当前的所有提案，可以在 TC39 的官方网站<a href="https://github.com/tc39/ecma262" target="_blank" rel="noopener">GitHub.com/tc39/ecma262</a>查看。</p>
<p>本书的写作目标之一，是跟踪 ECMAScript 语言的最新进展，介绍 5.1 版本以后所有的新语法。对于那些明确或很有希望，将要列入标准的新语法，都将予以介绍。</p>
<h2 id="ECMAScript-的历史"><a href="#ECMAScript-的历史" class="headerlink" title="ECMAScript 的历史"></a>ECMAScript 的历史</h2><p>ES6 从开始制定到最后发布，整整用了 15 年。</p>
<p>前面提到，ECMAScript 1.0 是 1997 年发布的，接下来的两年，连续发布了 ECMAScript 2.0（1998 年 6 月）和 ECMAScript 3.0（1999 年 12 月）。3.0 版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 JavaScript 语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习 JavaScript，其实就是在学 3.0 版的语法。</p>
<p>2000 年，ECMAScript 4.0 开始酝酿。这个版本最后没有通过，但是它的大部分内容被 ES6 继承了。因此，ES6 制定的起点其实是 2000 年。</p>
<p>为什么 ES4 没有通过呢？因为这个版本太激进了，对 ES3 做了彻底升级，导致标准委员会的一些成员不愿意接受。ECMA 的第 39 号技术专家委员会（Technical Committee 39，简称 TC39）负责制订 ECMAScript 标准，成员包括 Microsoft、Mozilla、Google 等大公司。</p>
<p>2007 年 10 月，ECMAScript 4.0 版草案发布，本来预计次年 8 月发布正式版本。但是，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。</p>
<p>2008 年 7 月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA 开会决定，中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。</p>
<p>2009 年 12 月，ECMAScript 5.0 版正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。TC39 委员会的总体考虑是，ES5 与 ES3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是 ES6，第六版发布以后，就指 ES7。TC39 的判断是，ES5 会在 2013 年的年中成为 JavaScript 开发的主流标准，并在此后五年中一直保持这个位置。</p>
<p>2011 年 6 月，ECMAScript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。</p>
<p>2013 年 3 月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。</p>
<p>2013 年 12 月，ECMAScript 6 草案发布。然后是 12 个月的讨论期，听取各方反馈。</p>
<p>2015 年 6 月，ECMAScript 6 正式通过，成为国际标准。从 2000 年算起，这时已经过去了 15 年。</p>
<h2 id="部署进度"><a href="#部署进度" class="headerlink" title="部署进度"></a>部署进度</h2><p>各大浏览器的最新版本，对 ES6 的支持可以查看<a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">kangax.github.io/compat-table/es6/</a>。随着时间的推移，支持度已经越来越高了，超过 90%的 ES6 语法特性都实现了。</p>
<p>Node 是 JavaScript 的服务器运行环境（runtime）。它对 ES6 的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，但是默认没有打开。使用下面的命令，可以查看 Node 已经实现的 ES6 特性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Linux &amp; Mac</span><br><span class="line">$ node --v8-options | grep harmony</span><br><span class="line"></span><br><span class="line">// Windows</span><br><span class="line">$ node --v8-options | findstr harmony</span><br></pre></td></tr></table></figure>
<p>我写了一个工具 <a href="https://github.com/ruanyf/es-checker" target="_blank" rel="noopener">ES-Checker</a>，用来检查各种运行环境对 ES6 的支持情况。访问<a href="http://ruanyf.github.io/es-checker" target="_blank" rel="noopener">ruanyf.github.io/es-checker</a>，可以看到您的浏览器支持 ES6 的程度。运行下面的命令，可以查看你正在使用的 Node 环境对 ES6 的支持程度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g es-checker</span><br><span class="line">$ es-checker</span><br><span class="line"></span><br><span class="line">=========================================</span><br><span class="line">Passes 24 feature Detections</span><br><span class="line">Your runtime supports 57% of ECMAScript 6</span><br><span class="line">=========================================</span><br></pre></td></tr></table></figure>
<h2 id="Babel-转码器"><a href="#Babel-转码器" class="headerlink" title="Babel 转码器"></a>Babel 转码器</h2><p><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a> 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 转码前</span><br><span class="line">input.map(item =&gt; item + 1);</span><br><span class="line"></span><br><span class="line">// 转码后</span><br><span class="line">input.map(function (item) &#123;</span><br><span class="line">  return item + 1;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。</p>
<p>下面的命令在项目目录中，安装 Babel。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev @babel/core</span><br></pre></td></tr></table></figure>
<h3 id="配置文件-babelrc"><a href="#配置文件-babelrc" class="headerlink" title="配置文件.babelrc"></a>配置文件.babelrc</h3><p>Babel 的配置文件是<code>.babelrc</code>，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。</p>
<p>该文件用来设置转码规则和插件，基本格式如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [],</span><br><span class="line">  &quot;plugins&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>presets</code>字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 最新转码规则</span><br><span class="line">$ npm install --save-dev @babel/preset-env</span><br><span class="line"></span><br><span class="line"># react 转码规则</span><br><span class="line">$ npm install --save-dev @babel/preset-react</span><br></pre></td></tr></table></figure>
<p>然后，将这些规则加入<code>.babelrc</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;@babel/env&quot;,</span><br><span class="line">    &quot;@babel/preset-react&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，以下所有 Babel 工具和模块的使用，都必须先写好<code>.babelrc</code>。</p>
<h3 id="命令行转码"><a href="#命令行转码" class="headerlink" title="命令行转码"></a>命令行转码</h3><p>Babel 提供命令行工具<code>@babel/cli</code>，用于命令行转码。</p>
<p>它的安装命令如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev @babel/cli</span><br></pre></td></tr></table></figure>
<p>基本用法如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 转码结果输出到标准输出</span><br><span class="line">$ npx babel example.js</span><br><span class="line"></span><br><span class="line"># 转码结果写入一个文件</span><br><span class="line"># --out-file 或 -o 参数指定输出文件</span><br><span class="line">$ npx babel example.js --out-file compiled.js</span><br><span class="line"># 或者</span><br><span class="line">$ npx babel example.js -o compiled.js</span><br><span class="line"></span><br><span class="line"># 整个目录转码</span><br><span class="line"># --out-dir 或 -d 参数指定输出目录</span><br><span class="line">$ npx babel src --out-dir lib</span><br><span class="line"># 或者</span><br><span class="line">$ npx babel src -d lib</span><br><span class="line"></span><br><span class="line"># -s 参数生成source map文件</span><br><span class="line">$ npx babel src -d lib -s</span><br></pre></td></tr></table></figure>
<h3 id="babel-node"><a href="#babel-node" class="headerlink" title="babel-node"></a>babel-node</h3><p><code>@babel/node</code>模块的<code>babel-node</code>命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。</p>
<p>首先，安装这个模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev @babel/node</span><br></pre></td></tr></table></figure>
<p>然后，执行<code>babel-node</code>就进入 REPL 环境。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npx babel-node</span><br><span class="line">&gt; (x =&gt; x * 2)(1)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p><code>babel-node</code>命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件<code>es6.js</code>，然后直接运行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># es6.js 的代码</span><br><span class="line"># console.log((x =&gt; x * 2)(1));</span><br><span class="line">$ npx babel-node es6.js</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="babel-register-模块"><a href="#babel-register-模块" class="headerlink" title="@babel/register 模块"></a>@babel/register 模块</h3><p><code>@babel/register</code>模块改写<code>require</code>命令，为它加上一个钩子。此后，每当使用<code>require</code>加载<code>.js</code>、<code>.jsx</code>、<code>.es</code>和<code>.es6</code>后缀名的文件，就会先用 Babel 进行转码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev @babel/register</span><br></pre></td></tr></table></figure>
<p>使用时，必须首先加载<code>@babel/register</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// index.js</span><br><span class="line">require(&apos;@babel/register&apos;);</span><br><span class="line">require(&apos;./es6.js&apos;);</span><br></pre></td></tr></table></figure>
<p>然后，就不需要手动对<code>index.js</code>转码了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node index.js</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>@babel/register</code>只会对<code>require</code>命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。</p>
<h3 id="babel-API"><a href="#babel-API" class="headerlink" title="babel API"></a>babel API</h3><p>如果某些代码需要调用 Babel 的 API 进行转码，就要使用<code>@babel/core</code>模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var babel = require(&apos;@babel/core&apos;);</span><br><span class="line"></span><br><span class="line">// 字符串转码</span><br><span class="line">babel.transform(&apos;code();&apos;, options);</span><br><span class="line">// =&gt; &#123; code, map, ast &#125;</span><br><span class="line"></span><br><span class="line">// 文件转码（异步）</span><br><span class="line">babel.transformFile(&apos;filename.js&apos;, options, function(err, result) &#123;</span><br><span class="line">  result; // =&gt; &#123; code, map, ast &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 文件转码（同步）</span><br><span class="line">babel.transformFileSync(&apos;filename.js&apos;, options);</span><br><span class="line">// =&gt; &#123; code, map, ast &#125;</span><br><span class="line"></span><br><span class="line">// Babel AST转码</span><br><span class="line">babel.transformFromAst(ast, code, options);</span><br><span class="line">// =&gt; &#123; code, map, ast &#125;</span><br></pre></td></tr></table></figure>
<p>配置对象<code>options</code>，可以参看官方文档<a href="http://babeljs.io/docs/usage/options/" target="_blank" rel="noopener">http://babeljs.io/docs/usage/options/</a>。</p>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var es6Code = &apos;let x = n =&gt; n + 1&apos;;</span><br><span class="line">var es5Code = require(&apos;@babel/core&apos;)</span><br><span class="line">  .transform(es6Code, &#123;</span><br><span class="line">    presets: [&apos;@babel/env&apos;]</span><br><span class="line">  &#125;)</span><br><span class="line">  .code;</span><br><span class="line"></span><br><span class="line">console.log(es5Code);</span><br><span class="line">// &apos;&quot;use strict&quot;;\n\nvar x = function x(n) &#123;\n  return n + 1;\n&#125;;&apos;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>transform</code>方法的第一个参数是一个字符串，表示需要被转换的 ES6 代码，第二个参数是转换的配置对象。</p>
<h3 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="@babel/polyfill"></a>@babel/polyfill</h3><p>Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如<code>Iterator</code>、<code>Generator</code>、<code>Set</code>、<code>Map</code>、<code>Proxy</code>、<code>Reflect</code>、<code>Symbol</code>、<code>Promise</code>等全局对象，以及一些定义在全局对象上的方法（比如<code>Object.assign</code>）都不会转码。</p>
<p>举例来说，ES6 在<code>Array</code>对象上新增了<code>Array.from</code>方法。Babel 就不会转码这个方法。如果想让这个方法运行，必须使用<code>babel-polyfill</code>，为当前环境提供一个垫片。</p>
<p>安装命令如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install --save-dev @babel/polyfill</span><br></pre></td></tr></table></figure>
<p>然后，在脚本头部，加入如下一行代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &apos;@babel/polyfill&apos;;</span><br><span class="line">// 或者</span><br><span class="line">require(&apos;@babel/polyfill&apos;);</span><br></pre></td></tr></table></figure>
<p>Babel 默认不转码的 API 非常多，详细清单可以查看<code>babel-plugin-transform-runtime</code>模块的<a href="https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime/src/definitions.js" target="_blank" rel="noopener">definitions.js</a>文件。</p>
<h3 id="浏览器环境"><a href="#浏览器环境" class="headerlink" title="浏览器环境"></a>浏览器环境</h3><p>Babel 也可以用于浏览器环境，使用<a href="https://babeljs.io/docs/en/next/babel-standalone.html" target="_blank" rel="noopener">@babel/standalone</a>模块提供的浏览器版本，将其插入网页。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">// Your ES6 code</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。</p>
<p>Babel 提供一个<a href="https://babeljs.io/repl/" target="_blank" rel="noopener">REPL 在线编译器</a>，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。</p>
<h2 id="Traceur-转码器"><a href="#Traceur-转码器" class="headerlink" title="Traceur 转码器"></a>Traceur 转码器</h2><p>Google 公司的<a href="https://github.com/google/traceur-compiler" target="_blank" rel="noopener">Traceur</a>转码器，也可以将 ES6 代码转为 ES5 代码。</p>
<h3 id="直接插入网页"><a href="#直接插入网页" class="headerlink" title="直接插入网页"></a>直接插入网页</h3><p>Traceur 允许将 ES6 代码直接插入网页。首先，必须在网页头部加载 Traceur 库文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/traceur.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/BrowserSystem.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://google.github.io/traceur-compiler/src/bootstrap.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  import &apos;./Greeter.js&apos;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，一共有 4 个<code>script</code>标签。第一个是加载 Traceur 的库文件，第二个和第三个是将这个库文件用于浏览器环境，第四个则是加载用户脚本，这个脚本里面可以使用 ES6 代码。</p>
<p>注意，第四个<code>script</code>标签的<code>type</code>属性的值是<code>module</code>，而不是<code>text/javascript</code>。这是 Traceur 编译器识别 ES6 代码的标志，编译器会自动将所有<code>type=module</code>的代码编译为 ES5，然后再交给浏览器执行。</p>
<p>除了引用外部 ES6 脚本，也可以直接在网页中放置 ES6 代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">  class Calc &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">      console.log(&apos;Calc constructor&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    add(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var c = new Calc();</span><br><span class="line">  console.log(c.add(4,5));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>正常情况下，上面代码会在控制台打印出<code>9</code>。</p>
<p>如果想对 Traceur 的行为有精确控制，可以采用下面参数配置的写法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // Create the System object</span><br><span class="line">  window.System = new traceur.runtime.BrowserTraceurLoader();</span><br><span class="line">  // Set some experimental options</span><br><span class="line">  var metadata = &#123;</span><br><span class="line">    traceurOptions: &#123;</span><br><span class="line">      experimental: true,</span><br><span class="line">      properTailCalls: true,</span><br><span class="line">      symbols: true,</span><br><span class="line">      arrayComprehension: true,</span><br><span class="line">      asyncFunctions: true,</span><br><span class="line">      asyncGenerators: exponentiation,</span><br><span class="line">      forOn: true,</span><br><span class="line">      generatorComprehension: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  // Load your module</span><br><span class="line">  System.import(&apos;./myModule.js&apos;, &#123;metadata: metadata&#125;).catch(function(ex) &#123;</span><br><span class="line">    console.error(&apos;Import failed&apos;, ex.stack || ex);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码中，首先生成 Traceur 的全局对象<code>window.System</code>，然后<code>System.import</code>方法可以用来加载 ES6。加载的时候，需要传入一个配置对象<code>metadata</code>，该对象的<code>traceurOptions</code>属性可以配置支持 ES6 功能。如果设为<code>experimental: true</code>，就表示除了 ES6 以外，还支持一些实验性的新功能。</p>
<h3 id="在线转换"><a href="#在线转换" class="headerlink" title="在线转换"></a>在线转换</h3><p>Traceur 也提供一个<a href="http://google.github.io/traceur-compiler/demo/repl.html" target="_blank" rel="noopener">在线编译器</a>，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。</p>
<p>上面的例子转为 ES5 代码运行，就是下面这个样子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/traceur.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/BrowserSystem.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://google.github.io/traceur-compiler/src/bootstrap.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$traceurRuntime.ModuleStore.getAnonymousModule(function() &#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">  var Calc = function Calc() &#123;</span><br><span class="line">    console.log(&apos;Calc constructor&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ($traceurRuntime.createClass)(Calc, &#123;add: function(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;&#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  var c = new Calc();</span><br><span class="line">  console.log(c.add(4, 5));</span><br><span class="line">  return &#123;&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="命令行转换"><a href="#命令行转换" class="headerlink" title="命令行转换"></a>命令行转换</h3><p>作为命令行工具使用时，Traceur 是一个 Node 的模块，首先需要用 npm 安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g traceur</span><br></pre></td></tr></table></figure>
<p>安装成功后，就可以在命令行下使用 Traceur 了。</p>
<p>Traceur 直接运行 ES6 脚本文件，会在标准输出显示运行结果，以前面的<code>calc.js</code>为例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ traceur calc.js</span><br><span class="line">Calc constructor</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p>如果要将 ES6 脚本转为 ES5 保存，要采用下面的写法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ traceur --script calc.es6.js --out calc.es5.js</span><br></pre></td></tr></table></figure>
<p>上面代码的<code>--script</code>选项表示指定输入文件，<code>--out</code>选项表示指定输出文件。</p>
<p>为了防止有些特性编译不成功，最好加上<code>--experimental</code>选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ traceur --script calc.es6.js --out calc.es5.js --experimental</span><br></pre></td></tr></table></figure>
<p>命令行下转换生成的文件，就可以直接放到浏览器中运行。</p>
<h3 id="Node-环境的用法"><a href="#Node-环境的用法" class="headerlink" title="Node 环境的用法"></a>Node 环境的用法</h3><p>Traceur 的 Node 用法如下（假定已安装<code>traceur</code>模块）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var traceur = require(&apos;traceur&apos;);</span><br><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">// 将 ES6 脚本转为字符串</span><br><span class="line">var contents = fs.readFileSync(&apos;es6-file.js&apos;).toString();</span><br><span class="line"></span><br><span class="line">var result = traceur.compile(contents, &#123;</span><br><span class="line">  filename: &apos;es6-file.js&apos;,</span><br><span class="line">  sourceMap: true,</span><br><span class="line">  // 其他设置</span><br><span class="line">  modules: &apos;commonjs&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">if (result.error)</span><br><span class="line">  throw result.error;</span><br><span class="line"></span><br><span class="line">// result 对象的 js 属性就是转换后的 ES5 代码</span><br><span class="line">fs.writeFileSync(&apos;out.js&apos;, result.js);</span><br><span class="line">// sourceMap 属性对应 map 文件</span><br><span class="line">fs.writeFileSync(&apos;out.js.map&apos;, result.sourceMap);</span><br></pre></td></tr></table></figure>
<h3 id="留言"><a href="#留言" class="headerlink" title="留言"></a>留言</h3>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>json是什么，如何处理转义？</title>
    <url>/2019/11/03/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%834/json%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E8%BD%AC%E4%B9%89%EF%BC%9F/</url>
    <content><![CDATA[<p>作者：Meetin空白<br>链接：<a href="https://www.jianshu.com/p/5d4549586821" target="_blank" rel="noopener">https://www.jianshu.com/p/5d4549586821</a><br>來源：简书</p><h1 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h1><h2 id="什么是JSON"><a href="#什么是JSON" class="headerlink" title="什么是JSON"></a>什么是JSON</h2><p>JSON (JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。——百度百科</p><a id="more"></a>

<p>数据传输是我们在敲代码时，经常遇到的一个场景,前后端交互。给数据一个统一的格式有利于我们编写和解析数据。</p>
<p>json，是一种数据格式，在与后端的数据交互中有较为广泛的应用。</p>
<h2 id="JSON的诞生"><a href="#JSON的诞生" class="headerlink" title="JSON的诞生"></a>JSON的诞生</h2><p>JSON是 (JavaScript Object Notation, JS 对象标记)，它是一种数据交换格式。在JSON出现之前，大家一直用XML来传递数据。因为XML是一种纯文本格式，所以它适合在网络上交换数据。XML本身不算复杂，但是，加上DTD、XSD、XPath、XSLT等一大堆复杂的规范以后，任何正常的软件开发人员碰到XML都会感觉头大了，最后大家发现，即使你努力钻研几个月，也未必搞得清楚XML的规范。</p>
<p>终于，在2002年的一天，道格拉斯·克罗克福特（DouglasCrockford）同学为了拯救深陷水深火热同时又被某几个巨型软件企业长期愚弄的软件工程师，发明了JSON这种超轻量级的数据交换格式。</p>
<p>由于JSON非常简单，很快就风靡Web世界，并且成为ECMA标准。几乎所有编程语言都有解析JSON的库，而在JavaScript中，我们可以直接使用JSON，因为JavaScript内置了JSON的解析。把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。</p>
<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>我们在调用 jsonp 接口或者调用js文件的时候，由于文件编码不同会导致出现乱码的问题。 如果你的文件出现了非英文字符，如果调用时文件编码不一致，同样会出现乱码情况。</p>
<p>这也就是为什么要数据统一格式的原因。</p>
<p>JSON 是适用于 Ajax 应用程序的一种有效格式，原因是它使 JavaScript 对象和字符串值之间得以快速转换 JSON是一种传递对象的语法</p>
<p>JSON是一个提供了stringify和parse方法的内置对象 </p>
<p>stringify将js对象转化为符合json标准的字符串</p>
<p>parse将符合json标准的字符串转化为js对象</p>
<h1 id="2-知识剖析"><a href="#2-知识剖析" class="headerlink" title="2.知识剖析"></a>2.知识剖析</h1><h2 id="JSON语法"><a href="#JSON语法" class="headerlink" title="JSON语法"></a>JSON语法</h2><p>数据在名称/值对中</p>
<p>数据由逗号分隔</p>
<p>大括号保存对象</p>
<p>中括号保存数组</p>
<h2 id="JSON值"><a href="#JSON值" class="headerlink" title="JSON值"></a>JSON值</h2><p>数字(整数/浮点数)</p>
<p>字符串(双引号)</p>
<p>布尔值(true/false)</p>
<p>数组(中括号中)</p>
<p>对象(大括号中)</p>
<p>null</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>JSON 数据的书写格式是：名称/值对。</p>
<p>名称/值对组合中的名称写在前面（在双引号中），值对写在后面，中间用冒号隔开，</p>
<p>其中 值 可以是：数字（整数或浮点数）、字符串（在双引号中）、布尔值（true或false）、数组（在方括号中）、对象（在花括号中）、null</p>
<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var json = &#123;&quot;password&quot;:123456,&quot;name&quot;:&quot;myname&quot;,&quot;Booleans&quot;:true,&quot;Array&quot;:[1,2,3],&quot;object&quot;:&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>或者是嵌套使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">                      myObj = &#123;</span><br><span class="line"></span><br><span class="line">                          &quot;name&quot;:&quot;jnshu&quot;,</span><br><span class="line"></span><br><span class="line">                          &quot;alexa&quot;:10086,</span><br><span class="line"></span><br><span class="line">                          &quot;sites&quot;: &#123;</span><br><span class="line"></span><br><span class="line">                              &quot;site1&quot;:&quot;www.jnshu.com&quot;,</span><br><span class="line"></span><br><span class="line">                              &quot;site2&quot;:&quot;m.jnshu.com&quot;,</span><br><span class="line"></span><br><span class="line">                              &quot;site3&quot;:&quot;c.jnshu.com&quot;</span><br><span class="line"></span><br><span class="line">                          &#125;</span><br><span class="line"></span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                      console.log(myObj)</span><br><span class="line"></span><br><span class="line">//输出结果：</span><br><span class="line"></span><br><span class="line">Object &#123;name: &quot;jnshu&quot;, alexa: 10086, sites: Object&#125;</span><br></pre></td></tr></table></figure>
<h2 id="转义概述"><a href="#转义概述" class="headerlink" title="转义概述"></a>转义概述</h2><p>为什么需要转义？在js中我们使用的js对象进行处理，但是在与后端数据交换的时候，我们发送规定的json格式的字符串，所以在给后端发送或接受数据的时候，需要转义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;name:&quot;myname&quot;,password:&quot;123456&quot;&#125; </span><br><span class="line"></span><br><span class="line">&quot;&#123;&quot;name&quot;:&quot;myname&quot;,&quot;password&quot;:&quot;123456&quot;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>其中json字符串转js对象，调用parse方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">js对象 = JSON.parse(json字符串);</span><br><span class="line"></span><br><span class="line">js对象转json字符串，调用stringify方法：</span><br><span class="line"></span><br><span class="line">json字符串 = JSON.stringify(js对象);</span><br></pre></td></tr></table></figure>
<h1 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3.常见问题"></a>3.常见问题</h1><p>在json字符串转换成对象，还有eval(‘(‘+json字符串+’)’)这个方法，但是在对目标数据进行读取时，可能会出现一些意外的错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">var jsonstr = &apos;&#123;&quot;data1&quot;:&quot;hello&quot;,&quot;data2&quot;:++value&#125;&apos;;</span><br><span class="line"></span><br><span class="line">var data1 = eval(&apos;(&apos;+jsonstr+&apos;)&apos;);</span><br><span class="line"></span><br><span class="line">console.log(data1);//这时value值为2</span><br><span class="line"></span><br><span class="line">var data2=JSON.parse(jsonstr);</span><br><span class="line"></span><br><span class="line">console.log(data2);//报错</span><br></pre></td></tr></table></figure>
<p>原因：eval获取的json对象的值中，如果有执行代码，也将照样执行！所以若不能保证数据的安全性，不要使用eval方法进行转义。</p>
<h1 id="4-编码实战"><a href="#4-编码实战" class="headerlink" title="4.编码实战"></a>4.编码实战</h1><p>下面是一个简单的json数据发送应用，有兴趣可以阅读一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line"></span><br><span class="line">    var saveDataAry=[];</span><br><span class="line"></span><br><span class="line">    var data1=&#123;&quot;userName&quot;:&quot;test&quot;,&quot;address&quot;:&quot;gz&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    var data2=&#123;&quot;userName&quot;:&quot;ququ&quot;,&quot;address&quot;:&quot;gr&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    saveDataAry.push(data1);</span><br><span class="line"></span><br><span class="line">    saveDataAry.push(data2);</span><br><span class="line"></span><br><span class="line">    $.ajax(&#123;</span><br><span class="line"></span><br><span class="line">        type:&quot;POST&quot;,</span><br><span class="line"></span><br><span class="line">        url:&quot;user/saveUser&quot;,</span><br><span class="line"></span><br><span class="line">        dataType:&quot;json&quot;,</span><br><span class="line"></span><br><span class="line">        contentType:&quot;application/json&quot;,</span><br><span class="line"></span><br><span class="line">        data:JSON.stringify(saveDataAry),</span><br><span class="line"></span><br><span class="line">        success:function(data)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="5-扩展思考"><a href="#5-扩展思考" class="headerlink" title="5.扩展思考"></a>5.扩展思考</h1><p>我们常看到 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;name:&quot;myname&quot;,password:123456&#125;</span><br><span class="line"></span><br><span class="line">和</span><br><span class="line"></span><br><span class="line">&#123;&quot;name&quot;:&quot;myname&quot;,&quot;password&quot;:123456&#125;</span><br></pre></td></tr></table></figure>
<p>这样两种格式，即js对象和json，然而js对象和json有什么不一样的地方？</p>
<p>很多人搞不清楚 JSON 和 Js 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：</p>
<p>JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。</p>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var obj = &#123;a: &apos;Hello&apos;, b: &apos;World&apos;&#125;; //这是一个对象，注意键名也是可以使用引号包裹的</span><br><span class="line"></span><br><span class="line">var json = &apos;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&apos;; //这是一个 JSON 字符串，本质是一个字符串</span><br></pre></td></tr></table></figure>
<p>JSON格式的对象与一般JS对象语法上的区别？</p>
<p>对比内容JSONJS对象</p>
<ul>
<li><p>键名必须是加双引号可允许不加、加单引号、加双引号</p>
</li>
<li><p>属性值只能是数值（10进制）、字符串（双引号）、布尔值和null，</p>
</li>
</ul>
<p>也可以是数组或者符合JSON要求的对象，</p>
<ul>
<li>不能是函数、NaN, Infinity（存放表示正无穷大的数值）, -Infinity和undefined</li>
</ul>
<p>任意属性值均可</p>
<p>逗号问题最后一个属性后面不能有逗号可以有逗号</p>
<p>数值前导0不能用，小数点后必须有数字无限制</p>
<h1 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6.参考文献"></a>6.参考文献</h1><p>参考一：JSON官方文网</p>
<p>参考二：Json对象和Json字符串的区别</p>
<p>参考三：json属性名必须加引号的讨论</p>
<h1 id="7-更多讨论"><a href="#7-更多讨论" class="headerlink" title="7.更多讨论"></a>7.更多讨论</h1><p>json字符串转json对象,调用parse方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var b=&apos;&#123;&quot;name&quot;:&quot;2323&quot;,&quot;sex&quot;:&quot;afasdf&quot;,&quot;age&quot;:&quot;6262&quot;&#125;&apos;//json字符串var bToObject=JSON.parse(b);</span><br><span class="line"></span><br><span class="line">console.log(bToObject.name);//2323</span><br></pre></td></tr></table></figure>
<p>json对象转为json字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vara=&#123;&quot;name&quot;:&quot;tom&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:&quot;24&quot;&#125;//json对象varaToString=JSON.stringify(a);console.log(aToString);//&#123;&quot;name&quot;:&quot;tom&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:&quot;24&quot;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何使用Bootbox ？</title>
    <url>/2019/11/02/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%834/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Bootbox-%EF%BC%9F/</url>
    <content><![CDATA[<p>Bootbox.js是一个小型的JavaScript库，基于 TBootstrap 和jquery开发。它允许你创建使用编程对话框。方便用户快速创建模拟框。 </p><h1 id="下载bootbox文件"><a href="#下载bootbox文件" class="headerlink" title="下载bootbox文件"></a>下载bootbox文件</h1><p><a href="http://bootboxjs.com/getting-started.html" target="_blank" rel="noopener">点击右上角下载按钮进行下载</a></p><p>所有版本的Bootbox都站在两个伟大的巨人的肩上：<a href="https://getbootstrap.com/" target="_blank" rel="noopener">Bootstrap</a>和<a href="https://jquery.com/" target="_blank" rel="noopener">jQuery</a>。Bootstrap的确切版本取决于您使用的Bootbox的版本。这已经变得比我们想要的要复杂一些，但是希望这个方便的表格可以解决问题：</p><a id="more"></a>


<table>
<thead>
<tr>
<th>引导箱版本</th>
<th>最小 引导版本</th>
<th>最高 引导程序</th>
<th>最小 jQuery的</th>
<th>笔记</th>
</tr>
</thead>
<tbody>
<tr>
<td>5.xx 最新</td>
<td>3.0.0 <strong>*</strong></td>
<td>4.xx</td>
<td>1.9.1</td>
<td>当前版本。更新以支持Bootstrap4。与Bootstrap 3保持兼容性。</td>
</tr>
<tr>
<td>4.xx</td>
<td>3.0.0</td>
<td>3.4.x</td>
<td>1.9.1</td>
<td>完全重写以支持Bootstrap 3.0.0。</td>
</tr>
<tr>
<td>3.xx</td>
<td>2.2.2</td>
<td>2.3.2</td>
<td>1.8.3</td>
<td>支持Bootstrap 2的最新版本。</td>
</tr>
<tr>
<td>2.xx</td>
<td>2.0.0</td>
<td>2.0.4</td>
<td>1.7.1</td>
<td>如您所见，Bootstrap 2.1.x从未得到正式支持。</td>
</tr>
<tr>
<td>1.xx</td>
<td>1.3.0</td>
<td>1.4.0</td>
<td>1.7.1</td>
<td>不要下载此版本的Bootbox，因为它太旧了。</td>
</tr>
<tr>
<td><strong>*</strong>有些选项（例如<code>size</code>）需要Bootstrap 3.1.0或更高版本。</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>如果您使用的是Bootstrap 4，则还<strong>必须</strong>包含<a href="https://popper.js.org/" target="_blank" rel="noopener">Popper.js</a>。如果您愿意，Bootstrap当前还会在预编译版本中包含bootstrap.bundle.min.js文件，该文件将Popper.js与bootstrap.js源文件结合在一起。</p>
<h1 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;</span><br><span class="line">    &lt;title&gt;My page&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- CSS dependencies --&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .flexBox&#123;</span><br><span class="line">            display: flex;</span><br><span class="line">            align-items: center;</span><br><span class="line">            justify-content: center;</span><br><span class="line">            width: 100vw;</span><br><span class="line">            height: 100vh;</span><br><span class="line">        &#125;</span><br><span class="line">        .btn--margin&#123;</span><br><span class="line">            margin: 1rem;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;flexBox&quot;&gt;</span><br><span class="line">    &lt;!--&lt;p&gt;Content here. &lt;a class=&quot;show-alert&quot; href=#&gt;Alert!&lt;/a&gt;&lt;/p&gt;--&gt;</span><br><span class="line">    &lt;button type=&quot;button&quot; class=&quot;btn btn-lg btn--margin show-alert&quot;&gt;带回调的警告&lt;/button&gt;</span><br><span class="line">    &lt;button type=&quot;button&quot; class=&quot;btn btn-lg  btn--margin confirm&quot;&gt;对话框&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- JS dependencies --&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- Bootstrap 4 dependency --&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.bootcss.com/popper.js/1.15.0/esm/popper.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- bootbox code --&gt;</span><br><span class="line">&lt;script src=&quot;bootbox.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;bootbox.locales.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(document).on(&quot;click&quot;, &quot;.show-alert&quot;, function(e) &#123;</span><br><span class="line">        bootbox.alert(&#123;</span><br><span class="line">            message: &quot;在控制台可以看到带回调的警告！&quot;,</span><br><span class="line">            callback: function () &#123;</span><br><span class="line">                console.log(&apos;带回调的警告&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    $(document).on(&quot;click&quot;, &quot;.confirm&quot;, function(e) &#123;</span><br><span class="line">        bootbox.confirm(&quot;这是默认的确认框&quot;, function(result)&#123;</span><br><span class="line">            console.log(&apos;回调函数的结果时: &apos; + result);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h1 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h1><p>详细的用法参考官方文档</p>
<p><a href="http://bootboxjs.com/examples.html#bb-alert" target="_blank" rel="noopener">bootbox官方文档</a></p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>return的用法是什么？若用在for循环中，还会执行下一次循环吗？</title>
    <url>/2019/11/02/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%834/return%E7%9A%84%E7%94%A8%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%8B%A5%E7%94%A8%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E4%B8%AD%EF%BC%8C%E8%BF%98%E4%BC%9A%E6%89%A7%E8%A1%8C%E4%B8%8B%E4%B8%80%E6%AC%A1%E5%BE%AA%E7%8E%AF%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="return的用法"><a href="#return的用法" class="headerlink" title="return的用法"></a>return的用法</h1><h2 id="返回函数结果"><a href="#返回函数结果" class="headerlink" title="返回函数结果"></a>返回函数结果</h2><p><strong>语法为</strong>：return +表达式; 语句结束函数执行，返回调用函数，而且把表达式的值作为函数的结果</p><p>语句结束函数执行，返回调用函数，而且把表达式的值作为函数的结果。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add() &#123;</span><br><span class="line">    var a=1;</span><br><span class="line">    var b=2;</span><br><span class="line">    return a+b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function getAdd() &#123;</span><br><span class="line">    console.log(add());</span><br><span class="line">&#125;</span><br><span class="line">getAdd(); //控制台输出3</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>return 表示从被调函数返回到主调函数继续执行，返回时可附带一个返回值， 由return后面的参数指定。return通常是必要的，因为函数调用的时候计算结果通常是通过返回值带出的。</p>
<p>不使用return</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add() &#123;</span><br><span class="line">    var a=1;</span><br><span class="line">    var b=2;</span><br><span class="line">     a+b;</span><br><span class="line">&#125;</span><br><span class="line">function getAdd() &#123;</span><br><span class="line">    console.log(add());</span><br><span class="line">&#125;</span><br><span class="line">getAdd();// //控制台输出undefind</span><br></pre></td></tr></table></figure>
<h3 id="返回函数控制"><a href="#返回函数控制" class="headerlink" title="返回函数控制"></a>返回函数控制</h3><p><strong>语法为</strong>：return;无函数结果，</p>
<p>在大多数情况下,为事件处理函数返回false,可以防止默认的事件行为.例如,默认情况下点击<br>一个a标签元素,页面会跳转到该元素href属性指定的页.   </p>
<p>Return False 就相当于终止符，Return True 就相当于执行符。   </p>
<p>在js中return false的作用一般是用来取消默认动作的。比如你单击一个链接除了触发你的<br>onclick时间（如果你指定的话）以外还要触发一个默认事件就是执行页面的跳转。所以如果<br>你想取消对象的默认动作就可以return false。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;return&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href=&quot;https://www.baidu.com&quot;&gt;跳转至百度&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;https://www.baidu.com&quot; onclick=&quot;return false&quot;&gt;无法跳转&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function a() &#123;</span><br><span class="line">        return false;</span><br><span class="line">        console.log(&quot;函数a执行&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    function b() &#123;</span><br><span class="line">        console.log(&quot;函数b执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    function c() &#123;</span><br><span class="line">        console.log(&quot;函数c执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function abc() &#123;</span><br><span class="line">        a();</span><br><span class="line">        b();</span><br><span class="line">        c();</span><br><span class="line">    &#125;</span><br><span class="line">    abc();//控制台打印&quot;函数b执行.函数c执行&quot;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>即使a函数返回return false 阻止提交了，但是不影响 b()以及 c()函数的执行。在abc()函数里调用a()函数，那么 return false 对于abc()函数来说，只是相当于返回值，而不能阻止Test()函数执行。</p>
<h1 id="若用在for循环中，还会执行下一次循环吗"><a href="#若用在for循环中，还会执行下一次循环吗" class="headerlink" title="若用在for循环中，还会执行下一次循环吗"></a>若用在for循环中，还会执行下一次循环吗</h1><p>for循环只返回return所返回的值，并不会执行下一次循环。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function returnFor() &#123;</span><br><span class="line">      result = [1,2,3];</span><br><span class="line">      for(i=1;i&lt;10;i++)&#123;</span><br><span class="line">          result.push(i);</span><br><span class="line">          return result</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(result)</span><br><span class="line">  &#125;</span><br><span class="line">  returnFor();//控制台 [1, 2, 3, 1]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>简述JS中的event delegate事件委托</title>
    <url>/2019/11/02/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%834/%E7%AE%80%E8%BF%B0JS%E4%B8%AD%E7%9A%84event-delegate%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<p>原文链接：<a href="https://www.jianshu.com/p/d7d4bf472766" target="_blank" rel="noopener">https://www.jianshu.com/p/d7d4bf472766</a></p><h1 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h1><p>事件处理程序可以为现代web应用程序提供交互能力，因此许多开发人员会向页面中添加大量的处理程序。</p><p>但是在JavaScript中，添加到页面中的事件处理程序的数量会直接影响页面的整体运行性能。 </p><p>理由： </p><p>1.每个函数都是对象，都会占用内存。</p><a id="more"></a>




<p>2.事先指定所有的事件处理程序会导致DOM的访问次数增加，会延迟整个页面的交互时间。 对“事件处理程序过多”问题的解决方案就是事件委托（Delegation）。–JavaScript高级程序设计</p>
<p>3.事件委托的基本实现方式：在DOM树中尽量高的节点添加事件处理程序，代替在其多个子节点中添加。</p>
<p><strong>事件委托还有一个名字叫事件代理.</strong> </p>
<p>JS高程上讲：</p>
<p>事件委托就是利用事件冒泡，只制定一个事件处理程序，就可以管理某一类型的所有事件。</p>
<p><strong>这里用取快递来解释这个现象：</strong> </p>
<p>有三个同事预计会在周一收到快递。为签收快递，有两种办法：</p>
<p>一是三个人在公司门口等快递；</p>
<p>二是委托给前台代为签收。</p>
<p>现实当中，我们大都采用委托的方案。前台收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台也会在收到寄给新员工的快递后核实并代为签收。</p>
<p>这里其实还有2层意思的：</p>
<p>第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；</p>
<p>第二，新员工也是可以被前台代为签收的，即程序中新添加的dom节点也是有事件的。</p>
<hr>
<h1 id="2-知识剖析"><a href="#2-知识剖析" class="headerlink" title="2.知识剖析"></a>2.知识剖析</h1><h2 id="2-1为什么要用事件委托"><a href="#2-1为什么要用事件委托" class="headerlink" title="2.1为什么要用事件委托"></a>2.1为什么要用事件委托</h2><p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能， 因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多， 就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；</p>
<p>每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率越大，100个li就要占用100个内存空间。 如果要用事件委托，就会将所有的操作放到js程序里面，只对它的父级(如果只有一个父级)这一个对象进行操作， 与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；</p>
<h2 id="2-2事件委托的原理"><a href="#2-2事件委托的原理" class="headerlink" title="2.2事件委托的原理"></a>2.2事件委托的原理</h2><p>事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？</p>
<p>就是事件从最深的节点开始，然后逐步向上传播事件，</p>
<p>举个例子：</p>
<p>页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件， 那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div， 有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候， 都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p>
<p>实例1、</p>
<p><strong>子节点实现相同的功能：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/6285913-828c5ffbcefe490a.png?imageMogr2/auto-orient/strip|imageView2/2/w/682/format/webp" alt="img"> </p>
<p>实现功能是点击li，弹出123</p>
<p>我们看看有多少次的dom操作，首先要找到ul，然后遍历li，然后点击li的时候，又要找一次目标的li的位置，才能执行最后的操作，每次点击都要找一次li；</p>
<p><strong>那么我们用事件委托的方式做又会怎么样呢</strong>？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6285913-90ccbdaddab8250a.png?imageMogr2/auto-orient/strip|imageView2/2/w/712/format/webp" alt="img"> </p>
<p>这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发，当然，这里当点击ul的时候，也是会触发的.</p>
<h2 id="2-3-事件冒泡及捕获"><a href="#2-3-事件冒泡及捕获" class="headerlink" title="2.3 事件冒泡及捕获"></a>2.3 事件冒泡及捕获</h2><p>DOM2.0模型将事件处理流程分为三个阶段：</p>
<p>一、事件捕获阶段，</p>
<p>二、事件目标阶段，</p>
<p>三、事件起泡阶段。</p>
<p>如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6285913-53bc61bc8e253863.png?imageMogr2/auto-orient/strip|imageView2/2/w/540/format/webp" alt="img"> </p>
<p>事件捕获： </p>
<p>当某个元素触发某个事件（如onclick），顶层对象document就会发出一个事件流，</p>
<p>随着DOM树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。</p>
<p>在这个过程中，事件相应的监听函数是不会被触发的。</p>
<p>事件目标：</p>
<p>当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。</p>
<p>事件起泡：</p>
<p>从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被触发。</p>
<h2 id="2-4事件委托的优点"><a href="#2-4事件委托的优点" class="headerlink" title="2.4事件委托的优点"></a>2.4事件委托的优点</h2><p>通过刚才的对比介绍，大家应该能够体会到使用事件委托对于web应用程序带来的几个优点：</p>
<p>1.管理的函数变少了。不需要为每个元素都添加监听函数。对于同一个父节点下面类似的子元素，可以通过委托给父元素的监听函数来处理事件。</p>
<p>2.可以方便地动态添加和修改元素，不需要因为元素的改动而修改事件绑定。</p>
<p>3.JavaScript和DOM节点之间的关联变少了，这样也就减少了因循环引用而带来的内存泄漏发生的概率。</p>
<hr>
<h1 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3.常见问题"></a>3.常见问题</h1><p>如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办? </p>
<p>比如说只有点击li才会触发?</p>
<h1 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4.解决方案"></a>4.解决方案</h1><p>Event对象提供了一个属性叫target，可以返回事件的目标节点，</p>
<p>我们成为事件源， 也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作dom。 </p>
<p>标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置， 并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名。 </p>
<p>这样改下就只有点击li会触发事件了，且每次只执行一次dom操作 </p>
<p>HTML引用上面的实例部分</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6285913-f1c4eb62c1dadb65.png?imageMogr2/auto-orient/strip|imageView2/2/w/793/format/webp" alt="img"> </p>
<h1 id="5-编码实战"><a href="#5-编码实战" class="headerlink" title="5.编码实战"></a>5.编码实战</h1><p>现在讲的都是document加载完成的现有dom节点下的操作， 那么如果是新增的节点，新增的节点会有事件吗？ 现在是移入li，li变红，移出li，li变蓝，这么一个效果，然后点击按钮，可以向ul中添加一个li子节点 </p>
<p><img src="https://upload-images.jianshu.io/upload_images/6285913-569d46ede7205b3e.png?imageMogr2/auto-orient/strip|imageView2/2/w/646/format/webp" alt="img"> </p>
<p>HTML引用上面的实例部分</p>
<p>我们可以发现，当用事件委托的时候，根本就不需要去遍历元素的子节点， 只需要给父级元素添加事件就好了，其他的都是在js里面的执行， 这样可以大大的减少dom操作，这才是事件委托的精髓所在。 </p>
<p><img src="https://upload-images.jianshu.io/upload_images/6285913-c4ea2261e44d04a9.png?imageMogr2/auto-orient/strip|imageView2/2/w/692/format/webp" alt="img"> </p>
<p>HTML引用上面的实例部分</p>
<h1 id="6-扩展思考"><a href="#6-扩展思考" class="headerlink" title="6.扩展思考"></a>6.扩展思考</h1><p>什么样的事件可以用事件委托，什么样的事件不可以用呢？ </p>
<p>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。（所有用到按钮的事件，多数的鼠标事件和键盘事件）</p>
<p>值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。</p>
<p>不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。</p>
<h1 id="7-参考文献"><a href="#7-参考文献" class="headerlink" title="7.参考文献"></a>7.参考文献</h1><p> 参考一：<a href="https://link.jianshu.com?t=https://www.cnblogs.com/owenChen/archive/2013/02/18/2915521.html" target="_blank" rel="noopener">(转)陈鑫伟的博客</a></p>
<h1 id="8-更多讨论"><a href="#8-更多讨论" class="headerlink" title="8.更多讨论"></a>8.更多讨论</h1><p>一、事件委托解决了什么问题？ </p>
<p>1-可以绑定文档完成后新出现的新的子元素</p>
<p>2-指定绑定事件的范围（父元素）</p>
<p>3-不需要为每个元素设置绑定</p>
<p> 二、与其它事件绑定有什么区别？</p>
<p>.on()可多个事件绑定新元素冒泡不能绑定子元素</p>
<p>.bind()可多个事件绑定新元素冒泡不能绑定子元素</p>
<p>.delegate()可多个事件绑定新元素冒泡绑定子元素</p>
<p>.click()单个事件不可绑定新元素冒泡绑定子元素</p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>对一个数组 filter、some、map、foreach的操作分别有什么作用？</title>
    <url>/2019/11/01/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%834/%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84-filter%E3%80%81some%E3%80%81map%E3%80%81foreach%E7%9A%84%E6%93%8D%E4%BD%9C%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<p>使用JavaScript数组常常需要对数组进行遍历、迭代操作。而我们常用的就是for语句对数组进行迭代。然而在ECMAscript5已经为数组定义了5个迭代的方法，分别是：filter、some、map、foreach、every，下面我们讲讲它们的具体作用。</p><h1 id="every-和some"><a href="#every-和some" class="headerlink" title="every()和some()"></a>every()和some()</h1><p>every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true ;<br>some()： 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true; 为了加深对它们的理解，以上两个迭代方式有必要放在一起demo，<br>演示如下：<br><img src="https://img-blog.csdnimg.cn/20191101150657552.png" alt="every()和some()"><br><img src="https://img-blog.csdnimg.cn/20191101150743191.png" alt="在这里插入图片描述"></p><a id="more"></a>

<p>通过 demo，可以看出<br>every()，在遍历数组项的时候，<strong>第一项的值就已经为false了，所以直接返回false不再继续执行后面的迭代；</strong><br>some() ，在遍历数组项的时候，当第一个满足函数体的项出现，就直接返回true，并且不再执行后面的迭代；</p>
<h1 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h1><p>filter()：对数组中的每一项运行给定函数，返回该函数会返回true 的项组成的数组。<br>演示如下：<br> <img src="https://img-blog.csdnimg.cn/20191101151110577.png" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20191101151127414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW54aW50aWFuZGlzaGVuZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通过demo，可以看出filter() 把原数组arr每一项返回为true的项，重新组成数组，并打印出该数组每个索引的值和数组长度；</p>
<h1 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h1><p>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组<br>演示如下：<br> <img src="https://img-blog.csdnimg.cn/20191101151234877.png" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20191101151254404.png" alt="在这里插入图片描述"></p>
<p>通过demo可以看出 map() 把原数组arr的每一项迭代返回的结果，重新组成数组，并打印出该数组每个索引的值和数组长度；</p>
<h1 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h1><p>forEach()：对数组中的每一项运行给定函数，这个方法并没有返回值<br> <img src="https://img-blog.csdnimg.cn/20191101151330192.png" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20191101151343615.png" alt="在这里插入图片描述"><br>通过demo可以看出 forEach()，只是对每个数组项运行指定的函数体，这个迭代方式并没有返回值；</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>如何判断两个数组中相同的项，然后将相同的部分或者不同的部分生成新的数组？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var num1 = [1,2,3,4,5,7];    </span><br><span class="line"></span><br><span class="line">var num2 = [2,3,5];    </span><br><span class="line"></span><br><span class="line">var nums = num1.filter(function(aaa)&#123;    </span><br><span class="line"></span><br><span class="line">    return num2.indexOf(aaa) &gt;= 0;    </span><br><span class="line"></span><br><span class="line">&#125;);    </span><br><span class="line"></span><br><span class="line">console.log(nums);</span><br></pre></td></tr></table></figure>
<h1 id="扩展思考"><a href="#扩展思考" class="headerlink" title="扩展思考"></a>扩展思考</h1><p>问：相对于for()，JS数组自定义的数组迭代方式有哪些好处？这里面参数item、index和array代表的是什么？<br>答：在实现相同功能的前提下，后者除了能够节省代码量外，在实现某些功能上的流程中存在很多有意思的优势，比如forEach相比普通的for循环的优势在于对稀疏数组的处理，会跳过数组中的空位。for+i在性能测试上是优越于后者，但是前提是，array的length要事先计算出来，而在处理非常大量的数据时候，后者的优势就显而易见了。<br>答：传入这些方法中的函数会接收三个参数，item表示遍历后的当前对象，里面的index代表当前循环到第几个索引，array代表数组对象本身；</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p> <a href="https://blog.csdn.net/michael8512/article/details/77892899" target="_blank" rel="noopener">https://blog.csdn.net/michael8512/article/details/77892899</a></p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>vue中前端跨域方案</title>
    <url>/2019/11/01/Vue/vue%E4%B8%AD%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>vue项目中，前端与后台进行数据请求或者提交的时候，如果后台没有设置跨域，前端本地调试代码的时候就会报“No ‘Access-Control-Allow-Origin’ header is present on the requested resource.” 这种跨域错误。</p><p>搜素资料，发现方式五花八门，什么修改config/index.js中的配置，但是我的项目里面根本就没有这文件夹，大多都是过时资料。</p><a id="more"></a>

<p>本文主要介绍如何使用反向代理进行跨域。</p>
<h1 id="vue-cli搭建项目"><a href="#vue-cli搭建项目" class="headerlink" title="vue-cli搭建项目"></a>vue-cli搭建项目</h1><h2 id="根目录下新建vue-config-js"><a href="#根目录下新建vue-config-js" class="headerlink" title="根目录下新建vue.config.js"></a>根目录下新建vue.config.js</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|-- dist                       # 打包后文件夹	        </span><br><span class="line">|-- public                     # 静态文件夹         		                  </span><br><span class="line">|   |-- favicon.ico				</span><br><span class="line">|   |-- index.html					#入口页面</span><br><span class="line">|-- src                        # 源码目录         </span><br><span class="line">|   |--assets						# 模块资源</span><br><span class="line">|   |--components					# vue公共组件</span><br><span class="line">|   |--views 						</span><br><span class="line">|   |--App.vue                                          # 页面入口文件</span><br><span class="line">|   |--main.js	                                        # 入口文件，加载公共组件</span><br><span class="line">|   |--router.js                                        # 路由配置</span><br><span class="line">|   |--store.js	                                        # 状态管理</span><br><span class="line">|-- .env.pre-release          # 预发布环境    </span><br><span class="line">|-- .env.production	      # 生产环境       </span><br><span class="line">|-- .env.test		      # 测试环境  </span><br><span class="line">|-- vue.config.js             # 根目录下新建vue.config.js</span><br><span class="line">|-- .eslintrc.js    		  	# ES-lint校验                   </span><br><span class="line">|-- .gitignore          		# git忽略上传的文件格式   </span><br><span class="line">|-- babel.config.js   			# babel语法编译                        </span><br><span class="line">|-- package.json       	     # 项目基本信息 </span><br><span class="line">|-- postcss.config.js   	 	# CSS预处理器(此处默认启用autoprefixer)</span><br></pre></td></tr></table></figure>
<p>vue-cli3.0致力于Vue生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你就可以专注在撰写应用上，减少配置的时间。查看如下文件，会发现相比于vue-cli2.0少了<code>build</code>与<code>config</code>文件夹，所以vue-cli3提供了一个可选的配置文件 ——<code>vue.config.js</code>。请具体参考4和5(打包配置)，这里只详细解读文件作用。</p>
<h3 id="vue-config-js简介"><a href="#vue-config-js简介" class="headerlink" title="vue.config.js简介"></a>vue.config.js简介</h3><p>Vue.config.js是一个可选的配置文件，如果项目的根目录存在这个文件，那么它就会被 <code>@vue/cli-service</code> 自动加载。你也可以使用package.json中的vue字段，但要注意严格遵守JSON的格式来写。这里使用配置vue.config.js的方式进行处理。</p>
<h2 id="编辑vue-config-js"><a href="#编辑vue-config-js" class="headerlink" title="编辑vue.config.js"></a>编辑vue.config.js</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            &apos;/api&apos;: &#123;</span><br><span class="line">                target: &apos;http://dev.admin.carrots.ptteng.com&apos;,</span><br><span class="line">                ws: true,</span><br><span class="line">                changeOrigin: true,</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    &apos;^/api&apos;: &apos;http://dev.admin.carrots.ptteng.com&apos;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // devServer:&#123;</span><br><span class="line">    //     proxyTable: &#123;</span><br><span class="line">    //         &apos;/api&apos;: &#123;  //使用&quot;/api&quot;来代替&quot;http://f.apiplus.c&quot;</span><br><span class="line">    //             target: &apos;http://dev.admin.carrots.ptteng.com&apos;, //源地址</span><br><span class="line">    //             changeOrigin: true, //改变源</span><br><span class="line">    //             pathRewrite: &#123;</span><br><span class="line">    //                 &apos;^/api&apos;: &apos;http://dev.admin.carrots.ptteng.com&apos; //路径重写</span><br><span class="line">    //             &#125;</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="webpack搭建项目"><a href="#webpack搭建项目" class="headerlink" title="webpack搭建项目"></a>webpack搭建项目</h1><h2 id="修改webpack-config-js或者webpack-base-js"><a href="#修改webpack-config-js或者webpack-base-js" class="headerlink" title="修改webpack.config.js或者webpack.base.js"></a>修改webpack.config.js或者webpack.base.js</h2><p>在<code>module.exports = {}</code>添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">       proxy: &#123;</span><br><span class="line">           &apos;/api&apos;: &#123;</span><br><span class="line">               target: &apos;http://dev.admin.carrots.ptteng.com&apos;,</span><br><span class="line">               ws: true,</span><br><span class="line">               changeOrigin: true,</span><br><span class="line">               pathRewrite: &#123;</span><br><span class="line">                   &apos;^/api&apos;: &apos;http://dev.admin.carrots.ptteng.com&apos;</span><br><span class="line">               &#125;,</span><br><span class="line">           &#125;,</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   // devServer:&#123;</span><br><span class="line">   //     proxyTable: &#123;</span><br><span class="line">   //         &apos;/api&apos;: &#123;  //使用&quot;/api&quot;来代替&quot;http://f.apiplus.c&quot;</span><br><span class="line">   //             target: &apos;http://dev.admin.carrots.ptteng.com&apos;, //源地址</span><br><span class="line">   //             changeOrigin: true, //改变源</span><br><span class="line">   //             pathRewrite: &#123;</span><br><span class="line">   //                 &apos;^/api&apos;: &apos;http://dev.admin.carrots.ptteng.com&apos; //路径重写</span><br><span class="line">   //             &#125;</span><br><span class="line">   //         &#125;</span><br><span class="line">   //     &#125;</span><br><span class="line">   // &#125;</span><br></pre></td></tr></table></figure>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>修改后需重启服务后生效</p>
<h1 id="vue测试组件"><a href="#vue测试组件" class="headerlink" title="vue测试组件"></a>vue测试组件</h1><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>可以在vue项目中引入如下组件进行测试</p>
<p>需要安装axios，<code>npm install --save-dev axios</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=&quot;example-2&quot;&gt;</span><br><span class="line">        &lt;!-- `post` 是在下面定义的方法名 --&gt;</span><br><span class="line">        &lt;button v-on:click=&quot;post&quot;&gt;登录&lt;/button&gt;</span><br><span class="line">        &lt;p&gt;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import axios from &apos;axios&apos;</span><br><span class="line"></span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;Ajax&quot;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            post() &#123;</span><br><span class="line">                axios.post(&apos;/api/a/login?name=admin&amp;pwd=123456&apos;, &#123;</span><br><span class="line">                &#125;)</span><br><span class="line">                    .then(function (response) &#123;</span><br><span class="line">                        console.log(response);</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .catch(function (error) &#123;</span><br><span class="line">                        console.log(error);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>package.json文件，仅供参考</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hello-world&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;vue-cli-service build&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;vue-cli-service lint&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;core-js&quot;: &quot;^3.3.2&quot;,</span><br><span class="line">    &quot;vue&quot;: &quot;^2.6.10&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;@vue/cli-plugin-babel&quot;: &quot;^4.0.0&quot;,</span><br><span class="line">    &quot;@vue/cli-plugin-eslint&quot;: &quot;^4.0.0&quot;,</span><br><span class="line">    &quot;@vue/cli-service&quot;: &quot;^4.0.0&quot;,</span><br><span class="line">    &quot;axios&quot;: &quot;^0.19.0&quot;,</span><br><span class="line">    &quot;babel-eslint&quot;: &quot;^10.0.3&quot;,</span><br><span class="line">    &quot;eslint&quot;: &quot;^5.16.0&quot;,</span><br><span class="line">    &quot;eslint-plugin-vue&quot;: &quot;^5.0.0&quot;,</span><br><span class="line">    &quot;vue-template-compiler&quot;: &quot;^2.6.10&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;eslintConfig&quot;: &#123;</span><br><span class="line">    &quot;root&quot;: true,</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">      &quot;node&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;extends&quot;: [</span><br><span class="line">      &quot;plugin:vue/essential&quot;,</span><br><span class="line">      &quot;eslint:recommended&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">      &quot;no-console&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;parserOptions&quot;: &#123;</span><br><span class="line">      &quot;parser&quot;: &quot;babel-eslint&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;postcss&quot;: &#123;</span><br><span class="line">    &quot;plugins&quot;: &#123;</span><br><span class="line">      &quot;autoprefixer&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;browserslist&quot;: [</span><br><span class="line">    &quot;&gt; 1%&quot;,</span><br><span class="line">    &quot;last 2 versions&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://juejin.im/post/5d453068f265da03eb13ac47#heading-16" target="_blank" rel="noopener">vue跨域方案指北</a></p>
<p><a href="https://juejin.im/post/5c63afd56fb9a049b41cf5f4" target="_blank" rel="noopener">VUE CLI 3 配置</a></p>
<p><a href="https://github.com/funnycoderstar/blog/issues/42" target="_blank" rel="noopener">Webpack-dev-server的proxy用法</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>vue-cli3的eslint配置问题</title>
    <url>/2019/11/01/Vue/vue-cli3%E7%9A%84eslint%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>vue-cli3按照官网教程配置搭建后，发现每次编译，eslint都抛出错误</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: Expected indentation of 4 spaces but found 0 (indent) at src\views\User.vue:26:1:</span><br><span class="line">1 error found.</span><br><span class="line">1 error potentially fixable with the `--fix` option.</span><br><span class="line"></span><br><span class="line">You may use special comments to disable some warnings.</span><br><span class="line">Use // eslint-disable-next-line to ignore the next line.</span><br><span class="line">Use /* eslint-disable */ to ignore all warnings in a file.</span><br></pre></td></tr></table></figure><a id="more"></a>

<p>真实蛋疼eslint默认要4个空格的缩进啊<br>于是网上搜索了好多es-lint的配置方法，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;indent&quot;: [2, 4],//缩进风格</span><br></pre></td></tr></table></figure>
<p>这一条最适合我了，但是配置后还是报错啊。<br> 后台发现配置后需要重启服务器才生效<br> 重启之，es-lint配置成功了<br> 最后附上参考的配置文件</p>
<h1 id="关闭eslint"><a href="#关闭eslint" class="headerlink" title="关闭eslint"></a>关闭eslint</h1><p> 直接注释掉package.json文件中eslint的配置就可以了（以下是vue-cli的默认配置）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;eslintConfig&quot;: &#123;</span><br><span class="line">   &quot;root&quot;: true,////此项是用来告诉eslint找当前配置文件不能往父级查找</span><br><span class="line">   &quot;env&quot;: &#123;</span><br><span class="line">     &quot;node&quot;: true//此项指定环境的全局变量，下面的配置指定为node环境</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;extends&quot;: [// 此项是用来配置vue.js风格，就是说写代码的时候要规范的写，如果你使用vs-code我觉得应该可以避免出错</span><br><span class="line">     &quot;plugin:vue/essential&quot;,</span><br><span class="line">     &quot;@vue/standard&quot;</span><br><span class="line">   ],</span><br><span class="line">   &quot;rules&quot;: &#123;//规则配置写在这里</span><br><span class="line">     &quot;indent&quot;: [1, 4]</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;parserOptions&quot;: &#123;</span><br><span class="line">     &quot;parser&quot;: &quot;babel-eslint&quot;//此项是用来指定eslint解析器的，解析器必须符合规则，babel-eslint解析器是对babel解析器的包装使其与ESLint解析</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>
<p>或者vue.config.js中将以下三项设置为false</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    overlay: &#123;</span><br><span class="line">        warnings: false,</span><br><span class="line">        errors: false</span><br><span class="line">    &#125;,</span><br><span class="line">    lintOnSave: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细解读可参考<a href="https://cli.vuejs.org/zh/config/#pages" target="_blank" rel="noopener">vue-cli配置官方文档</a><br> 或者<a href="https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-eslint" target="_blank" rel="noopener">vue-cli-eslint github说明书</a></p>
<h1 id="修改eslint的语法检测，"><a href="#修改eslint的语法检测，" class="headerlink" title="修改eslint的语法检测，"></a>修改eslint的语法检测，</h1><p>文件为根目录下的 <strong>package.json</strong>文件（规则写在rules内）<br>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">    &quot;规则名&quot;: [规则值, 规则配置]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规则值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;off&quot;或者0    //关闭规则关闭</span><br><span class="line">&quot;warn&quot;或者1    //在打开的规则作为警告（不影响退出代码）</span><br><span class="line">&quot;error&quot;或者2    //把规则作为一个错误（退出代码触发时为1）</span><br></pre></td></tr></table></figure>
<p>3、eslint 规则配置参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;no-alert&quot;: 0,//禁止使用alert confirm prompt</span><br><span class="line">&quot;no-array-constructor&quot;: 2,//禁止使用数组构造器</span><br><span class="line">&quot;no-bitwise&quot;: 0,//禁止使用按位运算符</span><br><span class="line">&quot;no-caller&quot;: 1,//禁止使用arguments.caller或arguments.callee</span><br><span class="line">&quot;no-catch-shadow&quot;: 2,//禁止catch子句参数与外部作用域变量同名</span><br><span class="line">&quot;no-class-assign&quot;: 2,//禁止给类赋值</span><br><span class="line">&quot;no-cond-assign&quot;: 2,//禁止在条件表达式中使用赋值语句</span><br><span class="line">&quot;no-console&quot;: 2,//禁止使用console</span><br><span class="line">&quot;no-const-assign&quot;: 2,//禁止修改const声明的变量</span><br><span class="line">&quot;no-constant-condition&quot;: 2,//禁止在条件中使用常量表达式 if(true) if(1)</span><br><span class="line">&quot;no-continue&quot;: 0,//禁止使用continue</span><br><span class="line">&quot;no-control-regex&quot;: 2,//禁止在正则表达式中使用控制字符</span><br><span class="line">&quot;no-debugger&quot;: 2,//禁止使用debugger</span><br><span class="line">&quot;no-delete-var&quot;: 2,//不能对var声明的变量使用delete操作符</span><br><span class="line">&quot;no-div-regex&quot;: 1,//不能使用看起来像除法的正则表达式/=foo/</span><br><span class="line">&quot;no-dupe-keys&quot;: 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;</span><br><span class="line">&quot;no-dupe-args&quot;: 2,//函数参数不能重复</span><br><span class="line">&quot;no-duplicate-case&quot;: 2,//switch中的case标签不能重复</span><br><span class="line">&quot;no-else-return&quot;: 2,//如果if语句里面有return,后面不能跟else语句</span><br><span class="line">&quot;no-empty&quot;: 2,//块语句中的内容不能为空</span><br><span class="line">&quot;no-empty-character-class&quot;: 2,//正则表达式中的[]内容不能为空</span><br><span class="line">&quot;no-empty-label&quot;: 2,//禁止使用空label</span><br><span class="line">&quot;no-eq-null&quot;: 2,//禁止对null使用==或!=运算符</span><br><span class="line">&quot;no-eval&quot;: 1,//禁止使用eval</span><br><span class="line">&quot;no-ex-assign&quot;: 2,//禁止给catch语句中的异常参数赋值</span><br><span class="line">&quot;no-extend-native&quot;: 2,//禁止扩展native对象</span><br><span class="line">&quot;no-extra-bind&quot;: 2,//禁止不必要的函数绑定</span><br><span class="line">&quot;no-extra-boolean-cast&quot;: 2,//禁止不必要的bool转换</span><br><span class="line">&quot;no-extra-parens&quot;: 2,//禁止非必要的括号</span><br><span class="line">&quot;no-extra-semi&quot;: 2,//禁止多余的冒号</span><br><span class="line">&quot;no-fallthrough&quot;: 1,//禁止switch穿透</span><br><span class="line">&quot;no-floating-decimal&quot;: 2,//禁止省略浮点数中的0 .5 3.</span><br><span class="line">&quot;no-func-assign&quot;: 2,//禁止重复的函数声明</span><br><span class="line">&quot;no-implicit-coercion&quot;: 1,//禁止隐式转换</span><br><span class="line">&quot;no-implied-eval&quot;: 2,//禁止使用隐式eval</span><br><span class="line">&quot;no-inline-comments&quot;: 0,//禁止行内备注</span><br><span class="line">&quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],//禁止在块语句中使用声明（变量或函数）</span><br><span class="line">&quot;no-invalid-regexp&quot;: 2,//禁止无效的正则表达式</span><br><span class="line">&quot;no-invalid-this&quot;: 2,//禁止无效的this，只能用在构造器，类，对象字面量</span><br><span class="line">&quot;no-irregular-whitespace&quot;: 2,//不能有不规则的空格</span><br><span class="line">&quot;no-iterator&quot;: 2,//禁止使用__iterator__ 属性</span><br><span class="line">&quot;no-label-var&quot;: 2,//label名不能与var声明的变量名相同</span><br><span class="line">&quot;no-labels&quot;: 2,//禁止标签声明</span><br><span class="line">&quot;no-lone-blocks&quot;: 2,//禁止不必要的嵌套块</span><br><span class="line">&quot;no-lonely-if&quot;: 2,//禁止else语句内只有if语句</span><br><span class="line">&quot;no-loop-func&quot;: 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）</span><br><span class="line">&quot;no-mixed-requires&quot;: [0, false],//声明时不能混用声明类型</span><br><span class="line">&quot;no-mixed-spaces-and-tabs&quot;: [2, false],//禁止混用tab和空格</span><br><span class="line">&quot;linebreak-style&quot;: [0, &quot;windows&quot;],//换行风格</span><br><span class="line">&quot;no-multi-spaces&quot;: 1,//不能用多余的空格</span><br><span class="line">&quot;no-multi-str&quot;: 2,//字符串不能用\换行</span><br><span class="line">&quot;no-multiple-empty-lines&quot;: [1, &#123;&quot;max&quot;: 2&#125;],//空行最多不能超过2行</span><br><span class="line">&quot;no-native-reassign&quot;: 2,//不能重写native对象</span><br><span class="line">&quot;no-negated-in-lhs&quot;: 2,//in 操作符的左边不能有!</span><br><span class="line">&quot;no-nested-ternary&quot;: 0,//禁止使用嵌套的三目运算</span><br><span class="line">&quot;no-new&quot;: 1,//禁止在使用new构造一个实例后不赋值</span><br><span class="line">&quot;no-new-func&quot;: 1,//禁止使用new Function</span><br><span class="line">&quot;no-new-object&quot;: 2,//禁止使用new Object()</span><br><span class="line">&quot;no-new-require&quot;: 2,//禁止使用new require</span><br><span class="line">&quot;no-new-wrappers&quot;: 2,//禁止使用new创建包装实例，new String new Boolean new Number</span><br><span class="line">&quot;no-obj-calls&quot;: 2,//不能调用内置的全局对象，比如Math() JSON()</span><br><span class="line">&quot;no-octal&quot;: 2,//禁止使用八进制数字</span><br><span class="line">&quot;no-octal-escape&quot;: 2,//禁止使用八进制转义序列</span><br><span class="line">&quot;no-param-reassign&quot;: 2,//禁止给参数重新赋值</span><br><span class="line">&quot;no-path-concat&quot;: 0,//node中不能使用__dirname或__filename做路径拼接</span><br><span class="line">&quot;no-plusplus&quot;: 0,//禁止使用++，--</span><br><span class="line">&quot;no-process-env&quot;: 0,//禁止使用process.env</span><br><span class="line">&quot;no-process-exit&quot;: 0,//禁止使用process.exit()</span><br><span class="line">&quot;no-proto&quot;: 2,//禁止使用__proto__属性</span><br><span class="line">&quot;no-redeclare&quot;: 2,//禁止重复声明变量</span><br><span class="line">&quot;no-regex-spaces&quot;: 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/</span><br><span class="line">&quot;no-restricted-modules&quot;: 0,//如果禁用了指定模块，使用就会报错</span><br><span class="line">&quot;no-return-assign&quot;: 1,//return 语句中不能有赋值表达式</span><br><span class="line">&quot;no-script-url&quot;: 0,//禁止使用javascript:void(0)</span><br><span class="line">&quot;no-self-compare&quot;: 2,//不能比较自身</span><br><span class="line">&quot;no-sequences&quot;: 0,//禁止使用逗号运算符</span><br><span class="line">&quot;no-shadow&quot;: 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名</span><br><span class="line">&quot;no-shadow-restricted-names&quot;: 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用</span><br><span class="line">&quot;no-spaced-func&quot;: 2,//函数调用时 函数名与()之间不能有空格</span><br><span class="line">&quot;no-sparse-arrays&quot;: 2,//禁止稀疏数组， [1,,2]</span><br><span class="line">&quot;no-sync&quot;: 0,//nodejs 禁止同步方法</span><br><span class="line">&quot;no-ternary&quot;: 0,//禁止使用三目运算符</span><br><span class="line">&quot;no-trailing-spaces&quot;: 1,//一行结束后面不要有空格</span><br><span class="line">&quot;no-this-before-super&quot;: 0,//在调用super()之前不能使用this或super</span><br><span class="line">&quot;no-throw-literal&quot;: 2,//禁止抛出字面量错误 throw &quot;error&quot;;</span><br><span class="line">&quot;no-undef&quot;: 1,//不能有未定义的变量</span><br><span class="line">&quot;no-undef-init&quot;: 2,//变量初始化时不能直接给它赋值为undefined</span><br><span class="line">&quot;no-undefined&quot;: 2,//不能使用undefined</span><br><span class="line">&quot;no-unexpected-multiline&quot;: 2,//避免多行表达式</span><br><span class="line">&quot;no-underscore-dangle&quot;: 1,//标识符不能以_开头或结尾</span><br><span class="line">&quot;no-unneeded-ternary&quot;: 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;</span><br><span class="line">&quot;no-unreachable&quot;: 2,//不能有无法执行的代码</span><br><span class="line">&quot;no-unused-expressions&quot;: 2,//禁止无用的表达式</span><br><span class="line">&quot;no-unused-vars&quot;: [2, &#123;&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;&#125;],//不能有声明后未被使用的变量或参数</span><br><span class="line">&quot;no-use-before-define&quot;: 2,//未定义前不能使用</span><br><span class="line">&quot;no-useless-call&quot;: 2,//禁止不必要的call和apply</span><br><span class="line">&quot;no-void&quot;: 2,//禁用void操作符</span><br><span class="line">&quot;no-var&quot;: 0,//禁用var，用let和const代替</span><br><span class="line">&quot;no-warning-comments&quot;: [1, &#123; &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;xxx&quot;], &quot;location&quot;: &quot;start&quot; &#125;],//不能有警告备注</span><br><span class="line">&quot;no-with&quot;: 2,//禁用with</span><br><span class="line"></span><br><span class="line">&quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],//是否允许非空数组里面有多余的空格</span><br><span class="line">&quot;arrow-parens&quot;: 0,//箭头函数用小括号括起来</span><br><span class="line">&quot;arrow-spacing&quot;: 0,//=&gt;的前/后括号</span><br><span class="line">&quot;accessor-pairs&quot;: 0,//在对象中使用getter/setter</span><br><span class="line">&quot;block-scoped-var&quot;: 0,//块语句中使用var</span><br><span class="line">&quot;brace-style&quot;: [1, &quot;1tbs&quot;],//大括号风格</span><br><span class="line">&quot;callback-return&quot;: 1,//避免多次调用回调什么的</span><br><span class="line">&quot;camelcase&quot;: 2,//强制驼峰法命名</span><br><span class="line">&quot;comma-dangle&quot;: [2, &quot;never&quot;],//对象字面量项尾不能有逗号</span><br><span class="line">&quot;comma-spacing&quot;: 0,//逗号前后的空格</span><br><span class="line">&quot;comma-style&quot;: [2, &quot;last&quot;],//逗号风格，换行时在行首还是行尾</span><br><span class="line">&quot;complexity&quot;: [0, 11],//循环复杂度</span><br><span class="line">&quot;computed-property-spacing&quot;: [0, &quot;never&quot;],//是否允许计算后的键名什么的</span><br><span class="line">&quot;consistent-return&quot;: 0,//return 后面是否允许省略</span><br><span class="line">&quot;consistent-this&quot;: [2, &quot;that&quot;],//this别名</span><br><span class="line">&quot;constructor-super&quot;: 0,//非派生类不能调用super，派生类必须调用super</span><br><span class="line">&quot;curly&quot;: [2, &quot;all&quot;],//必须使用 if()&#123;&#125; 中的&#123;&#125;</span><br><span class="line">&quot;default-case&quot;: 2,//switch语句最后必须有default</span><br><span class="line">&quot;dot-location&quot;: 0,//对象访问符的位置，换行的时候在行首还是行尾</span><br><span class="line">&quot;dot-notation&quot;: [0, &#123; &quot;allowKeywords&quot;: true &#125;],//避免不必要的方括号</span><br><span class="line">&quot;eol-last&quot;: 0,//文件以单一的换行符结束</span><br><span class="line">&quot;eqeqeq&quot;: 2,//必须使用全等</span><br><span class="line">&quot;func-names&quot;: 0,//函数表达式必须有名字</span><br><span class="line">&quot;func-style&quot;: [0, &quot;declaration&quot;],//函数风格，规定只能使用函数声明/函数表达式</span><br><span class="line">&quot;generator-star-spacing&quot;: 0,//生成器函数*的前后空格</span><br><span class="line">&quot;guard-for-in&quot;: 0,//for in循环要用if语句过滤</span><br><span class="line">&quot;handle-callback-err&quot;: 0,//nodejs 处理错误</span><br><span class="line">&quot;id-length&quot;: 0,//变量名长度</span><br><span class="line">&quot;indent&quot;: [2, 4],//缩进风格</span><br><span class="line">&quot;init-declarations&quot;: 0,//声明时必须赋初值</span><br><span class="line">&quot;key-spacing&quot;: [0, &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;],//对象字面量中冒号的前后空格</span><br><span class="line">&quot;lines-around-comment&quot;: 0,//行前/行后备注</span><br><span class="line">&quot;max-depth&quot;: [0, 4],//嵌套块深度</span><br><span class="line">&quot;max-len&quot;: [0, 80, 4],//字符串最大长度</span><br><span class="line">&quot;max-nested-callbacks&quot;: [0, 2],//回调嵌套深度</span><br><span class="line">&quot;max-params&quot;: [0, 3],//函数最多只能有3个参数</span><br><span class="line">&quot;max-statements&quot;: [0, 10],//函数内最多有几个声明</span><br><span class="line">&quot;new-cap&quot;: 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用</span><br><span class="line">&quot;new-parens&quot;: 2,//new时必须加小括号</span><br><span class="line">&quot;newline-after-var&quot;: 2,//变量声明后是否需要空一行</span><br><span class="line">&quot;object-curly-spacing&quot;: [0, &quot;never&quot;],//大括号内是否允许不必要的空格</span><br><span class="line">&quot;object-shorthand&quot;: 0,//强制对象字面量缩写语法</span><br><span class="line">&quot;one-var&quot;: 1,//连续声明</span><br><span class="line">&quot;operator-assignment&quot;: [0, &quot;always&quot;],//赋值运算符 += -=什么的</span><br><span class="line">&quot;operator-linebreak&quot;: [2, &quot;after&quot;],//换行时运算符在行尾还是行首</span><br><span class="line">&quot;padded-blocks&quot;: 0,//块语句内行首行尾是否要空行</span><br><span class="line">&quot;prefer-const&quot;: 0,//首选const</span><br><span class="line">&quot;prefer-spread&quot;: 0,//首选展开运算</span><br><span class="line">&quot;prefer-reflect&quot;: 0,//首选Reflect的方法</span><br><span class="line">&quot;quotes&quot;: [1, &quot;single&quot;],//引号类型 `` &quot;&quot; &apos;&apos;</span><br><span class="line">&quot;quote-props&quot;:[2, &quot;always&quot;],//对象字面量中的属性名是否强制双引号</span><br><span class="line">&quot;radix&quot;: 2,//parseInt必须指定第二个参数</span><br><span class="line">&quot;id-match&quot;: 0,//命名检测</span><br><span class="line">&quot;require-yield&quot;: 0,//生成器函数必须有yield</span><br><span class="line">&quot;semi&quot;: [2, &quot;always&quot;],//语句强制分号结尾</span><br><span class="line">&quot;semi-spacing&quot;: [0, &#123;&quot;before&quot;: false, &quot;after&quot;: true&#125;],//分号前后空格</span><br><span class="line">&quot;sort-vars&quot;: 0,//变量声明时排序</span><br><span class="line">&quot;space-after-keywords&quot;: [0, &quot;always&quot;],//关键字后面是否要空一格</span><br><span class="line">&quot;space-before-blocks&quot;: [0, &quot;always&quot;],//不以新行开始的块&#123;前面要不要有空格</span><br><span class="line">&quot;space-before-function-paren&quot;: [0, &quot;always&quot;],//函数定义时括号前面要不要有空格</span><br><span class="line">&quot;space-in-parens&quot;: [0, &quot;never&quot;],//小括号里面要不要有空格</span><br><span class="line">&quot;space-infix-ops&quot;: 0,//中缀操作符周围要不要有空格</span><br><span class="line">&quot;space-return-throw-case&quot;: 2,//return throw case后面要不要加空格</span><br><span class="line">&quot;space-unary-ops&quot;: [0, &#123; &quot;words&quot;: true, &quot;nonwords&quot;: false &#125;],//一元运算符的前/后要不要加空格</span><br><span class="line">&quot;spaced-comment&quot;: 0,//注释风格要不要有空格什么的</span><br><span class="line">&quot;strict&quot;: 2,//使用严格模式</span><br><span class="line">&quot;use-isnan&quot;: 2,//禁止比较时使用NaN，只能用isNaN()</span><br><span class="line">&quot;valid-jsdoc&quot;: 0,//jsdoc规则</span><br><span class="line">&quot;valid-typeof&quot;: 2,//必须使用合法的typeof的值</span><br><span class="line">&quot;vars-on-top&quot;: 2,//var必须放在作用域顶部</span><br><span class="line">&quot;wrap-iife&quot;: [2, &quot;inside&quot;],//立即执行函数表达式的小括号风格</span><br><span class="line">&quot;wrap-regex&quot;: 0,//正则表达式字面量用小括号包起来</span><br><span class="line">&quot;yoda&quot;: [2, &quot;never&quot;]//禁止尤达条件</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p> <a href="https://blog.csdn.net/M_wolf/article/details/79409557" target="_blank" rel="noopener">vue-cli下ESlint 配置说明</a> 原创：<a href="https://blog.csdn.net/M_wolf" target="_blank" rel="noopener">来自星星的马</a><br> <a href="https://blog.csdn.net/IT_HLM/article/details/78776630" target="_blank" rel="noopener">ESLint在Vue中的使用详解</a>  原创：<a href="https://blog.csdn.net/IT_HLM" target="_blank" rel="noopener">老哥二娃</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>vue中修改css属性无效</title>
    <url>/2019/10/30/Vue/vue%E4%B8%AD%E4%BF%AE%E6%94%B9css%E5%B1%9E%E6%80%A7%E6%97%A0%E6%95%88/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>vue中修改css属性无效,img设置的宽度无效，p设置的颜色有效<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;           </span><br><span class="line">         &lt;carousel&gt;&lt;/carousel&gt;     </span><br><span class="line">        &lt;p&gt; 555555&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import carousel from &apos;./carousel.vue&apos;;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &quot;home&quot;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            carousel</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style rel=&quot;stylesheet/scss&quot; lang=&quot;scss&quot; scoped&gt;</span><br><span class="line"></span><br><span class="line"> img&#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">p&#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><a id="more"></a>
<h1 id="问题解决过程"><a href="#问题解决过程" class="headerlink" title="问题解决过程"></a>问题解决过程</h1><p>使用F12代码调试<br>elements页面，发现img的宽度属性没有覆盖，<strong>甚至没有出现</strong>，不是权重的问题。<br>查看sources，发现css文件里面有我编写的img宽度属性，不是scss编译的问题。</p>
<p>尝试使用其他标签选择器修改属性，发现修改p标签的属性有效，观察他们两个的区别，发现template中没有img标签，猜测可能时该css只能修改当前组件的属性。</p>
<h1 id="问题出现原因"><a href="#问题出现原因" class="headerlink" title="问题出现原因"></a>问题出现原因</h1><p>没有仔细查看官方文档,<strong>scoped</strong>表示当前style只对当前组件有效，避免组件间样式相互影响<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="问题解决方案"><a href="#问题解决方案" class="headerlink" title="问题解决方案"></a>问题解决方案</h1><ul>
<li>去除scoped</li>
<li>在对应组件修改img属性<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;a-carousel arrows&gt;</span><br><span class="line">        &lt;div</span><br><span class="line">                slot=&quot;prevArrow&quot;</span><br><span class="line">                slot-scope=&quot;props&quot;</span><br><span class="line">                class=&quot;custom-slick-arrow&quot;</span><br><span class="line">                style=&quot;left: 10px;zIndex: 1&quot;</span><br><span class="line">        &gt;</span><br><span class="line">            &lt;a-icon type=&quot;left-circle&quot; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div slot=&quot;nextArrow&quot; slot-scope=&quot;props&quot; class=&quot;custom-slick-arrow&quot; style=&quot;right: 10px&quot;&gt;</span><br><span class="line">            &lt;a-icon type=&quot;right-circle&quot; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src=&quot;https://btsstatic.oss-cn-shanghai.aliyuncs.com/official/about1.jpg&quot;&gt;&lt;/img&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src=&quot;https://btsstatic.oss-cn-shanghai.aliyuncs.com/official/about1.jpg&quot;&gt;&lt;/img&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src=&quot;https://btsstatic.oss-cn-shanghai.aliyuncs.com/official/about1.jpg&quot;&gt;&lt;/img&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src=&quot;https://btsstatic.oss-cn-shanghai.aliyuncs.com/official/about1.jpg&quot;&gt;&lt;/img&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/a-carousel&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    /*样式覆盖*/</span><br><span class="line">    img&#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    /* For demo */</span><br><span class="line">    .ant-carousel &gt;&gt;&gt; .slick-slide &#123;</span><br><span class="line">        text-align: center;</span><br><span class="line">        height: 160px;</span><br><span class="line">        line-height: 160px;</span><br><span class="line">        background: #364d79;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .ant-carousel &gt;&gt;&gt; .custom-slick-arrow &#123;</span><br><span class="line">        width: 25px;</span><br><span class="line">        height: 25px;</span><br><span class="line">        font-size: 25px;</span><br><span class="line">        color: #fff;</span><br><span class="line">        background-color: rgba(31, 45, 61, 0.11);</span><br><span class="line">        opacity: 0.3;</span><br><span class="line">    &#125;</span><br><span class="line">    .ant-carousel &gt;&gt;&gt; .custom-slick-arrow:before &#123;</span><br><span class="line">        display: none;</span><br><span class="line">    &#125;</span><br><span class="line">    .ant-carousel &gt;&gt;&gt; .custom-slick-arrow:hover &#123;</span><br><span class="line">        opacity: 0.5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .ant-carousel &gt;&gt;&gt; .slick-slide h3 &#123;</span><br><span class="line">        color: #fff;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>还是对解决问题的流程不够熟悉，导致解决问题耗费过长的时间。</p>
<ol>
<li>确认Bug是否在本地可以重现。</li>
<li>确认Bug在哪一段代码中。</li>
<li>去除掉所有无关代码，只去调试和Bug相关的代码。</li>
<li>和之前正常运行的版本对比，尝试恢复到之前可以正常运行的代码。</li>
<li>重新写一个小Demo，确认是否可以正常运行，可以的话，移动代码到原有的代码中。</li>
<li>如果本地无法重现，打日志，观察线上行为。</li>
<li>重启服务，重启IDE，重启笔记本，重启服务器。</li>
<li>跟产品经理说这个Bug解决不了，花费的代价很大，不值得。</li>
</ol>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>scss常用语法</title>
    <url>/2019/10/30/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/scss%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。</p><a id="more"></a>
<h1 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h1><p>Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#main p &#123;</span><br><span class="line">  color: #00ff00;</span><br><span class="line">  width: 97%;</span><br><span class="line"></span><br><span class="line">  .redbox &#123;</span><br><span class="line">    background-color: #ff0000;</span><br><span class="line">    color: #000000;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#main p &#123;</span><br><span class="line">  color: #00ff00;</span><br><span class="line">  width: 97%; &#125;</span><br><span class="line">  #main p .redbox &#123;</span><br><span class="line">    background-color: #ff0000;</span><br><span class="line">    color: #000000; &#125;</span><br></pre></td></tr></table></figure>
<p>嵌套功能避免了重复输入父选择器，而且令复杂的 CSS 结构更易于管理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#main &#123;</span><br><span class="line">  width: 97%;</span><br><span class="line"></span><br><span class="line">  p, div &#123;</span><br><span class="line">    font-size: 2em;</span><br><span class="line">    a &#123; font-weight: bold; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pre &#123; font-size: 3em; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#main &#123;</span><br><span class="line">  width: 97%; &#125;</span><br><span class="line">  #main p, #main div &#123;</span><br><span class="line">    font-size: 2em; &#125;</span><br><span class="line">    #main p a, #main div a &#123;</span><br><span class="line">      font-weight: bold; &#125;</span><br><span class="line">  #main pre &#123;</span><br><span class="line">    font-size: 3em; &#125;</span><br></pre></td></tr></table></figure>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>SassScript 最普遍的用法就是变量，变量以美元符号开头，赋值方法与 CSS 属性的写法一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$width: 5em;</span><br></pre></td></tr></table></figure>
<p>直接使用即调用变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#main &#123;</span><br><span class="line">  width: $width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 <code>!global</code> 声明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#main &#123;</span><br><span class="line">  $width: 5em !global;</span><br><span class="line">  width: $width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#sidebar &#123;</span><br><span class="line">  width: $width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#main &#123;</span><br><span class="line">  width: 5em;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#sidebar &#123;</span><br><span class="line">  width: 5em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="继承-extend"><a href="#继承-extend" class="headerlink" title="继承@extend"></a>继承@extend</h1><p>在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。通常会在 HTML 中给元素定义两个 class，一个通用样式，一个特殊样式。假设现在要设计一个普通错误样式与一个严重错误样式，一般会这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;error seriousError&quot;&gt;</span><br><span class="line">  Oh no! You&apos;ve been hacked!</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>样式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.error &#123;</span><br><span class="line">  border: 1px #f00;</span><br><span class="line">  background-color: #fdd;</span><br><span class="line">&#125;</span><br><span class="line">.seriousError &#123;</span><br><span class="line">  border-width: 3px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>麻烦的是，这样做必须时刻记住使用 <code>.seriousError</code> 时需要参考 <code>.error</code> 的样式，带来了很多不变：智能比如加重维护负担，导致 bug，或者给 HTML 添加无语意的样式。使用 <code>@extend</code> 可以避免上述情况，告诉 Sass 将一个选择器下的所有样式继承给另一个选择器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.error &#123;</span><br><span class="line">  border: 1px #f00;</span><br><span class="line">  background-color: #fdd;</span><br><span class="line">&#125;</span><br><span class="line">.seriousError &#123;</span><br><span class="line">  @extend .error;</span><br><span class="line">  border-width: 3px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的意思是将 <code>.error</code> 下的所有样式继承给 <code>.seriousError</code>，<code>border-width: 3px;</code> 是单独给 <code>.seriousError</code> 设定特殊样式，这样，使用 <code>.seriousError</code> 的地方可以不再使用 <code>.error</code>。</p>
<p>其他使用到 <code>.error</code> 的样式也会同样继承给 <code>.seriousError</code>，例如，另一个样式 <code>.error.intrusion</code> 使用了 <code>hacked.png</code> 做背景，<code>&lt;div class=&quot;seriousError intrusion&quot;&gt;</code> 也同样会使用 <code>hacked.png</code> 背景。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.error.intrusion &#123;</span><br><span class="line">  background-image: url(&quot;/image/hacked.png&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.sass.hk/docs/" target="_blank" rel="noopener">sass中文文档</a></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title>路径中“./”、“../”、“/”代表的含义</title>
    <url>/2019/10/28/JS/%E8%B7%AF%E5%BE%84%E4%B8%AD%E2%80%9C-%E2%80%9D%E3%80%81%E2%80%9C-%E2%80%9D%E3%80%81%E2%80%9C-%E2%80%9D%E4%BB%A3%E8%A1%A8%E7%9A%84%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<p>经常用到./和../及/路径访问指定的资源，但三者有什么区别呢？</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul>
<li>“./“：代表目前所在的目录。</li>
<li>“ . ./“：代表上一层目录。</li>
<li>“/“：代表根目录。</li>
</ul>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>在读取文件时,路径的写法有如下方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Mat Image = imread(&quot;./图片.jpg&quot;);//文件在当前目录</span><br><span class="line">imshow(&quot;Test&quot;, Image);</span><br><span class="line"></span><br><span class="line">Mat Image1 = imread(&quot;../图片.jpg&quot;);//文件在上一层目录下</span><br><span class="line">imshow(&quot;Test1&quot;, Image1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mat Image2 = imread(&quot;./Image1/图片.jpg&quot;);//文件在下一层目录(Image1文件夹)</span><br><span class="line">imshow(&quot;Test2&quot;, Image2);</span><br><span class="line"></span><br><span class="line">Mat Image3 = imread(&quot;../../图片.jpg&quot;); //文件在上上层目录下</span><br><span class="line">imshow(&quot;Test3&quot;, Image3);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>Webpack4建造Vue项目</title>
    <url>/2019/10/28/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Webpack4%E5%BB%BA%E9%80%A0Vue%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章除前言以及后记部分之外均为转载，转载文章发布于<strong>2018-08-22</strong>，所以关于依赖和插件的配置</p><p>方法部分有些过时，所以正文内容仅供参考，大家多多查看对应插件的官方文档。</p><p><strong>我会在后记部分贴出自己配置的vue项目作为参考。</strong></p><h1 id="项目建设"><a href="#项目建设" class="headerlink" title="项目建设"></a><strong>项目建设</strong></h1><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>创建createVue文件夹，进入该文件夹，<code>npm init</code>初始化项目</p><a id="more"></a>



<h2 id="安装webpack四件套"><a href="#安装webpack四件套" class="headerlink" title="安装webpack四件套"></a>安装webpack四件套</h2><p><code>npm i webpack webpack-cli webpack-dev-server webpack-merge --save-dev</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 当前我使用版本</span><br><span class="line">&quot;webpack&quot;: &quot;^4.16.3&quot;,</span><br><span class="line">&quot;webpack-cli&quot;: &quot;^3.1.0&quot;,</span><br><span class="line">&quot;webpack-dev-server&quot;: &quot;^3.1.5&quot;, // 开发服务器</span><br><span class="line">&quot;webpack-merge&quot;: &quot;^4.1.4&quot; // webpack 配置合并</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="创建相应文件"><a href="#创建相应文件" class="headerlink" title="创建相应文件"></a>创建相应文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">createVue</span><br><span class="line">  |--dist</span><br><span class="line">  |--build</span><br><span class="line">      |--webpack.prod.js</span><br><span class="line">      |--webpack.dev.js</span><br><span class="line">      |--webpack.base.js</span><br><span class="line">  |--src</span><br><span class="line">      |--index.js</span><br><span class="line">      |--app.vue</span><br><span class="line">  |--index.html</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.base.js</span><br><span class="line">// 存放 dev 和 prod 通用配置</span><br><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;, //入口</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: []</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    // 解决vender后面的hash每次都改变</span><br><span class="line">    new webpack.HashedModuleIdsPlugin(),</span><br><span class="line">  ],// 插件</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.dev.js</span><br><span class="line">// 存放 dev 配置</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;);</span><br><span class="line">const common = require(&apos;./webpack.base.js&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = merge(common, &#123;</span><br><span class="line">  devtool: &apos;inline-source-map&apos;,</span><br><span class="line">  devServer: &#123; // 开发服务器</span><br><span class="line">    contentBase: &apos;../dist&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123; // 输出</span><br><span class="line">    filename: &apos;js/[name].[hash].js&apos;, // 每次保存 hash 都变化</span><br><span class="line">    path: path.resolve(__dirname, &apos;../dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;&#125;,</span><br><span class="line">  mode: &apos;development&apos;,</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.prod.js</span><br><span class="line">// 存放 prod 配置</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">// 合并配置文件</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;);</span><br><span class="line">const common = require(&apos;./webpack.base.js&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = merge(common, &#123;</span><br><span class="line">  module: &#123;&#125;,</span><br><span class="line">  plugins: [],</span><br><span class="line">  mode: &apos;production&apos;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;js/[name].[contenthash].js&apos;, //contenthash 若文件内容无变化，则contenthash 名称不变</span><br><span class="line">    path: path.resolve(__dirname, &apos;../dist&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>webpack4增加了mode属性，设置为开发/生产，以下为替代配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">development:</span><br><span class="line"></span><br><span class="line">process.env.NODE_ENV 的值设为 development</span><br><span class="line">默认开启以下插件，充分利用了持久化缓存。参考基于 webpack 的持久化缓存方案</span><br><span class="line"></span><br><span class="line">NamedChunksPlugin ：以名称固化 chunk id</span><br><span class="line">NamedModulesPlugin ：以名称固化 module id</span><br><span class="line"></span><br><span class="line">production:</span><br><span class="line"></span><br><span class="line">process.env.NODE_ENV 的值设为 production</span><br><span class="line">默认开启以下插件，其中 SideEffectsFlagPlugin 和 UglifyJsPlugin 用于 tree-shaking</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FlagDependencyUsagePlugin ：编译时标记依赖</span><br><span class="line">FlagIncludedChunksPlugin ：标记子chunks，防子chunks多次加载</span><br><span class="line">ModuleConcatenationPlugin ：作用域提升(scope hosting),预编译功能,提升或者预编译所有模块到一个闭包中，提升代码在浏览器中的执行速度</span><br><span class="line">NoEmitOnErrorsPlugin ：在输出阶段时，遇到编译错误跳过</span><br><span class="line">OccurrenceOrderPlugin ：给经常使用的ids更短的值</span><br><span class="line">SideEffectsFlagPlugin ：识别 package.json 或者 module.rules 的 sideEffects 标志（纯的 ES2015 模块)，安全地删除未用到的 export 导出</span><br><span class="line">UglifyJsPlugin ：删除未引用代码，并压缩</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// index.js</span><br><span class="line">// 需 npm i vue --save</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import App from &apos;./App.vue&apos;</span><br><span class="line">import &apos;./index.scss&apos;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- app.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    hello world</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;app&apos;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">  transform: rotate(0deg);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- index.html --&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Suporka Vue App&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="安装vue核心解析插件"><a href="#安装vue核心解析插件" class="headerlink" title="安装vue核心解析插件"></a>安装vue核心解析插件</h2><p><code>npm i vue-loader vue-template-compiler --save-dev</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 当前我使用版本</span><br><span class="line">&quot;vue-loader&quot;: &quot;^15.2.6&quot;,</span><br><span class="line">&quot;vue-template-compiler&quot;: &quot;^2.5.17&quot;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>由于vue的解析在dev和prod中均需使用，因此归入基本配置base</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.base.js</span><br><span class="line"></span><br><span class="line">// ...省略号</span><br><span class="line">// vue-loader 插件</span><br><span class="line">const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  //...省略号</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.vue$/,</span><br><span class="line">        loader: &apos;vue-loader&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    // 请确保引入这个插件来施展魔法</span><br><span class="line">    new VueLoaderPlugin(),</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="安装html模板解析插件"><a href="#安装html模板解析插件" class="headerlink" title="安装html模板解析插件"></a>安装html模板解析插件</h2><p><code>npm i html-webpack-plugin --save-dev</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 当前版本 </span><br><span class="line">&quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>html解析也属于基本配置，归入base</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.base.js</span><br><span class="line"></span><br><span class="line">// ...省略号</span><br><span class="line">// html插件</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  //...省略号</span><br><span class="line">  plugins: [</span><br><span class="line">    //...省略号</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: path.resolve(__dirname, &apos;../index.html&apos;),</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="创建npm命令"><a href="#创建npm命令" class="headerlink" title="创建npm命令"></a>创建npm命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;webpack-dev-server --hot --open --config build/webpack.dev.js&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;webpack --config build/webpack.prod.js&quot;</span><br><span class="line">&#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>–hot模块热替换</p>
<p>–open开启本地服务器</p>
<p>此时<code>npm start</code>，项目可正常运行</p>
<h1 id="功能拓展"><a href="#功能拓展" class="headerlink" title="功能拓展"></a>功能拓展</h1><h2 id="添加loader"><a href="#添加loader" class="headerlink" title="添加loader"></a>添加loader</h2><ul>
<li>CSS loader（包括前处理和后处理）</li>
</ul>
<p>CSS基础加载器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;css-loader&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">&quot;style-loader&quot;: &quot;^0.21.0&quot;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>CSS前处理less两件套</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;less&quot;: &quot;^3.8.0&quot;,</span><br><span class="line">&quot;less-loader&quot;: &quot;^4.1.0&quot;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>CSS前处理sass两件套</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;node-sass&quot;: &quot;^4.9.2&quot;,</span><br><span class="line">&quot;sass-loader&quot;: &quot;^7.1.0&quot;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>CSS后处理postcss两件套</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;postcss-loader&quot;: &quot;^2.1.6&quot;,</span><br><span class="line">&quot;autoprefixer&quot;: &quot;^9.1.0&quot;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>并在根文件夹创建postcss.config.js文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// postcss.config.js</span><br><span class="line">// 自动添加css兼容属性</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    require(&apos;autoprefixer&apos;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>安装以上依赖，在base文件中加入一下loader代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.base.js</span><br><span class="line"></span><br><span class="line">// ...省略号</span><br><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: /\.(sa|sc|c)ss$/,</span><br><span class="line">    use: [</span><br><span class="line">      &apos;style-loader&apos;,</span><br><span class="line">      &apos;css-loader&apos;,</span><br><span class="line">      &apos;postcss-loader&apos;,</span><br><span class="line">      &apos;sass-loader&apos;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    test: /\.less$/,</span><br><span class="line">    use: [</span><br><span class="line">      &apos;style-loader&apos;,</span><br><span class="line">      &apos;css-loader&apos;,</span><br><span class="line">      &apos;postcss-loader&apos;,</span><br><span class="line">      &apos;less-loader&apos;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="图片装载机"><a href="#图片装载机" class="headerlink" title="图片装载机"></a>图片装载机</h2><p>解析图片，字体等都是用file-loader，安装<code>npm i file-loader --save-dev</code></p>
<p>基本文件加入配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.base.js</span><br><span class="line"></span><br><span class="line">// ...省略号</span><br><span class="line">rules: [</span><br><span class="line">  // ...省略号</span><br><span class="line">  &#123;</span><br><span class="line">    test: /\.(png|svg|jpg|gif)$/,</span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: &apos;file-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 5000,</span><br><span class="line">          // 分离图片至imgs文件夹</span><br><span class="line">          name: &quot;imgs/[name].[ext]&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h1 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h1><h2 id="打包时清除dist文件夹"><a href="#打包时清除dist文件夹" class="headerlink" title="打包时清除dist文件夹"></a>打包时清除dist文件夹</h2><p>解决每次重新打包，dist文件夹文件未清除</p>
<p>安装clean-webpack-plugin插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.prod.js</span><br><span class="line"></span><br><span class="line">// 打包之前清除文件</span><br><span class="line">const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line">// ...省略号</span><br><span class="line">plugins: [</span><br><span class="line">  new CleanWebpackPlugin([&apos;dist/*&apos;], &#123;</span><br><span class="line">    root: path.resolve(__dirname, &apos;../&apos;)</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="分离CSS"><a href="#分离CSS" class="headerlink" title="分离CSS"></a>分离CSS</h2><p>webpack4中使用mini-css-extract-plugin插件来分离css。</p>
<p>安装mini-css-extract-plugin插件后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.prod.js</span><br><span class="line"></span><br><span class="line">// 分离CSS插件</span><br><span class="line">const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);</span><br><span class="line">// ...省略号</span><br><span class="line">plugins: [</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">    filename: &quot;css/[name].[hash].css&quot;,</span><br><span class="line">    chunkFilename: &apos;css/[id].[hash].css&apos;</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>另外，还需将各个css loader中的style-loader替换为MiniCssExtractPlugin</p>
<h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><p>图片压缩使用<code>image-webpack-loader</code>，安装后代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.prod.js</span><br><span class="line">// ...省略号</span><br><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: /\.(sa|sc|c)ss$/,</span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: MiniCssExtractPlugin.loader,</span><br><span class="line">        options: &#123;</span><br><span class="line">          // you can specify a publicPath here</span><br><span class="line">          // by default it use publicPath in webpackOptions.output</span><br><span class="line">          publicPath: &apos;../&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &apos;css-loader&apos;,</span><br><span class="line">      &apos;postcss-loader&apos;,</span><br><span class="line">      &apos;sass-loader&apos;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    test: /\.less$/,</span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: MiniCssExtractPlugin.loader,</span><br><span class="line">        options: &#123;</span><br><span class="line">          // you can specify a publicPath here</span><br><span class="line">          // by default it use publicPath in webpackOptions.output</span><br><span class="line">          publicPath: &apos;../&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &apos;css-loader&apos;,</span><br><span class="line">      &apos;postcss-loader&apos;,</span><br><span class="line">      &apos;less-loader&apos;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    test: /\.(png|svg|jpg|gif)$/,</span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: &apos;file-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 5000,</span><br><span class="line">          name: &quot;imgs/[hash].[ext]&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      // 图片压缩</span><br><span class="line">      &#123;</span><br><span class="line">        loader: &apos;image-webpack-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          //   bypassOnDebug: true,</span><br><span class="line">          mozjpeg: &#123;</span><br><span class="line">            progressive: true,</span><br><span class="line">            quality: 65</span><br><span class="line">          &#125;,</span><br><span class="line">          optipng: &#123;</span><br><span class="line">            enabled: false,</span><br><span class="line">          &#125;,</span><br><span class="line">          pngquant: &#123;</span><br><span class="line">            quality: &apos;65-90&apos;,</span><br><span class="line">            speed: 4</span><br><span class="line">          &#125;,</span><br><span class="line">          gifsicle: &#123;</span><br><span class="line">            interlaced: false,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="压缩CSS和JS代码"><a href="#压缩CSS和JS代码" class="headerlink" title="压缩CSS和JS代码"></a>压缩CSS和JS代码</h2><p>安装Optimiz-css-assets-webpack-plugin和uglifyjs-webpack-plugin插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// webpack.prod.js</span><br><span class="line">// 压缩CSS和JS代码</span><br><span class="line">// ...省略号</span><br><span class="line">const OptimizeCSSAssetsPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;);</span><br><span class="line">const UglifyJsPlugin = require(&quot;uglifyjs-webpack-plugin&quot;);</span><br><span class="line">module.exports = merge(common, &#123;</span><br><span class="line">  // ...省略号</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    // ...省略号</span><br><span class="line">    minimizer: [</span><br><span class="line">      // 压缩JS</span><br><span class="line">      new UglifyJsPlugin(&#123;</span><br><span class="line">        uglifyOptions: &#123;</span><br><span class="line">          compress: &#123;</span><br><span class="line">            warnings: false, // 去除警告</span><br><span class="line">            drop_debugger: true, // 去除debugger</span><br><span class="line">            drop_console: true // 去除console.log</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        cache: true, // 开启缓存</span><br><span class="line">        parallel: true, // 平行压缩</span><br><span class="line">        sourceMap: false // set to true if you want JS source maps</span><br><span class="line">      &#125;),</span><br><span class="line">      // 压缩css</span><br><span class="line">      new OptimizeCSSAssetsPlugin(&#123;&#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><h2 id="查看项目源码"><a href="#查看项目源码" class="headerlink" title="查看项目源码"></a>查看项目源码</h2><p><a href="https://github.com/tianxintiandisheng/webpak4-Build-the-vue-project" target="_blank" rel="noopener">Webpack4建造Vue项目源码</a></p>
<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;meijia&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;webpack-dev-server --hot --open --config build/webpack.dev.js&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack --config build/webpack.prod.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;repository&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;git+https://github.com/tianxintiandisheng/MeiJia.git&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;bugs&quot;: &#123;</span><br><span class="line">    &quot;url&quot;: &quot;https://github.com/tianxintiandisheng/MeiJia/issues&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;homepage&quot;: &quot;https://github.com/tianxintiandisheng/MeiJia#readme&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;@babel/core&quot;: &quot;^7.6.4&quot;,</span><br><span class="line">    &quot;@babel/preset-env&quot;: &quot;^7.6.3&quot;,</span><br><span class="line">    &quot;autoprefixer&quot;: &quot;^9.7.0&quot;,</span><br><span class="line">    &quot;babel-loader&quot;: &quot;^8.0.6&quot;,</span><br><span class="line">    &quot;clean-webpack-plugin&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;css-loader&quot;: &quot;^3.2.0&quot;,</span><br><span class="line">    &quot;fibers&quot;: &quot;^4.0.2&quot;,</span><br><span class="line">    &quot;file-loader&quot;: &quot;^4.2.0&quot;,</span><br><span class="line">    &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;,</span><br><span class="line">    &quot;image-webpack-loader&quot;: &quot;^6.0.0&quot;,</span><br><span class="line">    &quot;mini-css-extract-plugin&quot;: &quot;^0.8.0&quot;,</span><br><span class="line">    &quot;node-sass&quot;: &quot;^4.13.0&quot;,</span><br><span class="line">    &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^5.0.3&quot;,</span><br><span class="line">    &quot;postcss-loader&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;sass&quot;: &quot;^1.3.0&quot;,</span><br><span class="line">    &quot;sass-loader&quot;: &quot;^8.0.0&quot;,</span><br><span class="line">    &quot;style-loader&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">    &quot;uglifyjs-webpack-plugin&quot;: &quot;^2.2.0&quot;,</span><br><span class="line">    &quot;vue&quot;: &quot;^2.6.10&quot;,</span><br><span class="line">    &quot;vue-loader&quot;: &quot;^15.7.1&quot;,</span><br><span class="line">    &quot;vue-router&quot;: &quot;^3.1.3&quot;,</span><br><span class="line">    &quot;vue-template-compiler&quot;: &quot;^2.6.10&quot;,</span><br><span class="line">    &quot;webpack&quot;: &quot;^4.41.2&quot;,</span><br><span class="line">    &quot;webpack-cli&quot;: &quot;^3.3.9&quot;,</span><br><span class="line">    &quot;webpack-dev-server&quot;: &quot;^3.9.0&quot;,</span><br><span class="line">    &quot;webpack-merge&quot;: &quot;^4.2.2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://juejin.im/post/5b7d350951882542f3278b11" target="_blank" rel="noopener">Webpack4建造Vue项目</a></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title>webpack中使用预处理器postcss-loader和后处理程序autoprefixer处理css解决浏览器兼容问题</title>
    <url>/2019/10/27/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/webpack%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8postcss-loader%E5%92%8C%E5%90%8E%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8Fautoprefixer%E5%A4%84%E7%90%86css%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>在 Web 应用开发中，CSS 代码的编写是重要的一部分。CSS 规范从最初的 CSS1 到现在的 CSS3，再到 CSS 规范的下一步版本，规范本身一直在不断的发展演化之中。这给开发人员带来了效率上的提高。不过与其他 Web 领域的规范相似的处境是，CSS 规范在浏览器兼容性方面一直存在各种各样的问题。不同浏览器在 CSS 规范的实现方面的进度也存在很大差异。另外，CSS 规范本身的发展速度与社区的期待还有一定的差距。这也是为什么 SASS 和 LESS 等 CSS 预处理语言可以流行的重要原因。SASS 和 LESS 等提供了很多更实用的功能，也体现了开发人员对 CSS 语言的需求。本文中要介绍的 PostCSS 和autoprefixer是目前流行的对 CSS 进行处理的工具。</p><a id="more"></a>
<h1 id="预处理器postcss-loader"><a href="#预处理器postcss-loader" class="headerlink" title="预处理器postcss-loader"></a>预处理器postcss-loader</h1><p>PostCSS 本身是一个功能比较单一的工具。它提供了一种方式用 JavaScript 代码来处理 CSS。它负责把 CSS 代码解析成抽象语法树结构（Abstract Syntax Tree，AST），再交由插件来进行处理。插件基于 CSS 代码的 AST 所能进行的操作是多种多样的，比如可以支持变量和混入（mixin），增加浏览器相关的声明前缀，或是把使用将来的 CSS 规范的样式规则转译（transpile）成当前的 CSS 规范支持的格式。从这个角度来说，PostCSS 的强大之处在于其不断发展的插件体系。目前 PostCSS 已经有 200 多个功能各异的插件。开发人员也可以根据项目的需要，开发出自己的 PostCSS 插件。 </p>
<h1 id="AutoPrefixer后处理程序"><a href="#AutoPrefixer后处理程序" class="headerlink" title="AutoPrefixer后处理程序"></a>AutoPrefixer后处理程序</h1><p>Autoprefixer是一个后处理程序，你可以同Sass，Stylus或LESS等预处理器共通使用。它适用于普通的CSS，而你无需关心要为哪些浏览器加前缀，只需全新关注于实现，并使用W3C最新的规范。 </p>
<h1 id="webpack中使用-PostCSS"><a href="#webpack中使用-PostCSS" class="headerlink" title="webpack中使用 PostCSS"></a>webpack中使用 PostCSS</h1><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D postcss-loader autoprefixer</span><br></pre></td></tr></table></figure>
<h2 id="根文件夹创建postcss-config-js文件"><a href="#根文件夹创建postcss-config-js文件" class="headerlink" title="根文件夹创建postcss.config.js文件"></a>根文件夹创建postcss.config.js文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    require(&apos;autoprefixer&apos;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="webpack-config-js-添加规则"><a href="#webpack-config-js-添加规则" class="headerlink" title="webpack.config.js 添加规则"></a><strong>webpack.config.js</strong> 添加规则</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line"> </span><br><span class="line">    rules: [</span><br><span class="line">     //添加此部分，起始</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [ &apos;style-loader&apos;, &apos;postcss-loader&apos; ]</span><br><span class="line">      &#125;</span><br><span class="line">     //添加此部分，结束 </span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意： </p>
<ul>
<li>需要安装style-loader</li>
<li>复制粘贴时去掉注释</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/postcss/postcss-loader" target="_blank" rel="noopener">postcss官方文档</a></p>
<p><a href="https://github.com/postcss/autoprefixer" target="_blank" rel="noopener">AutoPrefixer官方使用说明</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/web/1604-postcss-css/index.html" target="_blank" rel="noopener">使用 PostCSS 进行 CSS 处理</a></p>
<p><a href="https://www.jianshu.com/p/f5b0b92e6b0f" target="_blank" rel="noopener">AutoPrefixer</a></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title>npm常用命令</title>
    <url>/2019/10/26/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="npm初始化"><a href="#npm初始化" class="headerlink" title="npm初始化"></a>npm初始化</h1><p>初始化一个基于node的项目，会创建一个配置文件package.json（两种方式）:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//1.一般情况下 一路enter</span><br><span class="line">$ npm init</span><br><span class="line"></span><br><span class="line">//2.全部使用默认配置</span><br><span class="line">$npm init --yes</span><br></pre></td></tr></table></figure><h1 id="查看npm命令"><a href="#查看npm命令" class="headerlink" title="查看npm命令"></a>查看npm命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm help</span><br></pre></td></tr></table></figure><h1 id="安装模块（包）"><a href="#安装模块（包）" class="headerlink" title="安装模块（包）"></a>安装模块（包）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//全局安装</span><br><span class="line">$ npm install 模块名 -g</span><br><span class="line">//本地安装</span><br><span class="line">$ npm install 模块名</span><br><span class="line">//一次性安装多个</span><br><span class="line">$ npm install 模块1 模块2 模块n --save</span><br><span class="line"></span><br><span class="line">//安装运行时依赖包</span><br><span class="line">$ npm install 模块名 --save</span><br><span class="line">//安装开发时依赖包</span><br><span class="line">$ npm install 模块名 --save-dev</span><br></pre></td></tr></table></figure><a id="more"></a>



<h2 id="–save-与-–save-dev的区别"><a href="#–save-与-–save-dev的区别" class="headerlink" title="–save 与 –save-dev的区别"></a>–save 与 –save-dev的区别</h2><p>添加模块名到<code>package.json</code>中的 <code>dependencies</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install &lt;package_name&gt; --save</span><br></pre></td></tr></table></figure>
<p>添加模块名到 <code>package.json</code>中的<code>devDependencies</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install &lt;package_name&gt; --save-dev</span><br></pre></td></tr></table></figure>
<h1 id="查看安装目录"><a href="#查看安装目录" class="headerlink" title="查看安装目录"></a>查看安装目录</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//查看本地安装的目录</span><br><span class="line">$ npm root</span><br><span class="line"></span><br><span class="line">//查看全局安装的目录</span><br><span class="line">$ npm root -g</span><br></pre></td></tr></table></figure>
<h1 id="卸载模块（包）"><a href="#卸载模块（包）" class="headerlink" title="卸载模块（包）"></a>卸载模块（包）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//卸载本地模块</span><br><span class="line">$ npm uninstall 模块名</span><br><span class="line"></span><br><span class="line">//卸载全局模块</span><br><span class="line">$ npm uninstall -g 模块名</span><br></pre></td></tr></table></figure>
<h1 id="更新模块（包）"><a href="#更新模块（包）" class="headerlink" title="更新模块（包）"></a>更新模块（包）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm update 模块名</span><br><span class="line"></span><br><span class="line">$ npm update 模块名 -g</span><br></pre></td></tr></table></figure>
<h1 id="查看当前安装的模块（包）"><a href="#查看当前安装的模块（包）" class="headerlink" title="查看当前安装的模块（包）"></a>查看当前安装的模块（包）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm ls</span><br><span class="line"></span><br><span class="line">$ npm ls -g</span><br></pre></td></tr></table></figure>
<h1 id="查看模块（包）的信息"><a href="#查看模块（包）的信息" class="headerlink" title="查看模块（包）的信息"></a>查看模块（包）的信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm info 模块名</span><br></pre></td></tr></table></figure>
<h1 id="配置命令与执行"><a href="#配置命令与执行" class="headerlink" title="配置命令与执行"></a>配置命令与执行</h1><p>package.json中scripts配置可执行的命令，以 键值对 的方式配置，可配置多个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;script&quot;: &#123;</span><br><span class="line">    &quot;命令&quot;: &quot;执行代码&quot;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行配置的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//必须加run</span><br><span class="line">$ npm run 命令</span><br><span class="line"></span><br><span class="line">//特殊的命令 start 可不加run</span><br><span class="line">$ npm start </span><br><span class="line">或</span><br><span class="line">$ npm run start</span><br></pre></td></tr></table></figure>
<h1 id="package-json文件的配置说明"><a href="#package-json文件的配置说明" class="headerlink" title="package.json文件的配置说明"></a>package.json文件的配置说明</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;blog&quot;,  //项目名称</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,   //版本</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,   //项目描述</span><br><span class="line">  &quot;private&quot;: true,  </span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,  //入口文件</span><br><span class="line">  &quot;scripts&quot;: &#123;   //配置一些通用的命令脚本</span><br><span class="line">    &quot;start&quot;: &quot;node ./bin/www&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [],  //项目的关键字</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,  //作者</span><br><span class="line">  &quot;dependencies&quot;: &#123;   //开发时的依赖</span><br><span class="line">    &quot;body-parser&quot;: &quot;~1.16.0&quot;,</span><br><span class="line">    &quot;cookie-parser&quot;: &quot;~1.4.3&quot;,</span><br><span class="line">    &quot;debug&quot;: &quot;~2.6.0&quot;,</span><br><span class="line">    &quot;ejs&quot;: &quot;~2.5.5&quot;,</span><br><span class="line">    &quot;express&quot;: &quot;~4.14.1&quot;,</span><br><span class="line">    &quot;morgan&quot;: &quot;~1.7.0&quot;,</span><br><span class="line">    &quot;serve-favicon&quot;: &quot;~2.3.2&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;   //运行时的依赖</span><br><span class="line">    &quot;express-session&quot;: &quot;^1.15.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/087d839e1d0c" target="_blank" rel="noopener">https://www.jianshu.com/p/087d839e1d0c</a><br><a href="https://www.npmjs.cn/getting-started/using-a-package.json/" target="_blank" rel="noopener">https://www.npmjs.cn/getting-started/using-a-package.json/</a></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title>npm删除全部依赖node_modules目录</title>
    <url>/2019/10/26/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/npm%E5%88%A0%E9%99%A4%E5%85%A8%E9%83%A8%E4%BE%9D%E8%B5%96node-modules%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>作为一名前端开发工程师，是否有这样的困扰呢？经常npm操作报错，或者运行ERROR，需要删除node_modules目录下的所有文件，然后重新安装cnpm install，但是每次去那个目录下移到回车站需要5分钟到10分钟，然后清空回收站大概也需要2、3分钟，时间就在这漫长的清除文件的进度条移动中流逝。</p><a id="more"></a>
<p>而且，慢点也无所谓，等吧，咱也不是啥急性子的人。但是最不能容忍的就是，每次删除node_modules目录下的文件夹，还经常需要权限，然后点击同意，居然还是删除失败。然后就是用笨笨的方法，去每个文件夹下面删除内容文件夹，然后就可以删除外部文件夹了，删完后一脸的懵逼……</p>
<p>但是，但是，万能的互联网，还有各位喜欢分享的各位前辈，已经早就找到了方法：</p>
<p>1.安装npm包–rimraf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install rimraf -g</span><br></pre></td></tr></table></figure>
<p>2.在cmd指令下，进入所需删除的node_modules文件夹的位置，再输入指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rimraf node_modules</span><br></pre></td></tr></table></figure>
<p>3.简单粗暴得秒删完成</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title>Git忽略文件.gitignore的使用</title>
    <url>/2019/10/26/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Git%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6-gitignore%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="1-为什么要忽略添加"><a href="#1-为什么要忽略添加" class="headerlink" title="1.为什么要忽略添加?"></a>1.为什么要忽略添加?</h2><p>当你使用<code>git add .</code>的时候有没有遇到把你不想提交的文件也添加到了缓存中去？比如项目的本地配置信息，如果你上传到Git中去其他人pull下来的时候就会和他本地的配置有冲突，所以这样的个性化配置文件我们一般不把它推送到git服务器中，但是又为了偷懒每次添加缓存的时候都想用<code>git add .</code>而不是手动一个一个文件添加，该怎么办呢？很简单，git为我们提供了一个.gitignore文件只要在这个文件中申明那些文件你不希望添加到git中去，这样当你使用<code>git add .</code>的时候这些文件就会被自动忽略掉。</p><a id="more"></a>
<h2 id="2-忽略文件的原则"><a href="#2-忽略文件的原则" class="headerlink" title="2.忽略文件的原则"></a>2.忽略文件的原则</h2><ul>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ul>
<h2 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3.使用方法"></a>3.使用方法</h2><p>首先，在你的工作区新建一个名称为<code>.gitignore</code>的文件。<br> 然后，把要忽略的文件名填进去，Git就会自动忽略这些文件。<br> 不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://link.jianshu.com?t=https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p>
<h2 id="4-例子"><a href="#4-例子" class="headerlink" title="4.例子"></a>4.例子</h2><p>比如你的项目是java项目，<code>.java</code>文件编译后会生成<code>.class</code>文件，这些文件多数情况下是不想被传到仓库中的文件。这时候你可以直接适用github的.gitignore文件模板。<a href="https://link.jianshu.com?t=https://github.com/github/gitignore/blob/master/Java.gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore/blob/master/Java.gitignore</a> 将这些忽略文件信息复制到你的.gitignore文件中去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.ear</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br></pre></td></tr></table></figure>
<p>可以看到github为我们提供了最流行的.gitignore文件配置。<br> 保存.ignore文件后我们查看下git status，检查下是否还有我们不需要的文件会被添加到git中去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   .gitignore</span><br><span class="line">        new file:   HelloWorld.java</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        Config.ini</span><br></pre></td></tr></table></figure>
<p>比如我的项目目录下有一个Config.ini文件，这个是个本地配置文件我不希望上传到git中去，我们可以在gitignore文件中添加这样的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Config.ini</span><br></pre></td></tr></table></figure>
<p>或者你想忽略所有的.ini文件你可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*.ini</span><br></pre></td></tr></table></figure>
<p>如果有些文件已经被你忽略了，当你使用<code>git add</code>时是无法添加的，比如我忽略了<code>*.class</code>，现在我想把<code>HelloWorld.class</code>添加到git中去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add HelloWorld.class</span><br><span class="line">The following paths are ignored by one of your .gitignore files:</span><br><span class="line">HelloWorld.class</span><br><span class="line">Use -f if you really want to add them.</span><br></pre></td></tr></table></figure>
<p>git会提示我们这个文件已经被我们忽略了，需要加上<code>-f</code>参数才能强制添加到git中去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   .gitignore</span><br><span class="line">        new file:   HelloWorld.class</span><br><span class="line">        new file:   HelloWorld.java</span><br></pre></td></tr></table></figure>
<p>这样就能强制添加到缓存中去了。<br> 如果我们意外的将想要忽略的文件添加到缓存中去了，我们可以使用<code>rm</code>命令将其从中移除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm HelloWorld.class --cached</span><br><span class="line">rm &apos;HelloWorld.class&apos;</span><br></pre></td></tr></table></figure>
<p>如果你已经把不想上传的文件上传到了git仓库，那么你必须先从远程仓库删了它，我们可以从远程仓库直接删除然后pull代码到本地仓库这些文件就会本删除，或者从本地删除这些文件并且在.gitignore文件中添加这些你想忽略的文件，然后再push到远程仓库。</p>
<h2 id="5-查看gitignore规则"><a href="#5-查看gitignore规则" class="headerlink" title="5.查看gitignore规则"></a>5.查看gitignore规则</h2><p>如果你发下<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git check-ignore -v HelloWorld.class</span><br><span class="line">.gitignore:1:*.class    HelloWorld.class</span><br></pre></td></tr></table></figure>
<p>可以看到<code>HelloWorld.class</code>匹配到了我们的第一条<code>*.class</code>的忽略规则所以文件被忽略了。</p>
<h2 id="6-忽略规则文件语法"><a href="#6-忽略规则文件语法" class="headerlink" title="6.忽略规则文件语法"></a>6.忽略规则文件语法</h2><h3 id="a-忽略指定文件-目录"><a href="#a-忽略指定文件-目录" class="headerlink" title="a.忽略指定文件/目录"></a>a.忽略指定文件/目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 忽略指定文件</span><br><span class="line">HelloWrold.class</span><br><span class="line"></span><br><span class="line"># 忽略指定文件夹</span><br><span class="line">bin/</span><br><span class="line">bin/gen/</span><br></pre></td></tr></table></figure>
<h3 id="b-通配符忽略规则"><a href="#b-通配符忽略规则" class="headerlink" title="b.通配符忽略规则"></a>b.通配符忽略规则</h3><p>通配符规则如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 忽略.class的所有文件</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># 忽略名称中末尾为ignore的文件夹</span><br><span class="line">*ignore/</span><br><span class="line"></span><br><span class="line"># 忽略名称中间包含ignore的文件夹</span><br><span class="line">*ignore*/</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p> <a href="https://www.jianshu.com/p/a09a9b40ad20" target="_blank" rel="noopener">https://www.jianshu.com/p/a09a9b40ad20</a></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title>雨中冒险2（Risk of Rain 2）游戏攻略</title>
    <url>/2019/10/25/%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/%E9%9B%A8%E4%B8%AD%E5%86%92%E9%99%A92%EF%BC%88Risk-of-Rain-2%EF%BC%89%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>雨中冒险risk of rain一款Roguelike的横版动作游戏，初始只有1个职业——突击队员（Commando），画风为点阵像素风格，但不影响其游戏性。</p><p>这款游戏无论在道具上还是怪物种类方面，都有着极其丰富的种类。与大部分roguelike游戏类似，打怪或开宝箱所获得的道具，遇到的BOSS，都有着很高的随机性。玩这类<a href="https://baike.baidu.com/item/%E6%B8%B8%E6%88%8F/33581" target="_blank" rel="noopener">游戏</a>，不光操作要好，脸也很重要，否则出门遇到BOSS，直接Game Over。另外，该游戏也继承了Roguelike类游戏的一贯特点——一命模式，死了就得重头再来，早期死了无所谓，后期死了那真是一把辛酸泪，这也使其具有了一定的挑战性。</p><a id="more"></a>

<h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><h2 id="全角色解锁方法"><a href="#全角色解锁方法" class="headerlink" title="全角色解锁方法"></a>全角色解锁方法</h2><p><strong>突击兵</strong></p>
<p>　　一开始就会给。</p>
<p><strong>Huntress（女猎手，女弓箭）</strong></p>
<p>　　完成第三关。</p>
<p><strong>MUL-T（机器人，小车）</strong></p>
<p>　　完成五次第一关，打完BOSS就算一次，之后可以不停跳伤原地自尽也可以退出游戏。</p>
<p><strong>Engineer（工程师）</strong></p>
<p>　　总计打完30关，不着急慢慢打就行。</p>
<p><strong>Mercenary（佣兵，剑圣）</strong></p>
<p>　　在“绿色传送门”我看着像是绿色的，反正是个非常亮的传送门。这个传送门会在第六关刷出，我也不是很确定。</p>
<p>　　出现后进入，里面是向下的跳跳乐，跳到最底部，然后面对石碑点击E。出现的字样为Obliterate yourself from existence，抹消自己的存在。点完一次后会出现Are you sure，再点击一次会立即结束本次游戏并且解锁剑客（如果不想结束游戏，石碑右侧会刷出一个普通传送门供你继续游戏）。</p>
<p><strong>Artificer（工匠，法师）</strong></p>
<p>　　游戏中有种特别大的硬币Lunar Coin（月亮硬币），数量显示在你金币的下方，为紫色的$标志。这种硬币是保留的！退出游戏后重开游戏硬币数目不会变。用10个新月币从“蓝色传送门”里面的商人处解锁该角色。</p>
<p>　　目前有两种说法，我目前对这两种说法更偏向于后者，因为我曾经同时看到两扇门：</p>
<p>　　1、蓝色商人传送门会在第五关结束时刷出，不需要其他操作。</p>
<p>　　2，这个蓝色传送门需要你使用一个新月币激活一个新月祭坛，然后关卡结束后会出现蓝色传送门，进去解锁。并且只有花费十个新月币购买了的玩家才能解锁该人物，队友无法解锁。</p>
<h2 id="各角色使用心得"><a href="#各角色使用心得" class="headerlink" title="各角色使用心得"></a><strong>各角色使用心得</strong></h2><ul>
<li><p><strong>工程师</strong>：炮台上蘑菇加个罩子再来个战旗。怎么死?怪都近不了身。一小时后除外，后面的怪谁也扛不住。</p>
</li>
<li><p><strong>女弓箭</strong>：飞羽叠高点加个强光喷射器地图里就没有到不了的地方，滞空能力超强闪避带无敌右键也可以延长滞空。虽然脆但是怪物摸不到你啊。</p>
</li>
<li><p><strong>多面手</strong>：硬的很。就这样。铁打的就是不一样嗷。容错率高。</p>
</li>
<li><p><strong>突击队员</strong>: 说实话初始角色还是很强的。闪避翻滚可以自控方向很有操作空间。比法师强些输出算是比较弱的吧。综合能排在法师前面嗷。</p>
</li>
<li><p><strong>剑士</strong>：就因为r技能，而且面板防御应该是所有角色里排第二吧。自带二段跳。</p>
</li>
<li><p><strong>法师</strong>：十个月亮币在大蜥蜴那里换到的拿到的时候激动的要死。输出是挺吊的。但我觉得这角色只适合联机和队友配合单兵作战能力就是个弟弟。</p>
</li>
</ul>
<h1 id="道具推荐"><a href="#道具推荐" class="headerlink" title="道具推荐"></a>道具推荐</h1><h2 id="全物品作用图鉴以及解锁方法"><a href="#全物品作用图鉴以及解锁方法" class="headerlink" title="全物品作用图鉴以及解锁方法"></a>全物品作用图鉴以及解锁方法</h2><p>《雨中冒险2》中有很多的物品道具，尤其在打BOSS时，道具的使用可以帮助玩家度过各种难关。请点击查看的《雨中冒险2》全物品效果与图鉴一览。 </p>
<p><a href="https://www.gamersky.com/handbook/201904/1173217.shtml" target="_blank" rel="noopener">全物品作用图鉴以及解锁方法</a></p>
<h2 id="白装"><a href="#白装" class="headerlink" title="白装"></a>白装</h2><h3 id="输出向道具"><a href="#输出向道具" class="headerlink" title="输出向道具"></a>输出向道具</h3><p>　　<strong>图片顺序代表排名，但黄针、眼镜、粘性炸弹并列，不分先后。</strong></p>
<p>　　黄针和眼镜都是非常简单粗暴又直观的加伤装备，无需多说，看到就拿，三选1选它们肯定是不亏的。因为存在收益递减，拿了7、8个之后就差不多可以考虑拿一下其他有用的白装了。如果你有吸血镰刀先把暴击叠满也是可以的。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image003.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image003_S.jpg" alt="游民星空"></a></p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image004.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image004_S.jpg" alt="游民星空"></a></p>
<p>　　粘性炸弹，喊它棒棒糖，无论什么时候拿都不亏，叠就完事了，叠起来伤害非常高，比一些垃圾绿装甚至红装高到不知道哪里去了。触发道具里能叠概率又叠伤害的，整个游戏里就它一个，机制决定地位，强。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image005.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image005_S.jpg" alt="游民星空"></a></p>
<p>　　撬棍单独拎出来其实不咋地，它的地位高是因为可以和皇家电容搭配走主动人，或者搭配鬼火油桶清群怪。可以叠但没必要，两三个就够了，如果你下定决心玩主动人的话多叠一些也是可以的。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image006.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image006_S.jpg" alt="游民星空"></a></p>
<p>　　汽油桶可以看作小鬼火，作为一个AOE伤害的补足还是不错的，但即使它能叠伤害，打出来的效果还是比较一般，没有其他好东西的时候就拿吧。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image007.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image007_S.jpg" alt="游民星空"></a></p>
<p>　　穿甲弹，打BOSS增伤，简单粗暴但适用面窄，拿两三个就差不多了，可以叠但没必要。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image008.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image008_S.jpg" alt="游民星空"></a></p>
<p>　　三尖匕首，增伤比较不明显的一个道具，实际存在感也比较薄弱，可以不拿。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image009.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image009_S.jpg" alt="游民星空"></a></p>
<h3 id="生存向道具"><a href="#生存向道具" class="headerlink" title="生存向道具"></a><strong>生存向道具</strong></h3><p>　　小熊强无敌，没什么好说的，推荐三选一看到就拿，叠到10个就相当于血量翻倍。要注意这玩意格挡概率不是简单的加法或者指数。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image010.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image010_S.jpg" alt="游民星空"></a></p>
<p>　　护盾发生器，25的护盾值在前期相当可观，即使到后期也不会毫无作用，拿了不亏。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image011.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image011_S.jpg" alt="游民星空"></a></p>
<p>　　谨慎蛞蝓，如果你没有水果，吸血道具又没有叠起来，这个将会是你的主要续航道具，脱战回血的增加量非常明显，在你感觉到续航不够时推荐拿几个。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image012.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image012_S.jpg" alt="游民星空"></a></p>
<p>　　真菌这玩意对工程师很重要，对其他角色就一般了，剑圣基本上用不上这玩意。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image013.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image013_S.jpg" alt="游民星空"></a></p>
<p>　　两个菜鸡道具，不懂设计出来的意义何在。数值加个零还勉强能用。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image014.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image014_S.jpg" alt="游民星空"></a></p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image015.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image015_S.jpg" alt="游民星空"></a></p>
<h3 id="辅助性道具"><a href="#辅助性道具" class="headerlink" title="辅助性道具"></a><strong>辅助性道具</strong></h3><p>　　羊腿，全游戏最好用的腿，能量饮料只加冲刺速度，红绳只加脱战速度，在它面前都是弟弟。拿几个显著提升游戏体验，生存能力也会强点。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image016.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image016_S.jpg" alt="游民星空"></a></p>
<p>　　备用弹夹，作用因角色而异，女猎手和法师拿提升很大，剑圣拿两三个能显著提升手感，其他角色拿就一般了，工程师拿完全没用。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image017.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image017_S.jpg" alt="游民星空"></a></p>
<p>　　震撼弹，因为对BOSS无效，很多人不喜欢这玩意。其实在你攻速起来之后这种强控道具是可以显著提升你输出环境的，精英怪一直晕到死就不用担心打完一套后被一拳拍死，拿几个不亏。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image018.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image018_S.jpg" alt="游民星空"></a></p>
<p>　　能量饮料，只加冲刺速度，数值略高，不如羊腿。缺腿可以拿一下。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image019.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image019_S.jpg" alt="游民星空"></a></p>
<p>　　烟花，作为一个伤害的补足还是可以的，但不要指望这东西给你打很多伤害，真叠上20个30个了游戏卡得不行。拿不拿都无所谓。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image020.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image020_S.jpg" alt="游民星空"></a></p>
<p>　　战旗的数值其实还行，问题在于它尴尬的机制。前期范围小存在感薄弱，后期基本打完BOSS才升级，而且其他道具把攻速叠上来了收益也变小了，那拿它干什么？</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image021.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image021_S.jpg" alt="游民星空"></a></p>
<p>　　生锈钥匙，你要是箱子好找一点就忍了，多拿一点箱子能变多也忍了，但就现在这机制，拿了就亏。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image022.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image022_S.jpg" alt="游民星空"></a></p>
<h2 id="绿装"><a href="#绿装" class="headerlink" title="绿装"></a><strong>绿装</strong></h2><h3 id="输出向道具-1"><a href="#输出向道具-1" class="headerlink" title="输出向道具"></a><strong>输出向道具</strong></h3><p>　　这里面没有一个是菜的，都很强。</p>
<p>　　最强的当属鬼火，机制看上去像是高配汽油桶，就是范围小一点，伤害高一点，但用起来感觉完全不一样，鬼火叠高来伤害太高了，有这玩意在手你完全不用担心后期怪刷太多，随便放几个AOE技能怪自己就炸完了。叠它，血赚。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image023.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image023_S.jpg" alt="游民星空"></a></p>
<p>　　尤克里里本身的AOE伤害并不出众，叠加也只叠加个数和范围不加概率伤害，看起来好像一般般，但这玩意是可以触发道具效果的！这就让它在触发流里占了一个很高的地位。一个足够，多了更好。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image024.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image024_S.jpg" alt="游民星空"></a></p>
<p>　　MK1导弹，看数值就知道这玩意要是叠的起来伤害有多高了，就像说的，如果你有尤克里里这些AOE，攻速也起来了，怼着一个怪打就能全屏到处触发棒棒糖导弹火环冰环之类的，直接用特效砸死BOSS和它的跟班。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image025.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image025_S.jpg" alt="游民星空"></a></p>
<p>　　冰环火环放到一起说，这两个伤害不如导弹，但它们好在是AOE而且有一个软控，同样非常强力。总之这游戏目前概率触发类道具就没弱的。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image026.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image026_S.jpg" alt="游民星空"></a></p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image027.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image027_S.jpg" alt="游民星空"></a></p>
<p>　　捕食本能，攻速加的很明显。如果你暴击够高，这玩意就一个就顶两个黄针。强。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image028.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image028_S.jpg" alt="游民星空"></a></p>
<p>　　狂战士肩甲，1秒内杀3个敌人，看起来是个很苛刻的条件，前期确实不好触发，但一旦你后面成型之后这个道具效果几乎是常驻的，强的不行。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image029.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image029_S.jpg" alt="游民星空"></a></p>
<h3 id="生存向道具-1"><a href="#生存向道具-1" class="headerlink" title="生存向道具"></a><strong>生存向道具</strong></h3><p>　　第一个首推吸血镰刀。多拿几个这个东西，叠叠暴击，你会发现你身体怎么这么硬朗，不小心吃了好几发都没死（火石巨人：？）。吸血流是目前游戏里最强的续航之一，完全可以和工程师的真菌炮台并肩，像剑圣这种不怎么吃的到炮台奶的角色用吸血流会很舒服，缺点就是成型太难了，所有吸血装备都是绿装。暴击不够之前可以分点给队友，毕竟这玩意第一个加5%暴击呢。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image030.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image030_S.jpg" alt="游民星空"></a></p>
<p>　　叠注入可以显著降低暴毙率，女猎手这种血少的角色拿它再合适不过。注意目前版本工程师有BUG，炮台杀敌，注入是给炮台加血的，不给角色本身加，而且炮台炸了血就没了，亏爆，所以请让给队友拿。还有注入在换道具换掉之后加的血上限就莫得了，拿了玻璃刀也只加50血，但超绝不受影响。除了目前版本的工程师无论谁拿都血赚，远离暴毙，就在今天。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image031.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image031_S.jpg" alt="游民星空"></a></p>
<p>　　老旧秘密战争装备，被打之后会隐形加移速，概率跟扣血量有关。这个同样是一个很好用的防暴毙概率，在你受到攻击隐身后持续伤害就不会打到你的身上了（例如巨人的激光），这时候脱战回回血，回来又是一条好汉。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image032.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image032_S.jpg" alt="游民星空"></a></p>
<p>　　玫瑰圆盾，不知道护甲是怎么算的，但自己用起来减伤还是挺明显的，叠起来跑动过程中甚至硬吃了一发火石巨人的激光。还不错的道具。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image033.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image033_S.jpg" alt="游民星空"></a></p>
<p>　　吸血种子，和吸血镰刀重复的功能，数值又低，只能说拿了勉强不亏。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image034.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image034_S.jpg" alt="游民星空"></a></p>
<h3 id="辅助性道具-1"><a href="#辅助性道具-1" class="headerlink" title="辅助性道具"></a><strong>辅助性道具</strong></h3><p>　　飞羽。在空中比地上的输出环境好很多，皇牌空战可以一直爽，飞羽可以说拿多少个都不亏，不过3、4个就已经差不多了，多的还是分点给队友吧。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image035.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image035_S.jpg" alt="游民星空"></a></p>
<p>　　燃料电池，如果你是主动人，这个道具重要性不亚于溺水手势，必需品，越多越好。如果你并不打算走主动流，这个道具就可有可无了，有当然很好，多一次水果的次数，没有也行，大不了苟一下。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image036.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image036_S.jpg" alt="游民星空"></a></p>
<p>　　子弹带，对远程角色基本没用，但对于剑圣很好用，无限无敌斩，冲就完事了。有两三个就够了，不用强求太多。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image037.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image037_S.jpg" alt="游民星空"></a></p>
<p>　　蜡质鹌鹑，也算是个腿，用来跑图逃命都不错，但不要多捡，2个就够了，多了反而是个负面道具。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image038.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image038_S.jpg" alt="游民星空"></a></p>
<p>　　红绳，对于大部分角色来说只有跑图有用，工程师拿这个倒是挺合适的，一个绿装性能没白装好，你丢人吗？</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image039.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image039_S.jpg" alt="游民星空"></a></p>
<p>　　时光珠，这玩意是个绿装？？？？？</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image040.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image040_S.jpg" alt="游民星空"></a></p>
<h2 id="红装"><a href="#红装" class="headerlink" title="红装"></a><strong>红装</strong></h2><h3 id="输出向道具-2"><a href="#输出向道具-2" class="headerlink" title="输出向道具"></a><strong>输出向道具</strong></h3><p>　　特斯拉线圈，频率高，伤害猛，全自动，没有限制条件，还能触发道具效果。这不是最强红装那谁是？如果在商店里看到这玩意，自己绿装里也没啥核心道具，换这个，不亏的。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image041.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image041_S.jpg" alt="游民星空"></a></p>
<p>　　仪式匕首，非常强力的一个红装。叠它会增加匕首的数量，匕首伤害非常高，配上足够多的撬棍鬼火汽油桶这类道具，甚至能将雨中冒险玩成一个放置游戏，你只要杀死第一个怪就能启动这个循环了：匕首—杀怪—爆炸并生成新的匕首——杀怪——爆炸并生成新的匕首……只要你伤害够，商店里可以酌情换这个。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image042.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image042_S.jpg" alt="游民星空"></a></p>
<p>　　感知肉钩，也是一个很强力的AOE红装，附带一点聚怪效果。升级加的是数量而不是伤害很可惜，10个本来就够多了哪来那么多怪让你钩，女猎手和剑圣用这个红装效果都非常好。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image043.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image043_S.jpg" alt="游民星空"></a></p>
<p>　　库哈那的观点，这个机制描述看的不是很懂，姑且当它就是造成你溢出治疗量10%的伤害。这个自然是给工程师用的，真菌工程师秒从奶变核心输出，伤害非常可观。吸血流成型了拿这个也很不错。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image044.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image044_S.jpg" alt="游民星空"></a></p>
<p>　　冰环，伤害较低，但它可以触发道具效果，相当于变相加攻速，给剑圣用会比较好一点，其他角色基本不会近身。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image045.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image045_S.jpg" alt="游民星空"></a></p>
<p>　　聪明的巨兽，每击都附带60%的伤害，这个自然是给攻击频率高的角色比较有用，例如女猎手的箭雨，剑圣的无敌斩，突击手的火力压制。但它不能触发道具效果，这就使它在后期的伤害并不明显了。但前期如果开到它就是一场屠杀，能保送到你打完第4关。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image046.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image046_S.jpg" alt="游民星空"></a></p>
<p>　　微笑面具，用处还是有一点的，幽灵可以帮你吸引仇恨，虽然也会挡你子弹，扰乱你视觉。但伤害嘛，别抱有期望。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image047.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image047_S.jpg" alt="游民星空"></a></p>
<h3 id="生存向和辅助向道具"><a href="#生存向和辅助向道具" class="headerlink" title="生存向和辅助向道具"></a><strong>生存向和辅助向道具</strong></h3><p>　　复活牛逼。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image048.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image048_S.jpg" alt="游民星空"></a></p>
<p>　　57三叶草，描述是触发道具的效果会再触发一次，但用了感觉像是触发道具的概率翻倍，因为这玩意对眼镜有效，5个眼镜满暴击……反正强就对了，什么导弹冰环火环的伤害直接翻倍。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image049.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image049_S.jpg" alt="游民星空"></a></p>
<p>　　强光喷射器，给谁拿都可以显著提升游戏体验的东西，比如剑圣，冲刺有3次充能，那就可以冲9次，加上无敌斩一共可以冲10次，一直冲一直爽，无论是游戏体验还是生存能力都显著上升。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image050.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image050_S.jpg" alt="游民星空"></a></p>
<p>　　外星人头，减少技能冷却时间，简单粗暴，对突击队员和机器人这种靠平A或者主动技能吃饭的可能用处不大，但对其他角色就太大了，尤其是剑圣，无敌斩CD减少后不仅输出上去了，暴毙概率也直线下降。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image051.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image051_S.jpg" alt="游民星空"></a></p>
<p>　　灵魂绑定催化剂，杀怪减少主动的CD，一听就是给主动人的，但主动人其实并不一定需要这个东西，有很好，没有溺水手势也够用的。不是主动人拿了收益也不错，水果能多吃好多口，续航不用担心了。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image052.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image052_S.jpg" alt="游民星空"></a></p>
<p>　　回春架，治疗效果翻倍，简单粗暴，好用。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image053.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image053_S.jpg" alt="游民星空"></a></p>
<p>　　大脑这个道具还没解锁，明明季风难度下火石巨人啥的都打过了……效果是杀精英怪短时间内无技能CD，跟别人联机的时候体验过，效果还不错，但论实际收益还是外星人头好，因为每个技能都有至少1s的内置CD。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image054.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image054_S.jpg" alt="游民星空"></a></p>
<p>　　这玩意会让你跳的很高，免疫坠落伤害，还多一个伤害不错的加速下踩，看起来挺美好的，但跳高很慢身位又不可控，在某些情况下就是活靶子，巨人一个激光过来直接暴毙，是不会捡这玩意的。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image055.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image055_S.jpg" alt="游民星空"></a></p>
<p>　　秃鹫觉醒，在官方对它进行了修正后它的地位有了提升，杀死电系精英怪之后会直接补充角色一半血一半盾，也就是说在你空血的时候击杀电系精英会直接补满血，这就很有使用价值了，有时候甚至会在满血的基础上加一半盾，血条突破了上限（估计是个BUG）。再加上它偷取精英怪属性对攻击的加成也还行，所以算是一个不错的红装了，捡到不亏，但不要换。</p>
<h2 id="BOSS掉落的道具"><a href="#BOSS掉落的道具" class="headerlink" title="BOSS掉落的道具"></a><strong>BOSS掉落的道具</strong></h2><p>　　都很一般。</p>
<p>　　巨人硬节其实还行，虽然它数值确实很低，但它起码有用，拿了不亏。当然把有用的绿装替换掉就有点亏了。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image057.jpg" target="_blank" rel="noopener"><img src="http://image.gamersky.com/webimg13/zhuanti/common/blank.png" alt="游民星空"></a></p>
<p>　　皇后腺体也就前面几关有点用，后面连个小怪都打不过，还会挡自己人子弹，AI也有问题，明明你周围没怪它就是莫名其妙过来给你一锤，把你吓个半死。反正是不会再捡这玩意了。</p>
<h2 id="月亮道具"><a href="#月亮道具" class="headerlink" title="月亮道具"></a><strong>月亮道具</strong></h2><p>　　溺水手势，月亮道具里最有用的之一，主动人必备道具，搭配皇家电容和一次性导弹发射器都很强，直接就变成了挂机游戏，不用上去打的。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image059.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image059_S.jpg" alt="游民星空"></a></p>
<p>　　卓越，把你所有的血换成护盾并增加生命值上限。这是月亮道具里唯一一个几乎没有负面作用的道具。除了剑圣外所有角色拿都是赚的。剑圣不拿这个是因为续航根本跟不上，带上卓越打火精英就是暴毙预定，所以剑圣其实并不适合拿玻璃刀和卓越当主动人。想玩主动人去玩突击手，机器人，工程师都不错。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image060.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image060_S.jpg" alt="游民星空"></a></p>
<p>　　玻璃刀，本游戏最强增伤技能，拿完就变成脆皮，没有卓越拿玻璃刀真的是作死行为，嫌暴毙不够快的。主动人拿玻璃刀那就真的是看谁谁死了（皇家电容），甚至都不用看的（一次性导弹发射器）。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image061.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image061_S.jpg" alt="游民星空"></a></p>
<p>　　起死回生，低配版本回春架，回血有数值上限，越拿数值越低，一个字，垃圾，不要拿。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image062.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image062_S.jpg" alt="游民星空"></a></p>
<p>　　脆弱皇冠，攻击加钱受伤减钱，但这玩意真的不成比例，加钱加一点点，扣钱扣一大截，而且拿了卖血就亏爆，觉得是个纯负面技能。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image063.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image063_S.jpg" alt="游民星空"></a></p>
<h2 id="主动道具"><a href="#主动道具" class="headerlink" title="主动道具"></a><strong>主动道具</strong></h2><h3 id="最有用的"><a href="#最有用的" class="headerlink" title="最有用的"></a><strong>最有用的</strong></h3><p>　　皇家电容和一次性导弹发射器，两个都是主动人的核心输出技能。孰优孰劣难分高低，两个都各有优势：皇家电容是单发伤害，可以吃到撬棍加成，可以秒商店老板（误，导弹则是总伤害更高，而且不需要视野，直接挂机都能杀怪，拿了玻璃刀后输出环境比电容安全，也不会误伤商店老板。两个其实都差不多，哪个更强那就看你更喜欢哪个吧。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image064.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image064_S.jpg" alt="游民星空"></a></p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image065.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image065_S.jpg" alt="游民星空"></a></p>
<p>　　异质水果，奶量足，防猝死，很好用，最喜欢的主动道具。无需多说，用过都说好。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image066.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image066_S.jpg" alt="游民星空"></a></p>
<p>　　乳白蝶蛹，可以一直飞高高，天上输出环境好，适合作为机器人主动人的第二主动技能，是个相当不错的主动技能。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image067.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image067_S.jpg" alt="游民星空"></a></p>
<p>　　先子聚集器，伤害很高，但很难打中，高配法师右键。而且冷却时间太长了，只能说可堪一用。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image068.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image068_S.jpg" alt="游民星空"></a></p>
<h3 id="一般甚至鸡肋的"><a href="#一般甚至鸡肋的" class="headerlink" title="一般甚至鸡肋的"></a><strong>一般甚至鸡肋的</strong></h3><p>　　雷达扫描器，组队时可以有效增加搜刮效率，还算个能用的主动。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image069.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image069_S.jpg" alt="游民星空"></a></p>
<p>　　原初立方体，10s聚怪，在没有更好的主动道具前也是个不错的选择。60s的冷却时间实在太长了，这使它真的不实用。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image070.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image070_S.jpg" alt="游民星空"></a></p>
<p>　　HUD目镜，百分百暴击，很明显是个前期主动，后期眼镜叠上来了就没有存在价值了，要是再加点暴伤那还有点用。</p>
<p>　　HUD目镜在单机时价值只体现在前期，但在联机时有另一种用法，就是让一个人拿上HUD，然后给它叠溺水手势，燃料电池，灵魂绑定催化剂，那这个人就不需要和队友抢眼镜了，稍微叠几个就能全程覆盖。当然了如果能拿到更多也能随时转主动人。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image071.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image071_S.jpg" alt="游民星空"></a></p>
<p>　　空中支援，喊出来一大堆无人机，前期过渡用用还行，后期无人机一出来就暴毙。此外它还有把主动人的游戏卡崩溃的功能。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image072.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image072_S.jpg" alt="游民星空"></a></p>
<p>　　木灵，这不就是水果加上起死回生的效果吗？要给别人奶，为什么不用工程师？菜。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image073.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image073_S.jpg" alt="游民星空"></a></p>
<p>　　众筹机，在后期还是有那么一点用的，输出也算可观，但……真的让人没有用的欲望。在你后期不缺钱的时候无聊可以拿来玩一玩。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image074.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image074_S.jpg" alt="游民星空"></a></p>
<p><strong>三个月亮主动技能</strong></p>
<p>　　结论：菜，没有存在的必要。这种负面效果放后期妥妥的死路一条。陨石在被队友坑了之后甚至都不想解锁，浪费月亮币。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image075.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image075_S.jpg" alt="游民星空"></a></p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image076.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image076_S.jpg" alt="游民星空"></a></p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image077.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190503_lc_475_4/image077_S.jpg" alt="游民星空"></a></p>
<h1 id="祭坛及建筑作用"><a href="#祭坛及建筑作用" class="headerlink" title="祭坛及建筑作用"></a>祭坛及建筑作用</h1><p>　《雨中冒险2》地图中特殊建筑还是很多的，其作用是什么相信新玩家还不了解，下面是“殇_寂灭”分享的《雨中冒险2》祭坛及建筑作用介绍，一起来看看吧。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image003.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image003_S.jpg" alt="游民星空"></a></p>
<p>　　纽特祭坛</p>
<p>　　消耗一枚月亮币，传送门充能完毕必开商店传送门（蓝门）。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image004.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image004_S.jpg" alt="游民星空"></a></p>
<p>　　赌博祭坛</p>
<p>　　消耗金币（逐步提升价格），概率给道具，每个赌博祭坛最多给予你两个道具（3次不中解锁成就）。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image006.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image006_S.jpg" alt="游民星空"></a></p>
<p>　　3D打印机</p>
<p>　　使用你身上已有道具，换取打印机上悬浮的道具（比如图上这个，就是换成黏性炸弹）白换白，绿换绿，红换红。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image156.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image156_S.jpg" alt="游民星空"></a></p>
<p>　　虏库哈娜祭坛点，在水槽红圈的位置。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image158.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image158_S.jpg" alt="游民星空"></a></p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image160.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image160_S.jpg" alt="游民星空"></a></p>
<p>　　山神祭坛</p>
<p>　　开启之后，boss增强（数量翻倍或者变成精英boss）。</p>
<p>　　一张地图开启两个山神，过关可以解锁成就。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image162.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image162_S.jpg" alt="游民星空"></a></p>
<p>　　沙图的隐藏门，打开方式是找到下图的两个机关，同时踩住（工程师可以用炮台，别的角色可以推罐子上去）。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image164.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image164_S.jpg" alt="游民星空"></a></p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image166.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image166_S.jpg" alt="游民星空"></a></p>
<p>　　精英祭坛</p>
<p>　　开启后出一堆怪（前期快速刷怪打钱）。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image168.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image168_S.jpg" alt="游民星空"></a></p>
<p>　　月球苞</p>
<p>　　花费一个月亮币，给予你一个随机的月亮道具。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image170.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image170_S.jpg" alt="游民星空"></a></p>
<p>　　天堂的图鉴收集点，位置在下图角色脚下（进去往后走，边缘往下看，能看到）。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image172.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image172_S.jpg" alt="游民星空"></a></p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image174.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image174_S.jpg" alt="游民星空"></a></p>
<p>　　森林祭坛</p>
<p>　　花钱开启，以祭坛为中心出现回血阵（和蘑菇一样）升满解锁成就。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image176.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image176_S.jpg" alt="游民星空"></a></p>
<p>　　商店的图鉴收集在大红箭头那个坑里面，下去能看到图鉴悬在半空，是时候展现真正的技术了（下面截图红圈是图鉴，EMMMMM截的有点小，大概就是这么个意思吧）。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image178.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image178_S.jpg" alt="游民星空"></a></p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image180.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image180_S.jpg" alt="游民星空"></a></p>
<p>　　商店里，这两个东西是换东西，以你身上有的道具换取上面悬浮的道具，左边是用3个白色道具换，右边是用5个绿色道具换。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image182.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image182_S.jpg" alt="游民星空"></a></p>
<p>　　商店里，这一堆蓝色道具，是用月亮币换。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image184.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image184_S.jpg" alt="游民星空"></a></p>
<p>　　场景扫描雷达</p>
<p>　　花钱扫描之后，解锁当前地图场景图鉴。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image185.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image185_S.jpg" alt="游民星空"></a></p>
<p>　　鲜血祭坛</p>
<p>　　用血换钱，血越多钱越多（三次，分别是百分之50.75.93）。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image187.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image187_S.jpg" alt="游民星空"></a></p>
<p>　　黄金祭坛（黄色的赌博祭坛）</p>
<p>　　开启后，传送门充能完毕，开启黄金海岸传送门（金色），前往黄金海岸挨揍。</p>
<p><a href="http://www.gamersky.com/showimage/id_gamersky.shtml?http://img1.gamersky.com/image2019/05/20190504_my_227_16/image189.jpg" target="_blank" rel="noopener"><img src="http://img1.gamersky.com/image2019/05/20190504_my_227_16/image189_S.jpg" alt="游民星空"></a></p>
<p>　　秩序祭坛</p>
<p>　　消耗一个月亮币，将你身上同等级道具数量整合为同等级的某个道具（比如你身上一共有白色道具80个，然后变成80个生锈钥匙）。</p>
]]></content>
      <categories>
        <category>游戏攻略</category>
      </categories>
  </entry>
  <entry>
    <title>jquery中的bind(),live(),delegate(),on()有什么区别？</title>
    <url>/2019/10/25/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%833/jquery%E4%B8%AD%E7%9A%84bind-live-delegate-on-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<p>当我们试图绑定一些事件到DOM元素上的时候，我相信上面这4个方法是最常用的。而它们之间到底有什么不同呢？在什么场合下用什么方法是最有效的呢?</p><h1 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h1><p>当我们在开始的时候，有些知识是必须具备的：</p><p>DOM树</p><p>下图仅仅是一个示例，这是一个在browser环境下的一棵模拟DOM树，在下面的代码中仅起到演示的作用：</p><p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g8ahircgqqj30fa08cjrb.jpg" alt="chart.png"></p><p>Event bubbling (aka event propagation)冒泡</p><a id="more"></a>





<p>我们的页面可以理解为一棵DOM树，当我们在叶子结点上做什么事情的时候（如click一个a元素），如果我们不人为的设置stopPropagation(Moder Browser), cancelBubble(IE)，那么它的所有父元素，祖宗元素都会受之影响，它们上面绑定的事件也会产生作用。看一个示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&apos;a&apos;).bind(&apos;click&apos;, function() &#123; alert(&quot;That tickles!&quot;) &#125;);</span><br></pre></td></tr></table></figure>
<p>当我们在a 上面点击的时候，首先会触发它本身所绑定的click事件，然后会一路往上，触发它的父元素，祖先元素上所有绑定的click事件，就像下图演示的那样。</p>
<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g8ahi3ycukj30fa09q0sq.jpg" alt="chart (1).png"></p>
<p>示例HTML</p>
<p> 为了对下面的代码进行演示，添加一些HTML代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul id=&quot;members&quot; data-role=&quot;listview&quot; data-filter=&quot;true&quot;&gt;</span><br><span class="line">    &lt;!-- ... more list items ... --&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;a href=&quot;detail.html?id=10&quot;&gt;</span><br><span class="line">            &lt;h3&gt;John Resig(jQuery的作者)&lt;/h3&gt;</span><br><span class="line">            &lt;p&gt;&lt;strong&gt;jQuery Core Lead&lt;/strong&gt;&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;Boston, United States&lt;/p&gt;</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;!-- ... more list items ... --&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Bind"><a href="#Bind" class="headerlink" title="Bind()"></a><strong>Bind()</strong></h1><p>.bind()是最直接的绑定方法 ，会绑定事件类型和处理函数到DOM element上, 这个方法是存在最久的，而且也很好的解决了浏览器在事件处理中的兼容问题。但是这个方法有一些performance方面的问题，看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* The .bind() method attaches the event handler directly to the DOM </span><br><span class="line">   element in question ( &quot;#members li a&quot; ). The .click() method is </span><br><span class="line">   just a shorthand way to write the .bind() method. */</span><br><span class="line"></span><br><span class="line">$( &quot;#members li a&quot; ).bind( &quot;click&quot;, function( e ) &#123;&#125; ); </span><br><span class="line">$( &quot;#members li a&quot; ).click( function( e ) &#123;&#125; );</span><br></pre></td></tr></table></figure>
<p>上面的两行代码所完成的任务都是一致的，就是把event handler加到<strong>全部</strong>的匹配的<a>元素上。这里存在着一些效率方面的问题，一方面，我们隐式地把click handler加到所有的a标签上，这个过程是昂贵的;另一方面在执行的时候也是一种浪费，因为它们都是做了同一件事却被执行了一次又一次（比如我们可以把它hook到它们的父元素上，通过冒泡可以对它们中的每一个进行区分，然后再执行这个event handler）。</a></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>这个方法提供了一种在各种浏览器之间对事件处理的兼容性解决方案</li>
<li>非常方便简单的绑定事件到元素上</li>
<li>.click(), .hover()…这些非常方便的事件绑定，都是bind的一种简化处理方式</li>
<li>对于利用ID选出来的元素是非常好的，不仅仅是很快的可以hook上去(因为一个页面只有一个id),而且当事件发生时，handler可以立即被执行(相对于后面的live, delegate)实现方式</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>它会绑定事件到所有的选出来的元素上</li>
<li>它不会绑定到在它执行完后动态添加的那些元素上</li>
<li>当元素很多时，会出现效率问题</li>
<li>当页面加载完的时候，你才可以进行bind()，所以可能产生效率问题</li>
</ul>
<h1 id="live"><a href="#live" class="headerlink" title=".live()"></a><strong>.live()</strong></h1><p>.live()方法用到了事件委托的概念来处理事件的绑定。它和用.bind()来绑定事件是一样的。.live()方法会绑定相应的事件到你所选择的元素的根元素上，即是document元素上。那么所有通过冒泡上来的事件都可以用这个相同的handler来处理了。它的处理机制是这样的，一旦事件冒泡到document上，jQuery将会查找selector/event metadata,然后决定那个handler应该被调用。jquery 1.8.2的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ( delegateCount &amp;&amp; !(event.button &amp;&amp; event.type === &quot;click&quot;) ) &#123;</span><br><span class="line"></span><br><span class="line">            for ( cur = event.target; cur != this; cur = cur.parentNode || this ) &#123;</span><br><span class="line"></span><br><span class="line">                // Don&apos;t process clicks (ONLY) on disabled elements (#6911, #8165, #11382, #11764)</span><br><span class="line">                if ( cur.disabled !== true || event.type !== &quot;click&quot; ) &#123;</span><br><span class="line">                    selMatch = &#123;&#125;;</span><br><span class="line">                    matches = [];</span><br><span class="line">                    for ( i = 0; i &lt; delegateCount; i++ ) &#123;</span><br><span class="line">                        handleObj = handlers[ i ];</span><br><span class="line">                        sel = handleObj.selector;</span><br><span class="line"></span><br><span class="line">                        if ( selMatch[ sel ] === undefined ) &#123;</span><br><span class="line">                            selMatch[ sel ] = handleObj.needsContext ?</span><br><span class="line">                                jQuery( sel, this ).index( cur ) &gt;= 0 :</span><br><span class="line">                                jQuery.find( sel, this, null, [ cur ] ).length;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if ( selMatch[ sel ] ) &#123;</span><br><span class="line">                            matches.push( handleObj );</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if ( matches.length ) &#123;</span><br><span class="line">                        handlerQueue.push(&#123; elem: cur, matches: matches &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>当handler在执行的时候，因为有冒泡的参与，确实会有一些延迟，但是绑定的时候是特别的快。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* The .live() method attaches the event handler to the root level </span><br><span class="line">   document along with the associated selector and event information </span><br><span class="line">   ( &quot;#members li a&quot; &amp; &quot;click&quot; ) */ </span><br><span class="line"></span><br><span class="line">$( &quot;#members li a&quot; ).live( &quot;click&quot;, function( e ) &#123;&#125; );</span><br></pre></td></tr></table></figure>
<p>上面的code在和.bind()相比的时候有一个好处就是我们不需要在每个元素上再去绑定事件，而只在document上绑定一次就可以了。尽管这个不是最快的方式，但是确实是最少浪费的。</p>
<h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><ul>
<li>这里仅有一次的事件绑定，绑定到document上而不像.bind()那样给所有的元素挨个绑定</li>
<li>那些动态添加的elemtns依然可以触发那些早先绑定的事件，因为事件真正的绑定是在document上</li>
<li>你可以在document ready之前就可以绑定那些需要的事件</li>
</ul>
<h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>从1.7开始已经不被推荐了，所以你也要开始逐步淘汰它了。</li>
<li>Chaining没有被正确的支持</li>
<li>当使用event.stopPropagation()是没用的，因为都要到达document</li>
<li>因为所有的selector/event都被绑定到document, 所以当我们使用matchSelector方法来选出那个事件被调用时，会非常慢</li>
<li>当发生事件的元素在你的DOM树中很深的时候，会有performance问题</li>
</ul>
<h1 id="Delegate"><a href="#Delegate" class="headerlink" title=".Delegate()"></a><strong>.Delegate()</strong></h1><p>.delegate()有点像.live(),不同于.live()的地方在于，它不会把所有的event全部绑定到document,而是由你决定把它放在哪儿。而和.live()相同的地方在于都是用event delegation.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* The .delegate() method behaves in a similar fashion to the .live() </span><br><span class="line">   method, but instead of attaching the event handler to the document, </span><br><span class="line">   you can choose where it is anchored ( &quot;#members&quot; ). The selector </span><br><span class="line">   and event information ( &quot;li a&quot; &amp; &quot;click&quot; ) will be attached to the </span><br><span class="line">   &quot;#members&quot; element. */</span><br><span class="line"></span><br><span class="line">$( &quot;#members&quot; ).delegate( &quot;li a&quot;, &quot;click&quot;, function( e ) &#123;&#125; );</span><br></pre></td></tr></table></figure>
<h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><ul>
<li>你可以选择你把这个事件放到那个元素上了</li>
<li>chaining被正确的支持了</li>
<li>jQuery仍然需要迭代查找所有的selector/event data来决定那个子元素来匹配，但是因为你可以决定放在那个根元素上，所以可以有效的减小你所要查找的元素。</li>
<li>可以用在动态添加的元素上</li>
</ul>
<h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>需要查找那个那个元素上发生了那个事件了，尽管比document少很多了，不过，你还是得浪费时间来查找。</li>
</ul>
<h1 id="On"><a href="#On" class="headerlink" title=".On()"></a><strong>.On()</strong></h1><p> 其实.bind(), .live(), .delegate()都是通过.on()来实现的，.unbind(), .die(), .undelegate(),也是一样的都是通过.off()来实现的，这是1.8.2的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind: function( types, data, fn ) &#123;</span><br><span class="line">        return this.on( types, null, data, fn );</span><br><span class="line">    &#125;,</span><br><span class="line">    unbind: function( types, fn ) &#123;</span><br><span class="line">        return this.off( types, null, fn );</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    live: function( types, data, fn ) &#123;</span><br><span class="line">        jQuery( this.context ).on( types, this.selector, data, fn );</span><br><span class="line">        return this;</span><br><span class="line">    &#125;,</span><br><span class="line">    die: function( types, fn ) &#123;</span><br><span class="line">        jQuery( this.context ).off( types, this.selector || &quot;**&quot;, fn );</span><br><span class="line">        return this;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    delegate: function( selector, types, data, fn ) &#123;</span><br><span class="line">        return this.on( types, selector, data, fn );</span><br><span class="line">    &#125;,</span><br><span class="line">    undelegate: function( selector, types, fn ) &#123;</span><br><span class="line">        // ( namespace ) or ( selector, types [, fn] )</span><br><span class="line">        return arguments.length === 1 ? this.off( selector, &quot;**&quot; ) : this.off( types, selector || &quot;**&quot;, fn );</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>
<p>看一下，我们用如何用.on()来改写前面通过 .bind(), .live(), .delegate()所注册的事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* The jQuery .bind(), .live(), and .delegate() methods are just one </span><br><span class="line">   line pass throughs to the new jQuery 1.8.2 .on() method */</span><br><span class="line"></span><br><span class="line">// Bind</span><br><span class="line">$( &quot;#members li a&quot; ).on( &quot;click&quot;, function( e ) &#123;&#125; ); </span><br><span class="line">$( &quot;#members li a&quot; ).bind( &quot;click&quot;, function( e ) &#123;&#125; ); </span><br><span class="line"></span><br><span class="line">// Live</span><br><span class="line">$( document ).on( &quot;click&quot;, &quot;#members li a&quot;, function( e ) &#123;&#125; ); </span><br><span class="line">$( &quot;#members li a&quot; ).live( &quot;click&quot;, function( e ) &#123;&#125; );</span><br><span class="line"></span><br><span class="line">// Delegate</span><br><span class="line">$( &quot;#members&quot; ).on( &quot;click&quot;, &quot;li a&quot;, function( e ) &#123;&#125; ); </span><br><span class="line">$( &quot;#members&quot; ).delegate( &quot;li a&quot;, &quot;click&quot;, function( e ) &#123;&#125; );</span><br></pre></td></tr></table></figure>
<h2 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h2><ul>
<li>提供了一种统一绑定事件的方法</li>
<li>仍然提供了.delegate()的优点，当然如果需要你也可以直接用.bind()</li>
</ul>
<h2 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>也许会对你产生一些困扰，因为它隐藏了一前面我们所介绍的三种方法的细节。</li>
</ul>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h1><ul>
<li>用.bind()的代价是非常大的，它会把相同的一个事件处理程序hook到所有匹配的DOM元素上</li>
<li>不要再用.live()了，它已经不再被推荐了，而且还有许多问题</li>
<li>.delegate()会提供很好的方法来提高效率，同时我们可以添加一事件处理方法到动态添加的元素上。</li>
<li><p>我们可以用.on()来代替上述的3种方法</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1></li>
</ul>
<p><a href="http://www.elijahmanor.com/2012/02/differences-between-jquery-bind-vs-live.html" target="_blank" rel="noopener">http://www.elijahmanor.com/2012/02/differences-between-jquery-bind-vs-live.html</a></p>
<p><a href="http://www.alfajango.com/blog/the-difference-between-jquerys-bind-live-and-delegate/" target="_blank" rel="noopener">http://www.alfajango.com/blog/the-difference-between-jquerys-bind-live-and-delegate/</a></p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>有限状态机是什么？</title>
    <url>/2019/10/25/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%833/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="有限状态机是什么"><a href="#有限状态机是什么" class="headerlink" title="有限状态机是什么"></a>有限状态机是什么</h1><p>有限状态机（Finite-state machine）是一个非常有用的模型，可以模拟世界上大部分事物。</p><p>简单说，它有三个特征：</p><ul>
<li>状态总数（state）是有限的。</li>
<li>任一时刻，只处在一种状态之中。</li>
<li>某种条件下，会从一种状态转变（transition）到另一种状态。</li>
</ul><h1 id="有限状态机的使用"><a href="#有限状态机的使用" class="headerlink" title="有限状态机的使用"></a>有限状态机的使用</h1><ol>
<li>引入有限状态机的js库</li>
</ol><a id="more"></a>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script src=&apos;state-machine.js&apos;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>有限状态机的基本结构</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var fsm = new StateMachine(&#123;</span><br><span class="line"></span><br><span class="line">   init: &apos;solid&apos;,</span><br><span class="line"></span><br><span class="line">   transitions: [</span><br><span class="line"></span><br><span class="line">     &#123; name: &apos;melt&apos;, from: &apos;solid&apos;, to: &apos;liquid&apos; &#125;,</span><br><span class="line"></span><br><span class="line">     &#123; name: &apos;freeze&apos;, from: &apos;liquid&apos;, to: &apos;solid&apos; &#125;,</span><br><span class="line"></span><br><span class="line">     &#123; name: &apos;vaporize&apos;, from: &apos;liquid&apos;, to: &apos;gas&apos; &#125;,</span><br><span class="line"></span><br><span class="line">     &#123; name: &apos;condense&apos;, from: &apos;gas&apos;, to: &apos;liquid&apos; &#125;</span><br><span class="line"></span><br><span class="line">   ],</span><br><span class="line"></span><br><span class="line">   methods: &#123;</span><br><span class="line"></span><br><span class="line">     onMelt: function() &#123; console.log(&apos;I melted&apos;) &#125;,</span><br><span class="line"></span><br><span class="line">     onFreeze: function() &#123; console.log(&apos;I froze&apos;) &#125;,</span><br><span class="line"></span><br><span class="line">     onVaporize: function() &#123; console.log(&apos;I vaporized&apos;) &#125;,</span><br><span class="line"></span><br><span class="line">     onCondense: function() &#123; console.log(&apos;I condensed&apos;) &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>生成实例以后，就可以随时查询当前状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* fsm.current ：返回当前状态。</span><br><span class="line"></span><br><span class="line">* fsm.is(s) ：返回一个布尔值，表示状态s是否为当前状态。</span><br><span class="line"></span><br><span class="line">* fsm.can(e) ：返回一个布尔值，表示事件e是否能在当前状态触发。</span><br><span class="line"></span><br><span class="line">* fsm.cannot(e) ：返回一个布尔值，表示事件e是否不能在当前状态触发。</span><br></pre></td></tr></table></figure>
<p>Javascript Finite State Machine允许为每个事件指定两个回调函数，以warn事件为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* onbeforewarn：在warn事件发生之前触发。</span><br><span class="line"></span><br><span class="line">* onafterwarn（可简写成onwarn） ：在warn事件发生之后触发。</span><br></pre></td></tr></table></figure>
<p>同时，它也允许为每个状态指定两个回调函数，以green状态为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* onleavegreen ：在离开green状态时触发。</span><br><span class="line"></span><br><span class="line">* onentergreen（可简写成ongreen） ：在进入green状态时触发。</span><br></pre></td></tr></table></figure>
<p>假定warn事件使得状态从green变为yellow，上面四类回调函数的发生顺序如下：onbeforewarn → onleavegreen → onenteryellow → onafterwarn。</p>
<p>除了为每个事件和状态单独指定回调函数，还可以为所有的事件和状态指定通用的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* onbeforeevent ：任一事件发生之前触发。</span><br><span class="line"></span><br><span class="line">* onleavestate ：离开任一状态时触发。</span><br><span class="line"></span><br><span class="line">* onenterstate ：进入任一状态时触发。</span><br><span class="line"></span><br><span class="line">* onafterevent ：任一事件结束后触发。</span><br></pre></td></tr></table></figure>
<h1 id="编码实战"><a href="#编码实战" class="headerlink" title="编码实战"></a>编码实战</h1><p><a href="https://it-xzy.github.io/WEB-NEW/HoverChangeColor.html" target="_blank" rel="noopener">信号灯</a> </p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>JS有哪几种传参方式?</title>
    <url>/2019/10/25/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%833/JS%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>所有函数的参数都是按值传递的,也就是说把函数外部的值赋值给函数内部的参数，就和把值从一个变量赋值到另一个变量一样。</p><p>————《js高级程序设计》</p><p>有的人可能会把这里的js传参方式，理解成js函数中的参数传递，但是呢，我们所要讲的是页面之间的数据传递。</p><p>传统的前端开发中，页面之间是少有参数交互的，甚至没有，而在如今的前端环境下， 一个稍微正式点的项目都不可能少了页面间传参，页面的跨越、服务器后台进行数据请求等，都需要一个或多个传参的方法。 那么参数在不同的页面间进行传递，一个页面的参数被另一页面使用，如何才能做到不同页面间进行参数传递？</p><a id="more"></a>



<h1 id="JS中页面传递参数的方法"><a href="#JS中页面传递参数的方法" class="headerlink" title="JS中页面传递参数的方法"></a>JS中页面传递参数的方法</h1><p>在JS中有多种页面传递参数的方法：<br>一、URL L传参<br>把参数值附在url后面传递到其他页面<br>二、H5 web storage<br>localStroage 和 sessionStorage<br>三、Cookie<br>使用浏览器Cookie传递参数<br>四、Form 表单<br>Form表单通过URL传递参数 </p>
<h2 id="URL传参"><a href="#URL传参" class="headerlink" title="URL传参"></a>URL传参</h2><p>把参数值附在url后面传递到其他页面<br>如： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://xxx.com/login.html?user=laowang&amp;pwd=100</span><br></pre></td></tr></table></figure>
<ul>
<li>其中 <code>user=laowang</code>和 <code>pwd=100</code>就是我们传递的参数名称和值。 </li>
<li>url和参数之间用 “?”隔开 </li>
<li>多个参数之间用 “&amp;”符号连接。 </li>
</ul>
<p>URL地址传递参数的几个特点： </p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>URL地址法简洁易用，可同时传递多个字符型参数； </p>
</li>
<li><p>URL地址法可以很方便的在页面之间切换并传递参数，无需额外的处理，基于正常情况比较性能不会损失； </p>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>URL传递参数长度受限，最大为2K； </p>
</li>
<li><p>URL只能传递字符型参数，传递中文时，由于发送页面和接收页面的字符编码方式不一样而导致参数解析处理错误，参数包含中文时可能出现乱码或者参数接收错误； </p>
</li>
<li>信息泄露：URL地址在客户端可见，所以涉及隐私的参数需进行加密后才能进行传递，不加密传输会导致信息泄露，产生安全隐患。 </li>
</ul>
<h2 id="storage本地存储"><a href="#storage本地存储" class="headerlink" title="storage本地存储"></a>storage本地存储</h2><h3 id="sessionStorage会话存储"><a href="#sessionStorage会话存储" class="headerlink" title="sessionStorage会话存储"></a>sessionStorage会话存储</h3><p>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。</p>
<h3 id="localStorage-本地存储"><a href="#localStorage-本地存储" class="headerlink" title="localStorage 本地存储"></a>localStorage 本地存储</h3><p>localStorage HTML5本地存储web storage特性的API之一，用于将大量数据（最大5M）保存在浏览器中 </p>
<ul>
<li><p>保存后数据永远存在不会失效过期，除非手动清除。 </p>
</li>
<li><p>不参与网络传输。 </p>
</li>
<li><p>一般用于性能优化，可以保存图片、js、css、html 模板、大量数据。 </p>
</li>
<li><p>数据以 键/值 （key/value）对存在, web网页的数据只允许该域访问使用 </p>
</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">保存数据：localStorage.setItem(key,value); </span><br><span class="line"></span><br><span class="line">读取数据：localStorage.getItem(key); </span><br><span class="line"></span><br><span class="line">删除单个数据：localStorage.removeItem(key); </span><br><span class="line"></span><br><span class="line">删除所有数据：localStorage.clear(); </span><br><span class="line"></span><br><span class="line">得到某个索引的key：localStorage.key(index);</span><br></pre></td></tr></table></figure>
<h3 id="数据储存"><a href="#数据储存" class="headerlink" title="数据储存"></a>数据储存</h3><p>在有多组数据需要储存时，一般: </p>
<ul>
<li>建立一个新的对象，然后将多组数据储存在对象中， </li>
<li>使用 JSON.stringify() 来将对象转换为字符串， </li>
<li>使用localStorage.setItem(key,value);保存数据。 </li>
</ul>
<h3 id="数据提取"><a href="#数据提取" class="headerlink" title="数据提取"></a>数据提取</h3><ul>
<li>使用localStorage.getItem(key)读取数据 </li>
<li>使用 JSON.parse 方法将字符串转换为 JSON 对象。 </li>
<li>直接引用对象的各个值。 </li>
</ul>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="Cookie是什么"><a href="#Cookie是什么" class="headerlink" title="Cookie是什么"></a>Cookie是什么</h3><p>Cookie是当你浏览某网站时，网站存储在你机器上的一个小文本文件，<br>它记录了你的用户ID，密码、浏览过的网页、停留的时间等信息，当你再次来到该网站时，<br>网站通过读取Cookie，得知你的相关信息，就可以做出相应的动作，如在页面显示欢迎你的标语，<br>或者让你不用输入ID、密码就直接登录等等 </p>
<h3 id="Cookie作用"><a href="#Cookie作用" class="headerlink" title="Cookie作用"></a>Cookie作用</h3><p>Cookie一般有两个作用。<br><strong>第一个作用是识别用户身份。</strong><br>比如用户 A 用浏览器访问了 <a href="http://a.com" target="_blank" rel="noopener">http://a.com</a>，那么 <a href="http://a.com" target="_blank" rel="noopener">http://a.com</a> 的服务器就会立刻给 A 返回一段数据「uid=1」（这就是 Cookie）。当 A 再次访问 <a href="http://a.com" target="_blank" rel="noopener">http://a.com</a> 的其他页面时，就会附带上「uid=1」这段数据。 </p>
<p>同理，用户 B 用浏览器访问 <a href="http://a.com" target="_blank" rel="noopener">http://a.com</a> 时，<a href="http://a.com" target="_blank" rel="noopener">http://a.com</a> 发现 B 没有附带 uid 数据，就给 B 分配了一个新的 uid，为2，然后返回给 B 一段数据「uid=2」。B 之后访问 <a href="http://a.com" target="_blank" rel="noopener">http://a.com</a> 的时候，就会一直带上「uid=2」这段数据。 借此，<a href="http://a.com" target="_blank" rel="noopener">http://a.com</a> 的服务器就能区分 A 和 B 两个用户了。 </p>
<p><strong>第二个作用是记录历史。</strong><br>假设 <a href="http://a.com" target="_blank" rel="noopener">http://a.com</a> 是一个购物网站，当 A 在上面将商品 A1 、A2 加入购物车时，JS 可以改写 Cookie，改为「uid=1; cart=A1,A2」，表示购物车里有 A1 和 A2 两样商品了。 这样一来，当用户关闭网页，过三天再打开网页的时候，依然可以看到 A1、A2 躺在购物车里，因为浏览器并不会无缘无故地删除这个 Cookie。 借此，就达到里记录用户操作历史的目的了。 </p>
<h3 id="Cookie的特点"><a href="#Cookie的特点" class="headerlink" title="Cookie的特点"></a>Cookie的特点</h3><ul>
<li>Cookie可以使用 js 在浏览器直接设置（用于记录不敏感信息，如用户名）, 也可以在服务端通使用 HTTP 协议规定的 set-cookie 来让浏览器种下Cookie，这是最常见的做法。 </li>
<li>每次网络请求 Request headers 中都会带上Cookie。所以如果 Cookie太多太大对传输效率会有影响。 </li>
<li>一般浏览器存储Cookie最大容量为4k，所以大量数据不要存到Cookie。 </li>
</ul>
<h2 id="Form-表单"><a href="#Form-表单" class="headerlink" title="Form 表单"></a>Form 表单</h2><p>Form表单传值也是通过URL传递参数</p>
<p>跳转至demo2.com时，<br>url为: demo2.com?id=laowang&amp;name=666666 </p>
<p>通常使用的表单的提交方式主要是： post和get两种。 </p>
<p>两者的区别在于：</p>
<p>post方式是把数据内容放在请求的数据正文部分，没有长度的限制;<br>get方式则是把数据内容直接跟在请求的头部的URL后面，有长度的限制。<br>而一般在表单的数据提交中，都会选择POST方式，<br>因为使用GET方法数据是通过URL传递的，在地址栏中会直接看到传递的数据，这样就缺少安全性。<br>而使用POST传递时，是把提交的数据放置在HTTP包的包体中，地址栏不会看到数据。 </p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>既然有如此多种页面传参的方式。那么问题来就来了，在什么情况下，适合使用以上介绍的传递方式呢？ </p>
<p>在<strong>传递少量不涉及隐私的参数</strong>时可以使用直接url或者Form的GET方式传递；</p>
<p><strong>大量数据</strong>可以用POST传递会话信息等可以用cookie和localStorage；</p>
<p><strong>临时数据</strong>可用sessionStorage </p>
<h2 id="传参方式的优缺点"><a href="#传参方式的优缺点" class="headerlink" title="传参方式的优缺点"></a>传参方式的优缺点</h2><p><strong>URL传参：</strong><br>优点：取值方便，可以跨域。<br>缺点：值长度有限制。 </p>
<p><strong>H5 Web storage：</strong><br>优点：使用起来非常简单、方便。<br>缺点：兼容性有点小问题。兼容性： 现代浏览器（firefox safari chrome opera）都支持，IE8以下（不包括IE8）不支持。 </p>
<p><strong>Cookie传参：</strong><br>优点：兼容性最好，可以在同源内的任意网页内访问，生命期可以设置。<br>缺点：值长度有限制（存储的容量小），还得注意请求接口时别带到http head。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>参考一：js传参方式<br>参考二：理解cookie及其用法<br>参考三：web Storage </p>
<p>来源： <a href="https://blog.csdn.net/menggx1/article/details/80311369" target="_blank" rel="noopener">https://blog.csdn.net/menggx1/article/details/80311369</a></p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>洗牌算法具体指的是什么？</title>
    <url>/2019/10/24/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%832/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95%E5%85%B7%E4%BD%93%E6%8C%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>洗牌算法是我们常见的随机问题，在玩游戏、随机排序时经常会碰到，本质是让一个数组内的元素随机排列，即数组乱序。</p><h1 id="Fisher–Yates-Shuffle"><a href="#Fisher–Yates-Shuffle" class="headerlink" title="Fisher–Yates Shuffle"></a>Fisher–Yates Shuffle</h1><p>关于数组乱序，正确的解法应该是 <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" target="_blank" rel="noopener">Fisher–Yates Shuffle</a>，复杂度 O(n)。</p><p>其实它的思想非常的简单，遍历数组元素，将其与之前的任意元素交换。因为遍历有从前向后和从后往前两种方式，所以该算法大致也有两个版本的实现。</p><a id="more"></a>


<p>从后往前的版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function shuffle(array) &#123;</span><br><span class="line">  var _array = array.concat();</span><br><span class="line"></span><br><span class="line">  for (var i = _array.length; i--; ) &#123;</span><br><span class="line">    var j = Math.floor(Math.random() * (i + 1));</span><br><span class="line">    var temp = _array[i];</span><br><span class="line">    _array[i] = _array[j];</span><br><span class="line">    _array[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return _array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>underscore 中采用从前往后遍历元素的方式，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Shuffle a collection, using the modern version of the</span><br><span class="line">// [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).</span><br><span class="line">_.shuffle = function(obj) &#123;</span><br><span class="line">  var set = isArrayLike(obj) ? obj : _.values(obj);</span><br><span class="line">  var length = set.length;</span><br><span class="line">  var shuffled = Array(length);</span><br><span class="line">  for (var index = 0, rand; index &lt; length; index++) &#123;</span><br><span class="line">    rand = _.random(0, index);</span><br><span class="line">    if (rand !== index) shuffled[index] = shuffled[rand];</span><br><span class="line">    shuffled[rand] = set[index];</span><br><span class="line">  &#125;</span><br><span class="line">  return shuffled;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将其解耦分离出来，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function shuffle(a) &#123;</span><br><span class="line">  var length = a.length;</span><br><span class="line">  var shuffled = Array(length);</span><br><span class="line"></span><br><span class="line">  for (var index = 0, rand; index &lt; length; index++) &#123;</span><br><span class="line">    rand = ~~(Math.random() * (index + 1));</span><br><span class="line">    if (rand !== index) </span><br><span class="line">      shuffled[index] = shuffled[rand];</span><br><span class="line">    shuffled[rand] = a[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return shuffled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟前面一样，做了下数据图表，猛戳 <a href="http://hanzichi.github.io/test-case/shuffle/Fisher-Yates/" target="_blank" rel="noopener">http://hanzichi.github.io/test-case/shuffle/Fisher-Yates/</a>。</p>
<p>关于证明，引用自月影老师的<a href="https://www.h5jun.com/post/array-shuffle.html" target="_blank" rel="noopener">文章</a>：</p>
<h1 id="随机性的数学归纳法证明"><a href="#随机性的数学归纳法证明" class="headerlink" title="随机性的数学归纳法证明"></a><strong>随机性的数学归纳法证明</strong></h1><p>对 n 个数进行随机：</p>
<ol>
<li>首先我们考虑 n = 2 的情况，根据算法，显然有 1/2 的概率两个数交换，有 1/2 的概率两个数不交换，因此对 n = 2 的情况，元素出现在每个位置的概率都是 1/2，满足随机性要求。</li>
<li>假设有 i 个数， i &gt;= 2 时，算法随机性符合要求，即每个数出现在 i 个位置上每个位置的概率都是 1/i。</li>
<li>对于 i + 1 个数，按照我们的算法，在第一次循环时，每个数都有 1/(i+1) 的概率被交换到最末尾，所以每个元素出现在最末一位的概率都是 1/(i+1) 。而每个数也都有 i/(i+1) 的概率不被交换到最末尾，如果不被交换，从第二次循环开始还原成 i 个数随机，根据 2. 的假设，它们出现在 i 个位置的概率是 1/i。因此每个数出现在前 i 位任意一位的概率是 (i/(i+1)) * (1/i) = 1/(i+1)，也是 1/(i+1)。</li>
<li>综合 1. 2. 3. 得出，对于任意 n &gt;= 2，经过这个算法，每个元素出现在 n 个位置任意一个位置的概率都是 1/n。</li>
</ol>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>关于数组乱序，如果面试中被问到，能说出 “Fisher–Yates Shuffle”，并且能基本说出原理（你也看到了，其实代码非常的简单），那么基本应该没有问题了；如果能更进一步，将其证明呈上（甚至一些面试官都可能一时证明不了），那么就牛逼了。千万不能只会用 Math.random() 投机取巧！</p>
<p>来源： <a href="https://segmentfault.com/a/1190000005875191" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005875191</a></p>
<h1 id="Read-More："><a href="#Read-More：" class="headerlink" title="Read More："></a><strong>Read More：</strong></h1><ul>
<li><a href="https://www.h5jun.com/post/array-shuffle.html" target="_blank" rel="noopener">数组的完全随机排列</a>（推荐）</li>
<li><a href="https://bost.ocks.org/mike/shuffle/" target="_blank" rel="noopener">Fisher–Yates Shuffle</a>（推荐）</li>
<li><a href="http://coolshell.cn/articles/8593.html" target="_blank" rel="noopener">如何测试洗牌程序</a></li>
<li><a href="http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array" target="_blank" rel="noopener">How to randomize (shuffle) a JavaScript array?</a></li>
<li><a href="https://www.kirupa.com/html5/shuffling_array_js.htm" target="_blank" rel="noopener">Code for Shuffling an Array</a></li>
</ul>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>常见Dom操作有哪些？</title>
    <url>/2019/10/24/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%832/%E5%B8%B8%E8%A7%81Dom%E6%93%8D%E4%BD%9C%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1.背景介绍"></a>1.背景介绍</h1><p>DOM（文档对象模型）是针对HTML 和XML 文档的一个API（应用程序编程接口）。DOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。DOM脱胎于</p><p>Netscape 及微软公司创始的DHTML（动态HTML），但现在它已经成为表现和操作页面标记的真正的跨平台、语言中立的方式。1998 年10 月DOM１级规范成为W3C 的推荐标准，为基本的文档结构及查询提供了接口。本章主要讨论与浏览器中的HTML页面相关的DOM1级的特性和应用，以及JavaScript 对DOM1级的实现。IE、Firefox、Safari、Chrome 和Opera 都非常完善地实现了DOM。</p><a id="more"></a>

<h1 id="2-知识剖析"><a href="#2-知识剖析" class="headerlink" title="2.知识剖析"></a>2.知识剖析</h1><h2 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h2><p>DOM 是 Document Object Model（文档对象模型）的缩写。DOM是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。在 HTML DOM中，所有事物都是节点。DOM 是被视为节点树的 HTML。DOM节点HTML 文档中的所有内容都是节点。整个文档是一个文档节点,每个 HTML 元素是元素节点，HTML 元素内的文本是文本节点，每个 HTML 属性是属性节点，注释是注释节点。</p>
<h2 id="DOM常用操作"><a href="#DOM常用操作" class="headerlink" title="DOM常用操作"></a>DOM常用操作</h2><ul>
<li>查找节点</li>
<li>新建节点</li>
<li>添加节点</li>
<li>删除节点</li>
<li>修改节点</li>
</ul>
<p>我们用到最多的是element类型，用于表现HTML元素，提供了对元素标签名、子节点及特性的访问。</p>
<h2 id="DOM常用操作举例"><a href="#DOM常用操作举例" class="headerlink" title="DOM常用操作举例"></a>DOM常用操作举例</h2><h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementById(&apos;id属性值&apos;);返回拥有指定id的第一个对象的引用 document/element.getElementsByClassName(&apos;class属性值&apos;);返回拥有指定class的对象集合</span><br></pre></td></tr></table></figure>
<h3 id="新建节点"><a href="#新建节点" class="headerlink" title="新建节点"></a>新建节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.createElement(&apos;元素名&apos;);创建新的元素节点</span><br><span class="line"></span><br><span class="line">document.createAttribute(&apos;属性名&apos;);创建新的属性节点</span><br><span class="line"></span><br><span class="line">document.createTextNode(&apos;文本内容&apos;);创建新的文本节点</span><br><span class="line"></span><br><span class="line">document.createComment(&apos;注释节点&apos;);创建新的注释节点</span><br><span class="line"></span><br><span class="line">document.createDocumentFragment( );创建文档片段节点xxxxxxxxxx</span><br></pre></td></tr></table></figure>
<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>常用来添加文本节点<code>element.innerHTML=&#39;新增文本内容&#39;</code></p>
<p>创建文本节点 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function addText()&#123;</span><br><span class="line"></span><br><span class="line">var element = document.getElementsByTagName(&apos;p&apos;)[0];</span><br><span class="line"></span><br><span class="line">element.innerHTML=&apos;新增文本内容&apos;; //插入文本内容</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parentNode.removeChild( existingChild );删除已有的子节点，返回值为删除节点</span><br><span class="line"></span><br><span class="line">element.removeAttribute(&apos;属性名&apos;);删除具有指定属性名称的属性，无返回值</span><br><span class="line"></span><br><span class="line">element.removeAttributeNode( attrNode );删除指定属性，返回值为删除的属性</span><br></pre></td></tr></table></figure>
<h3 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h3><p>添加属性节点，修改属性值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element.setAttribute( attributeName, attributeValue );</span><br></pre></td></tr></table></figure>
<p>属性节点 增添id属性，并修改class属性值</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var element = document.getElementsByTagName(&apos;p&apos;)[0];</span><br><span class="line">// 添加属性节点</span><br><span class="line">var attr = document.createAttribute(&apos;id&apos;);</span><br><span class="line">attr.value = &apos;idValue&apos;;</span><br><span class="line">element.setAttributeNode(attr);</span><br><span class="line">// 修改属性值</span><br><span class="line">var attr = document.createAttribute(&apos;class&apos;);</span><br><span class="line">attr.value = &apos;classNewValue&apos;;</span><br><span class="line">element.setAttributeNode(attr);</span><br></pre></td></tr></table></figure>
<h2 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h2><p>允许 JavaScript 对 HTML 事件作出反应</p>
<p>onclick 事件——当用户点击时</p>
<p>onload 事件——用户进入</p>
<p>onunload 事件——用户离开</p>
<p>onmouseover事件——鼠标移入</p>
<p>onmouseout事件——鼠标移出</p>
<p>onmousedown事件——鼠标按下</p>
<p>onmouseup 事件——鼠标抬起</p>
<h1 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3.常见问题"></a>3.常见问题</h1><p>如何通过class和tag调用元素?如何对其设置属性？</p>
<h1 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4.解决方案"></a>4.解决方案</h1><p>一个页面中常常有多个class相同的元素，也有多个标签相同的元素，在调用时方法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementsByClassName(&quot;time&quot;)[0].innerHTML = &quot;16:43&quot;;</span><br><span class="line"></span><br><span class="line">document.getElementsByClassName(&quot;time&quot;)[1].innerHTML = &quot;16:44&quot;;</span><br><span class="line"></span><br><span class="line">document.getElementsByTagName(&quot;div&quot;)[0].className = &quot;text-time&quot;;</span><br></pre></td></tr></table></figure>
<h1 id="5-编码实战"><a href="#5-编码实战" class="headerlink" title="5.编码实战"></a>5.编码实战</h1><h1 id="6-扩展思考"><a href="#6-扩展思考" class="headerlink" title="6.扩展思考"></a>6.扩展思考</h1><p>Html5添加了辅助管理DOM焦点的功能。首先就是document.activeElement属性，这个属性始终会引用DOM中当前获得了焦点的元素。另外就是新增了document.hasFocus()方法，这个方法用于确定文档是否获得了焦点。</p>
<h1 id="7-参考文献"><a href="#7-参考文献" class="headerlink" title="7.参考文献"></a>7.参考文献</h1><p>参考一：《JavaScript高级程序设计》</p>
<p>参考二：<a href="http://blog.csdn.net/ouyangyanlan/article/details/50217065" target="_blank" rel="noopener"> DOM树知识点梳理 </a></p>
<h1 id="8-更多讨论"><a href="#8-更多讨论" class="headerlink" title="8.更多讨论"></a>8.更多讨论</h1><h2 id="怎样在一个元素节点之前加入新的节点？"><a href="#怎样在一个元素节点之前加入新的节点？" class="headerlink" title="怎样在一个元素节点之前加入新的节点？"></a>怎样在一个元素节点之前加入新的节点？</h2><p>insertBefore(参数1，参数2)：在指定位置添加节点</p>
<h2 id="classlist和classname的区别？"><a href="#classlist和classname的区别？" class="headerlink" title="classlist和classname的区别？"></a>classlist和classname的区别？</h2><p>classlist为了解决classname一刀切的问题而诞生，类似于jquery的选择器，但明显不如jquery方便简洁，无视就好</p>
<h2 id="如何查找兄弟节点？"><a href="#如何查找兄弟节点？" class="headerlink" title="如何查找兄弟节点？"></a>如何查找兄弟节点？</h2><p>Query对象返回，children()则只会返回节点</p>
<p>jQuery.prev()，返回上一个兄弟节点，不是所有的兄弟节点</p>
<p>jQuery.prevAll()，返回所有之前的兄弟节点</p>
<p>jQuery.next(),返回下一个兄弟节点，不是所有的兄弟节点</p>
<p>jQuery.nextAll()，返回所有之后的兄弟节点</p>
<p>jQuery.siblings(),返回兄弟姐妹节点，不分前后</p>
<p>getelementsbyclassname获取的是什么，有何特点？</p>
<p>获取的是类似数组类的对象，可以理解成元素的数组，但是不能像数组一样push，确切的说是个伪数组，它只支持length属性。</p>
<p>链接：<a href="https://www.jianshu.com/p/870830fcec58" target="_blank" rel="noopener">https://www.jianshu.com/p/870830fcec58</a></p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>webpack打包报错：clean-webpack-plugin only accepts an options object</title>
    <url>/2019/10/24/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/webpack%E6%89%93%E5%8C%85%E6%8A%A5%E9%94%99%EF%BC%9Aclean-webpack-plugin-only-accepts-an-options-object/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><p>webpack 4.41.2<br>clean-webpack-plugin 3.0.0</p><h2 id="webpack打包报错信息"><a href="#webpack打包报错信息" class="headerlink" title="webpack打包报错信息"></a>webpack打包报错信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean-webpack-plugin only accepts an options object.</span><br></pre></td></tr></table></figure><h2 id="Webpack-Config"><a href="#Webpack-Config" class="headerlink" title="Webpack Config"></a>Webpack Config</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: &apos;./src/index.js&apos;,</span><br><span class="line">        print: &apos;./src/print.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new CleanWebpackPlugin([&apos;dist&apos;]),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            title: &apos;Output Management&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;[name].bundle.js&apos;,</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h1 id="问题解决过程"><a href="#问题解决过程" class="headerlink" title="问题解决过程"></a>问题解决过程</h1><p>查看clean-webpack-plugin官方文档的例子,发现其创建实例的时候没有引入参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;); // installed via npm</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); // installed via npm</span><br><span class="line">const webpack = require(&apos;webpack&apos;); // to access built-in plugins</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        /**</span><br><span class="line">         * With zero configuration,</span><br><span class="line">         *   clean-webpack-plugin will remove files inside the directory below</span><br><span class="line">         */</span><br><span class="line">        path: path.resolve(process.cwd(), &apos;dist&apos;),</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(js|jsx)$/,</span><br><span class="line">                loader: &apos;babel-loader&apos;,</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.ProgressPlugin(),</span><br><span class="line">        /**</span><br><span class="line">         * 无参数</span><br><span class="line">         */</span><br><span class="line">        new CleanWebpackPlugin(),</span><br><span class="line">        new HtmlWebpackPlugin(&#123; template: &apos;./src/index.html&apos; &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="问题出现原因"><a href="#问题出现原因" class="headerlink" title="问题出现原因"></a>问题出现原因</h1><p>插件更新，改变了使用方式</p>
<h1 id="问题解决方案"><a href="#问题解决方案" class="headerlink" title="问题解决方案"></a>问题解决方案</h1><p>去除传递的参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: &apos;./src/index.js&apos;,</span><br><span class="line">        print: &apos;./src/print.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new CleanWebpackPlugin(),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            title: &apos;Output Management&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;[name].bundle.js&apos;,</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>过时的资料害死人啊</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack打包报错CleanWebpackPlugin is not a constructor</title>
    <url>/2019/10/24/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/webpack%E6%89%93%E5%8C%85%E6%8A%A5%E9%94%99CleanWebpackPlugin-is-not-a-constructor/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><p>webpack 4.41.2<br>clean-webpack-plugin 3.0.0</p><h2 id="webpack打包报错信息"><a href="#webpack打包报错信息" class="headerlink" title="webpack打包报错信息"></a>webpack打包报错信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CleanWebpackPlugin is not a constructor.</span><br></pre></td></tr></table></figure><h2 id="Webpack-Config"><a href="#Webpack-Config" class="headerlink" title="Webpack Config"></a>Webpack Config</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &apos;./src/index.js&apos;,</span><br><span class="line">    print: &apos;./src/print.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new CleanWebpackPlugin([&apos;dist&apos;]),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: &apos;Output Management&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &apos;[name].bundle.js&apos;,</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h1 id="问题解决过程"><a href="#问题解决过程" class="headerlink" title="问题解决过程"></a>问题解决过程</h1><p>查看clean-webpack-plugin官方文档的例子,发现其声明方式和webpack官方文档中的不一样。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;); // 声明方式和webpack官方文档中的不一样</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); // installed via npm</span><br><span class="line">const webpack = require(&apos;webpack&apos;); // to access built-in plugins</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./path/to/my/entry/file.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        /**</span><br><span class="line">         * With zero configuration,</span><br><span class="line">         *   clean-webpack-plugin will remove files inside the directory below</span><br><span class="line">         */</span><br><span class="line">        path: path.resolve(process.cwd(), &apos;dist&apos;),</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.(js|jsx)$/,</span><br><span class="line">                loader: &apos;babel-loader&apos;,</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.ProgressPlugin(),</span><br><span class="line">        new CleanWebpackPlugin(),</span><br><span class="line">        new HtmlWebpackPlugin(&#123; template: &apos;./src/index.html&apos; &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="问题出现原因"><a href="#问题出现原因" class="headerlink" title="问题出现原因"></a>问题出现原因</h1><p>插件更新，改变了使用方式</p>
<h1 id="问题解决方案"><a href="#问题解决方案" class="headerlink" title="问题解决方案"></a>问题解决方案</h1><p>使用clean-webpack-plugin官方文档中的声明方式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const &#123; CleanWebpackPlugin &#125; = require(&apos;clean-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: &apos;./src/index.js&apos;,</span><br><span class="line">        print: &apos;./src/print.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new CleanWebpackPlugin([&apos;dist&apos;]),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            title: &apos;Output Management&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;[name].bundle.js&apos;,</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>过时的资料害死人啊</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack使用官方例子运行index.html报错</title>
    <url>/2019/10/24/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/webpack%E4%BD%BF%E7%94%A8%E5%AE%98%E6%96%B9%E4%BE%8B%E5%AD%90%E8%BF%90%E8%A1%8Cindex-html%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>webpack版本4.4.12<br>webpack使用官方例子运行index.html报错</p><h2 id="报错代码"><a href="#报错代码" class="headerlink" title="报错代码"></a>报错代码</h2><p>具体代码与官方例子完全相同（起步部分-创建一个 bundle 文件）<br><a href="https://www.webpackjs.com/guides/getting-started/#%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">起步部分-创建一个 bundle 文件</a></p><h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g89egfbdntj30qz08habh.jpg" alt="d5b088f3-de2d-46ac-8acc-c8f5f9961a1b.jpg"></p><h1 id="问题解决过程"><a href="#问题解决过程" class="headerlink" title="问题解决过程"></a>问题解决过程</h1><p>我注意到html的标题和报错中都出现了乱码，猜测可能时识别中文时出现了错误。然后我观察html文件,发现其未设置HTML编码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;起步&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><a id="more"></a>



<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>为html设置编码utf-8<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;起步&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>github新建项目以及本地项目关联远程库</title>
    <url>/2019/10/24/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/github%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%BB%A5%E5%8F%8A%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E5%BA%93/</url>
    <content><![CDATA[<p>github已经是我们不能忽略的远程仓库托管了，今天对创建新项目和上传记录一下过程。</p><h1 id="github新建项目"><a href="#github新建项目" class="headerlink" title="github新建项目"></a>github新建项目</h1><p>第一步：登录你的github账号</p><p>第二步：点击创建的 “+”，选择 New repositories</p><p><img src="https://upload-images.jianshu.io/upload_images/2241258-2c742ee02543ee4d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"> </p><p>第三步：填写先关信息</p><p><img src="https://upload-images.jianshu.io/upload_images/2241258-66e88119fd307e39.png?imageMogr2/auto-orient/strip|imageView2/2/w/1101/format/webp" alt="img"> </p><p>第四步：点击 Create repository创建。之后会出现以下界面的信息。</p><a id="more"></a>






<p><img src="https://upload-images.jianshu.io/upload_images/2241258-833c3e432af84108.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"> </p>
<h1 id="本地项目同步至github远程库"><a href="#本地项目同步至github远程库" class="headerlink" title="本地项目同步至github远程库"></a>本地项目同步至github远程库</h1><p>接下来讲解一下如何将创建的工程同步到github上。</p>
<ul>
<li>第一步：创建工程之后，用终端进入工程。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  cd /Users/hanwenguang/Desktop/pods/TestPreject</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步：建立本地仓库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  git init</span><br></pre></td></tr></table></figure>
<ul>
<li>第三步：将本地项目工作区的所有文件添加到暂存区</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  git add .</span><br></pre></td></tr></table></figure>
<ul>
<li>第四步：将暂存区的文件提交到本地仓库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  git commit -m “注释&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>第五步： 在Github上创建自己的 New repository</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">与第一部分的1-4步骤相同。</span><br></pre></td></tr></table></figure>
<ul>
<li>第六步：将本地仓库关联到Github上（后加上仓库地址：第一部分中第五步的<em>地址</em>）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  git remote add origin 地址</span><br></pre></td></tr></table></figure>
<ul>
<li>第七步：将代码由本地仓库上传到Github远程仓库，刷新即可看到上传成功。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//(不加这句可能报错出现错误的主要原因是github中的README.md文件不在本地代码目录中</span><br><span class="line">$  git pull --rebase origin master </span><br><span class="line">//可以通过该命令进行代码合并</span><br><span class="line">$  git push -u origin master</span><br><span class="line">//需要填写账号、密码时候，自己填写。通常一次通过之后就不需要了。</span><br></pre></td></tr></table></figure>
<h1 id="常用的git命令"><a href="#常用的git命令" class="headerlink" title="常用的git命令"></a>常用的git命令</h1><ul>
<li>第一步： 查看目前代码的修改状态:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  git status</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步： 查看代码修改的内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  git diff &lt;file&gt;</span><br><span class="line">    //如果该文件已暂存，那么应该使用</span><br><span class="line">$  git diff –cached &lt;file&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>第三步： 暂存需要提交的文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  git add &lt;file&gt;</span><br><span class="line">    //如果是删除的文件则</span><br><span class="line">$  git rm &lt;file&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>第四步 ： 提交已暂存的文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  git commit -m &quot;注释内容&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>第五步： 同步到服务器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">同步到服务器前先需要将服务器代码同步到本地</span><br><span class="line">命令：$  git pull</span><br><span class="line">如果执行失败，就按照提示还原有冲突的文件，然后再次尝试同步。</span><br><span class="line">命令：$  git checkout – &lt;有冲突的文件路径&gt;</span><br><span class="line">同步到服务器</span><br><span class="line">命令：$  git push origin master</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/6969de20cd52" target="_blank" rel="noopener">github新建项目并提交</a></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title>css动画animation绘制向四周扩散的圆圈</title>
    <url>/2019/10/23/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/css%E5%8A%A8%E7%94%BBanimation%E7%BB%98%E5%88%B6%E5%90%91%E5%9B%9B%E5%91%A8%E6%89%A9%E6%95%A3%E7%9A%84%E5%9C%86%E5%9C%88/</url>
    <content><![CDATA[<h1 id="CSS3-动画animation"><a href="#CSS3-动画animation" class="headerlink" title="CSS3 动画animation"></a>CSS3 动画animation</h1><p>CSS3 可以创建动画，它可以取代许多网页动画图像、Flash 动画和 JavaScript 实现的效果。 </p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">animation: name duration timing-function delay iteration-count direction fill-mode play-state;</span><br></pre></td></tr></table></figure><a id="more"></a>

<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>animation-name</em></td>
<td>指定要绑定到选择器的关键帧的名称</td>
</tr>
<tr>
<td><em>animation-duration</em></td>
<td>动画指定需要多少秒或毫秒完成</td>
</tr>
<tr>
<td><em>animation-timing-function</em></td>
<td>设置动画将如何完成一个周期</td>
</tr>
<tr>
<td><em>animation-delay</em></td>
<td>设置动画在启动前的延迟间隔。</td>
</tr>
<tr>
<td><em>animation-iteration-count</em></td>
<td>定义动画的播放次数。</td>
</tr>
<tr>
<td><em>animation-direction</em></td>
<td>指定是否应该轮流反向播放动画。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-fill-mode.html" target="_blank" rel="noopener">animation-fill-mode</a></td>
<td>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。</td>
</tr>
<tr>
<td><em>animation-play-state</em></td>
<td>指定动画是否正在运行或已暂停。</td>
</tr>
<tr>
<td>initial</td>
<td>设置属性为其默认值。 <a href="https://www.runoob.com/cssref/css-initial.html" target="_blank" rel="noopener">阅读关于 <em>initial</em>的介绍。</a></td>
</tr>
<tr>
<td>inherit</td>
<td>从父元素继承属性。 <a href="https://www.runoob.com/cssref/css-inherit.html" target="_blank" rel="noopener">阅读关于 <em>initinherital</em>的介绍。</a></td>
</tr>
</tbody>
</table>
<h2 id="CSS3-keyframes-规则"><a href="#CSS3-keyframes-规则" class="headerlink" title="CSS3 @keyframes 规则"></a>CSS3 @keyframes 规则</h2><p>要创建 CSS3 动画，你需要了解 @keyframes 规则。</p>
<p>@keyframes 规则是创建动画。</p>
<p>@keyframes 规则内指定一个 CSS 样式和动画将逐步从目前的样式更改为新的样式。</p>
<h2 id="CSS3的动画属性"><a href="#CSS3的动画属性" class="headerlink" title="CSS3的动画属性"></a>CSS3的动画属性</h2><p>下面的表格列出了 @keyframes 规则和所有动画属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>CSS</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-keyframes.html" target="_blank" rel="noopener">@keyframes</a></td>
<td>规定动画。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation.html" target="_blank" rel="noopener">animation</a></td>
<td>所有动画属性的简写属性，除了 animation-play-state 属性。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-name.html" target="_blank" rel="noopener">animation-name</a></td>
<td>规定 @keyframes 动画的名称。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-duration.html" target="_blank" rel="noopener">animation-duration</a></td>
<td>规定动画完成一个周期所花费的秒或毫秒。默认是 0。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-timing-function.html" target="_blank" rel="noopener">animation-timing-function</a></td>
<td>规定动画的速度曲线。默认是 “ease”。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-fill-mode.html" target="_blank" rel="noopener">animation-fill-mode</a></td>
<td>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-delay.html" target="_blank" rel="noopener">animation-delay</a></td>
<td>规定动画何时开始。默认是 0。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-iteration-count.html" target="_blank" rel="noopener">animation-iteration-count</a></td>
<td>规定动画被播放的次数。默认是 1。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-direction.html" target="_blank" rel="noopener">animation-direction</a></td>
<td>规定动画是否在下一周期逆向地播放。默认是 “normal”。</td>
<td>3</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/cssref/css3-pr-animation-play-state.html" target="_blank" rel="noopener">animation-play-state</a></td>
<td>规定动画是否正在运行或暂停。默认是 “running”。</td>
<td>3</td>
</tr>
</tbody>
</table>
<h1 id="编码实战"><a href="#编码实战" class="headerlink" title="编码实战"></a>编码实战</h1><p>使用css动画绘制向四周扩散的圆圈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;圆形扩散&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .pr&#123;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    .one</span><br><span class="line">    &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        width:100px;</span><br><span class="line">        height:100px;</span><br><span class="line">        border: 1px solid green ;</span><br><span class="line">        border-radius:50%;</span><br><span class="line">        animation:myOne 2s ease-out;</span><br><span class="line">        animation-iteration-count: infinite;</span><br><span class="line">    &#125;</span><br><span class="line">    .two&#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        width:100px;</span><br><span class="line">        height:100px;</span><br><span class="line">        border: 1px solid green  ;</span><br><span class="line">        border-radius:50%;</span><br><span class="line">        animation:myTwo 2s ease-out;</span><br><span class="line">        animation-iteration-count: infinite;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @keyframes myOne</span><br><span class="line">    &#123;</span><br><span class="line">        0%   &#123;</span><br><span class="line">            transform: scale(1);</span><br><span class="line">            opacity: 1;</span><br><span class="line">        &#125;</span><br><span class="line">        25%   &#123;</span><br><span class="line">            transform: scale(1.25);</span><br><span class="line">            opacity: 0.5;</span><br><span class="line">        &#125;</span><br><span class="line">        50%   &#123;</span><br><span class="line">            transform: scale(1.25);</span><br><span class="line">            opacity: 0.25;</span><br><span class="line">        &#125;</span><br><span class="line">        100%   &#123;</span><br><span class="line">            transform: scale(1.5);</span><br><span class="line">            opacity: 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes myTwo</span><br><span class="line">    &#123;</span><br><span class="line">        0%   &#123;</span><br><span class="line">            transform: scale(1);</span><br><span class="line">            opacity: 1;</span><br><span class="line">        &#125;</span><br><span class="line">        25%   &#123;</span><br><span class="line">            transform: scale(1.25);</span><br><span class="line">            opacity: 0.5;</span><br><span class="line">        &#125;</span><br><span class="line">        50%   &#123;</span><br><span class="line">            transform: scale(1.5);</span><br><span class="line">            opacity: 0.25;</span><br><span class="line">        &#125;</span><br><span class="line">        100%   &#123;</span><br><span class="line">            transform: scale(2);</span><br><span class="line">            opacity: 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;p&gt;&lt;b&gt;注意:&lt;/b&gt; 该实例在 Internet Explorer 9 及更早 IE 版本是无效的。&lt;/p&gt;</span><br><span class="line">&lt;div class=&quot;pr&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;one&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;two&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.runoob.com/cssref/css3-pr-animation.html" target="_blank" rel="noopener">CSS3 animation（动画） 属性</a></p>
<p><a href="http://www.webkaka.com/tutorial/html/2017/071327/" target="_blank" rel="noopener">【css3动画】圆波扩散效果</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
      </categories>
  </entry>
  <entry>
    <title>简述JS中执行环境与作用域的关系？</title>
    <url>/2019/10/23/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%831/%E7%AE%80%E8%BF%B0JS%E4%B8%AD%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="执行环境"><a href="#执行环境" class="headerlink" title="执行环境"></a>执行环境</h1><p> <strong>执行环境</strong>（execution context，为简单起见，有时也称为“环境”）是 JavaScript 中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable  object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。</p><a id="more"></a>
<h2 id="全局执行环境"><a href="#全局执行环境" class="headerlink" title="全局执行环境"></a>全局执行环境</h2><p> 全局执行环境是最外围的一个执行环境。根据 ECMAScript 实现所在的宿主环境不同，表示执行环境的对象也不一样。在 Web 浏览器中，全局执行环境被认为是 window 对象（第 7 章将详细讨论），因此所有全局变量和函数都是作为 window 对象的属性和方法创建的。</p>
<p>某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p> 每个函数都有自己的<strong>执行环境</strong>。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正是由这个方便的机制控制着。<br> 当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>（scope chain）。<strong>作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。</strong>作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation  object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>作用域链与一个执行上下文相关，是内部上下文所有变量对象（包括父变量对象）的列表，用于变量查询。 作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。</li>
<li>代码在执行环境中执行时，执行环境会为变量对象创建作用域链。</li>
<li>作用域链是由变量对象组成的数据对象链。</li>
<li>作用域链的前端，始终是当前函数执行环境的变量对象。</li>
<li>作用域链的最后端，始终是全局执行环境的变量对象。</li>
</ul>
<h1 id="执行环境与作用域的关系"><a href="#执行环境与作用域的关系" class="headerlink" title="执行环境与作用域的关系"></a>执行环境与作用域的关系</h1><p>代码进入到某个<strong>执行环境</strong>，准备执行时，会为该<strong>执行环境</strong>对应的变量对象创建一个<strong>作用域链</strong>。 </p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>JavaScript高级程序设计（第3版）</p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>JS中基本类型和引用类型分别指的的是什么？有何区别？</title>
    <url>/2019/10/23/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%831/JS%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%86%E5%88%AB%E6%8C%87%E7%9A%84%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h1><p>ECMAScript包含两个不同类型的值：基本类型值和引用类型值。</p><ul>
<li>基本类型值指的是简单的数据段；</li>
<li>引用类型值指由多个值构成的对象。</li>
</ul><p>在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。第 3 章讨论了 5 种基本数据类型：Undefined、Null、Boolean、Number 和 String。这 5 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。</p><a id="more"></a>


<p> 引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当我们把变量赋值给一个变量时，解析器首先要做的就是确认这个值是基本类型值还是引用类型值。</p>
<p>基本类型： string,number,boolean,null,undefined</p>
<p>引用类型： Function,Array,Object</p>
<h1 id="基本类型和引用类型的区别"><a href="#基本类型和引用类型的区别" class="headerlink" title="基本类型和引用类型的区别"></a>基本类型和引用类型的区别</h1><h2 id="访问方式的不同"><a href="#访问方式的不同" class="headerlink" title="访问方式的不同"></a>访问方式的不同</h2><table>
<thead>
<tr>
<th style="text-align:center"><strong>访问方式</strong></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">基本类型</td>
<td style="text-align:center">引用类型</td>
</tr>
<tr>
<td style="text-align:center">操作和保存在变量的实际的值</td>
<td style="text-align:center">值保存在内存中，js不允许直接访问内存，在操作的时候，操作的是对象的引用</td>
</tr>
</tbody>
</table>
<h2 id="存储位置的不同"><a href="#存储位置的不同" class="headerlink" title="存储位置的不同"></a>存储位置的不同</h2><table>
<thead>
<tr>
<th style="text-align:center">存储的位置</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">基本类型</td>
<td style="text-align:center">引用类型</td>
</tr>
<tr>
<td style="text-align:center"><strong>保存在栈区</strong><img src="https://images2015.cnblogs.com/blog/1019087/201611/1019087-20161118103248482-166610603.png" alt="img"></td>
<td style="text-align:center"><strong>引用存放在栈区，实际对象保存在堆区</strong><img src="https://images2015.cnblogs.com/blog/1019087/201611/1019087-20161118103316420-2010187687.png" alt="img"></td>
</tr>
</tbody>
</table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/wpp12345/p/6076659.html" target="_blank" rel="noopener">基本类型和引用类型的区别</a></p>
<p><a href="https://www.ituring.com.cn/book/946" target="_blank" rel="noopener">JavaScript高级程序设计（第3版）</a> </p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>F12Console的用法，以及如何Debug程序？</title>
    <url>/2019/10/23/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%831/F12Console%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95Debug%E7%A8%8B%E5%BA%8F%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="F12Console的用法"><a href="#F12Console的用法" class="headerlink" title="F12Console的用法"></a>F12Console的用法</h1><h2 id="JavaScript-Console-对象"><a href="#JavaScript-Console-对象" class="headerlink" title="JavaScript Console 对象"></a>JavaScript Console 对象</h2><p>Console 对象用于 JavaScript 调试。</p><p>JavaScript 原生中默认是没有 Console 对象,这是宿主对象（也就是游览器）提供的内置对象。 用于访问调试控制台, 在不同的浏览器里效果可能不同。</p><p>Console 对象常见的两个用途：</p><a id="more"></a>


<ul>
<li>显示网页代码运行时的错误信息。</li>
<li>提供了一个命令行接口，用来与网页代码互动。</li>
</ul>
<h2 id="常用-Console-调试命令"><a href="#常用-Console-调试命令" class="headerlink" title="常用 Console 调试命令"></a>常用 Console 调试命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&apos;hello&apos;);</span><br><span class="line"></span><br><span class="line">console.info(&apos;信息&apos;);</span><br><span class="line"></span><br><span class="line">console.error(&apos;错误&apos;);</span><br><span class="line"></span><br><span class="line">console.warn(&apos;警告&apos;);</span><br></pre></td></tr></table></figure>
<h1 id="如何Debug程序"><a href="#如何Debug程序" class="headerlink" title="如何Debug程序"></a>如何Debug程序</h1><h2 id="Debug的一般流程"><a href="#Debug的一般流程" class="headerlink" title="Debug的一般流程"></a>Debug的一般流程</h2><ol>
<li>确认Bug是否在本地可以重现。</li>
<li>确认Bug在哪一段代码中。</li>
<li>去除掉所有无关代码，只去调试和Bug相关的代码。</li>
<li>和之前正常运行的版本对比，尝试恢复到之前可以正常运行的代码。</li>
<li>重新写一个小Demo，确认是否可以正常运行，可以的话，移动代码到原有的代码中。</li>
<li>如果本地无法重现，打日志，观察线上行为。</li>
<li>重启服务，重启IDE，重启笔记本，重启服务器。</li>
<li>跟产品经理说这个Bug解决不了，花费的代价很大，不值得。</li>
</ol>
<h2 id="Debug的方法之断点调试"><a href="#Debug的方法之断点调试" class="headerlink" title="Debug的方法之断点调试"></a>Debug的方法之断点调试</h2><p>断点调试是最基础的一个调试方法，在调试的过程中查看变量和函数的变化状态，</p>
<p>这使得不可见的程序运行过程变得可视化。断点调试都在source选项卡中进行。</p>
<p> <img src="https://img-blog.csdnimg.cn/20190706155544493.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qbnNodS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img"> </p>
<p><img src="https://img-blog.csdnimg.cn/20190706155603807.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9qbnNodS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img"> </p>
<p>a.上图source选项代码序列上的蓝色标签即为断点的标识，断点也显示在Breakpoint</p>
<p>选项中，可以在Breakpoint选项卡中勾掉暂时不用的断点，后面再使用的时候可以再</p>
<p>勾选，这样就不用再代码中翻来翻去迷失方向了。</p>
<p>b.这几个小图标前两个和调试时页面的两个按钮相同， 分别是暂停/开始和单步；</p>
<p>往右边两个向上向下的箭头意思是进入函数，和（执行完）跳出函数；后面的一个是</p>
<p>忽略所有断点运行，这样被避免更改完之后，点掉所有断点执行一遍在挨个加断点的尴尬</p>
<p>c. watch窗口： 点击“+”添加一个想要监视的变量，在整个调试过程中，这个变量会一直显示在这里，</p>
<p>就不用在函数之间苦苦寻找，然后再“hover”上去显示它的值，非常适合全局变量的监视。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.runoob.com/w3cnote/javascript-console-object.html" target="_blank" rel="noopener">菜鸟教程</a></p>
<p><a href="https://blog.csdn.net/jnshu_it/article/details/77511725" target="_blank" rel="noopener">F12 console的用法，以及如何debug程序？</a></p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>ID和Class有什么区别？</title>
    <url>/2019/10/23/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%831/ID%E5%92%8CClass%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<p>对于CSS而言，id和class都是选择器，唯一不同的地方在于权重不同。如果只说CSS，上面那一句话就讲完了。拓展出来，对于html而言，id和class都是dom元素的属性值。不同的地方在于id属性的值是唯一的，而class属性值可以重复。id还一个老特性是锚点功能，当浏览器地址栏有一个#xxx，页面会自动滚动到id=xxx的元素上面。</p><a id="more"></a>
<h1 id="二者主要的区别"><a href="#二者主要的区别" class="headerlink" title="二者主要的区别"></a>二者主要的区别</h1><p>　　id你只能用来定义单一元素，定义二个以后。页面不会出现什么问题，但是W3检测的时候认为你页面不符合标准；</p>
<p>​        class是类，同一个class可以定义多个元素。就页面效果而言，两个东西的视觉效果几乎无差别。</p>
<h1 id="id-选择符为什么要少用，它有什么局限性"><a href="#id-选择符为什么要少用，它有什么局限性" class="headerlink" title="id 选择符为什么要少用，它有什么局限性"></a>id 选择符为什么要少用，它有什么局限性</h1><p>　　单一使用的样式用id，需要程序、js动态控制的样式用id，id在页面只能使用一次！提供少用id，因为id可能和页面嵌的程序冲突（比如名称相同等）！</p>
<h1 id="什么时候使用ID，什么时候使用class？"><a href="#什么时候使用ID，什么时候使用class？" class="headerlink" title="什么时候使用ID，什么时候使用class？"></a>什么时候使用ID，什么时候使用class？</h1><p>　　单一的元素，或需要程序、JS控制的东西，需要用id定义；重复使用的元素、类别，用class定义。</p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>定时器有哪些用法？</title>
    <url>/2019/10/23/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%831/%E5%AE%9A%E6%97%B6%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%A8%E6%B3%95%EF%BC%9F/</url>
    <content><![CDATA[<p>JS定时器有以下两个方法：</p><ul>
<li>setInterval() ：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。</li>
<li>setTimeout() ：在指定的毫秒数后调用函数或计算表达式。</li>
</ul><h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setInterval(code,millisec,lang)</span><br></pre></td></tr></table></figure><a id="more"></a>


<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>code</td>
<td>必需。要调用的函数或要执行的代码串。</td>
</tr>
<tr>
<td>millisec</td>
<td>必须。周期性执行或调用 code 之间的时间间隔，以毫秒计。</td>
</tr>
<tr>
<td>lang</td>
<td>可选。 JScript \</td>
<td>VBScript \</td>
<td>JavaScript</td>
</tr>
</tbody>
</table>
<p>以下实例在每 1000 毫秒执行 clock() 函数。实例中也包含了停止执行的按钮:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;clock&quot; /&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">var int=self.setInterval(&quot;clock()&quot;,1000);</span><br><span class="line">function clock()</span><br><span class="line">&#123;</span><br><span class="line">var d=new Date();</span><br><span class="line">var t=d.toLocaleTimeString();</span><br><span class="line">document.getElementById(&quot;clock&quot;).value=t;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;button onclick=&quot;int=window.clearInterval(int)&quot;&gt;停止&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>调用定时器时，连续点击按钮，定时器间隔的时间会变短。<br>造成这个情况的原因很简单，多次启动setInterval事件会造成定时器的时间叠加 这样当然会越来越快。</p>
<p>解决方案：</p>
<p>在函数内部，我们可以先清除定时器，再设置定时器。这样的话，每次点击事件发生时，都把前一个定时器清除，再重先开启一个新的定时器。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var clock;</span><br><span class="line"></span><br><span class="line">function startBtn() &#123;</span><br><span class="line"></span><br><span class="line">clearInterval(clock);</span><br><span class="line"></span><br><span class="line">clock=setInterval(setColor,1000);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(code,millisec,lang)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>code</td>
<td>必需。要调用的函数后要执行的 JavaScript 代码串。</td>
</tr>
<tr>
<td>millisec</td>
<td>必需。在执行代码前需等待的毫秒数。</td>
</tr>
<tr>
<td>lang</td>
<td>可选。脚本语言可以是：JScript \</td>
<td>VBScript \</td>
<td>JavaScript</td>
</tr>
</tbody>
</table>
<p>实例演示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;点击按钮，在等待 3 秒后弹出 &quot;Hello&quot;。&lt;/p&gt;</span><br><span class="line">&lt;button onclick=&quot;myFunction()&quot;&gt;点我&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function myFunction()</span><br><span class="line">&#123;</span><br><span class="line">    setTimeout(function()&#123;alert(&quot;Hello&quot;)&#125;,3000);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>JS有哪些数据类型和常用方法</title>
    <url>/2019/10/23/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%831/JS%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>  ECMAscript中有五种简单数据类型（也称基本数据类型）：Undefined、Null、Boolean、Number和String,还有一种复杂数据类型——Object，Object本质上是由一组无序的名值对组成的。</p><p>  ECMAscript不支持任何创建自定义类型的机制，而所有值最终都将是上述六种数据类型之一。</p><a id="more"></a>

<h2 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h2><p>Undefine类型只有一个值，即特殊的undefined。</p>
<h2 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h2><p>Null类型只有一个值，即特殊的null。从逻辑角度来看，null表示一个空对象指针，所以使用typeof操作符检测null时会返回“object”。</p>
<p>如果定义的变量准备在将来用于保存对象，那么最好将变量初始化为null而不是其他值。这样不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。</p>
<h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><p>Boolean只有两个字面值：true和false。</p>
<p>虽然Boolean类型的字面值只有两个，但是ECMAScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean（）。</p>
<p>流控制语句会自动执行相应的Boolean转换</p>
<h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><p>Number类型用IEEE754来表示正点数和浮点数值。</p>
<p>1.浮点数值</p>
<p>所为浮点数值，就是该数值中必须包括一个小数点，并且小数点后面必须至少有一位数字。</p>
<p>2.数值范围</p>
<p>由于内存的限制，EVMAScript不能保存世界上所有的数值。</p>
<p>3.NaN</p>
<p>NaN，即非数值（Not a Number）是一个特殊数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误）。</p>
<p>NaN有两个特点：首先，任何涉及NaN的操作都会返回NaN。其次，NaN与任何值都不相等，包括NaN本身。</p>
<p>针对这两个特点，ECMAScript定义了isNaN函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。</p>
<p>4.数值转换</p>
<p>有三个函数可以把非数值转换为数值：Number（），parseInt（）和parseFloat（）。</p>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String类型用于表示由零或多个16为Unicod字符组成的字符序列，即字符串。</p>
<p>1.字符表面量</p>
<p>String数据类型包含一些特殊的字符表面量，也叫转义序列，用于表示非打印字符，或者具有其他作用的字符。</p>
<p>2.字符串的特点</p>
<p>ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，他们的值就不能改变。</p>
<p>要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用一个包含新值的字符串填充该变量。</p>
<p>3.转换为字符串</p>
<p>要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的tostring（）方法。</p>
<p>在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String（），这个函数能将任何类型的值转换为字符串。</p>
<p>要把某个值转换为字符串，可以使用加号操作符把它与一个字符串（“”）加在一起。</p>
<h2 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h2><p>ECMAScript中的对象其实就是一组数据和功能的集合。</p>
<p>在ECMAScript中，object类型是所有它的实例的的基础。换句话说，object类型所具有的任何属性和方法也同样存在于更具体的对象中。</p>
<p>object的每个实例都具有下列属性和方法：</p>
<ul>
<li><p>constructor 保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是 Object() 。</p>
</li>
<li><p>hasOwnProperty（propertyName）:用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（ propertyName ）必须以字符串形式指定（例如o.hasOwnProperty(“name”) ）。</p>
</li>
<li><p>isPrototypeOf（object）:用于检查传入的对象是否是传入对象的原型（第 5 章将讨论原型）。</p>
</li>
<li><p>propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用 for-in 语句（本章后面将会讨论）来枚举。与 hasOwnProperty() 方法一样，作为参数的属性名必须以字符串形式指定。</p>
</li>
<li><p>toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应。</p>
</li>
<li><p>toString():返回对象的字符串表示。</p>
</li>
<li><p>valueOf():返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值</p>
</li>
</ul>
<p>相同。</p>
<h2 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h2><p>由于ECMASrcipt是松散类型的，因此需要有一种手段来检测给定变量的数据类型——typeof就是负责提供这方面信息的操作符。</p>
<p>对一个值使用typeof操作符可能返回下列某个字符串：</p>
<p>1.undefined——如果这个值未定义；</p>
<p>2.boolean——如果这个值是布尔值；</p>
<p>3.string——如果这个值是字符串；</p>
<p>4.number——如果这个值是数值；</p>
<p>5.object——如果这个值是对象或者null；</p>
<p>6.function——如果这个值是函数。</p>
<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="JS选取DOM元素的方法"><a href="#JS选取DOM元素的方法" class="headerlink" title="JS选取DOM元素的方法"></a>JS选取DOM元素的方法</h2><p>注意：原生JS选取DOM元素比使用jQuery类库选取要快很多<br>1、通过ID选取元素<br><code>document.getElementById(&#39;myid&#39;);</code><br>2、通过CLASS选取元素<br><code>document.getElementsByClassName(&#39;myclass&#39;)[0];</code><br>3、通过标签选取元素<br><code>document.getElementsByTagName(&#39;mydiv&#39;)[0];</code><br>4、通过NAME属性选取元素（常用于表单）<br><code>document.getElementsByName(&#39;myname&#39;)[0];</code></p>
<h2 id="JS修改CSS样式"><a href="#JS修改CSS样式" class="headerlink" title="JS修改CSS样式"></a>JS修改CSS样式</h2><p><code>document.getElementById(&#39;myid&#39;).style.display = &#39;none&#39;;</code></p>
<h2 id="JS修改CLASS属性"><a href="#JS修改CLASS属性" class="headerlink" title="JS修改CLASS属性"></a>JS修改CLASS属性</h2><p><code>document.getElementById(&#39;myid&#39;).className = &#39;active&#39;;</code><br>如果有多个CLASS属性，即用空格隔开<br><code>document.getElementById(&#39;myid&#39;).className = &#39;active div-1&#39;;</code><br>移除该元素上的所有CLASS</p>
<h2 id="JS之类型转换"><a href="#JS之类型转换" class="headerlink" title="JS之类型转换"></a>JS之类型转换</h2><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><p>js提供了parseInt()和parseFloat()两个转换函数。前者把值转换成整数，后者把值转换成浮点数。只有对String类型调用这些方法，这两个函数才能正确运行；对其他类型返回的都是NaN(Not a Number)。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>还可使用强制类型转换（type casting）处理转换值的类型。使用强制类型转换可以访问特定的值，即使它是另一种类型的。</p>
<p>ECMAScript中可用的3种强制类型转换如下：</p>
<p>Boolean(value)——把给定的值转换成Boolean型；</p>
<p>Number(value)——把给定的值转换成数字（可以是整数或浮点数）；</p>
<p>String(value)——把给定的值转换成字符串。</p>
<p>用这三个函数之一转换值，将创建一个新值，存放由原始值直接转换成的值。这会造成意想不到的后果。</p>
<p>当要转换的值是至少有一个字符的字符串、非0数字或对象（下一节将讨论这一点）时，Boolean()函数将返回true。如果该值是空字符串、数字0、undefined或null，它将返回false。</p>
<h2 id="JS之数组常用的方法"><a href="#JS之数组常用的方法" class="headerlink" title="JS之数组常用的方法"></a>JS之数组常用的方法</h2><ol>
<li>push      添加到最后        返回添加后的数组</li>
<li>unshift   添加到最前面      返回添加后的数组</li>
<li>shift     删除（从前面）    返回处理后的数组</li>
<li>pop       删除最后一项      返回处理后的数组</li>
<li>reverse   数组翻转          返回处理后的数组</li>
<li>join      数组转化为字符串  </li>
<li>slice(start,end)     截取数组 从start（开始） 到end（结束 不包含）</li>
<li>concat   数组合并</li>
<li>splice（开始下标,个数,ele1,ele2….） 剪接数组</li>
<li>arr.forEach(item,index,array){}   遍历，循环 类似jquery的each</li>
<li>map方法        映射 用法和forEach类似</li>
<li>arr.sort  排序</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/wang729506596/article/details/83019131" target="_blank" rel="noopener">js中数组常用的方法总结，包括ES6</a></p>
<p><a href="https://blog.csdn.net/qq_39132756/article/details/85007082" target="_blank" rel="noopener">js数组常用方法</a></p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>编程思想：面向对象和面向过程</title>
    <url>/2019/10/22/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>　　何谓面向对象？何谓面向过程？对于这编程界的两大思想，一直贯穿在我们学习和工作当中。我们知道面向过程和面向对象，但要让我们讲出来个所以然，又感觉是不知从何说起，最后可能也只会说出一句就是那样啦，你知道啦。而这种茫然，其实就是对这两大编程思想的迷糊之处。本文通过学生到校报道注册的实例，阐述了面向过程和面向对象两大思想。希望能对你的学习和工作有所帮助。</p><a id="more"></a>
<h1 id="一、面向过程"><a href="#一、面向过程" class="headerlink" title="一、面向过程"></a>一、面向过程</h1><p>　　首先我们来认识下，什么是面向过程？如果咬文嚼字的话可以这样来理解，面向过程就是面向解决问题的过程进行编程。仔细思考一下，我们在学习和工作中，当我们去实现某项功能或完成某项任务时，是不是会不自觉的按部就班的罗列出我们要做的事情？（如果没有，建议以后试着步骤化解决问题）。而当我们按着我们罗列的步骤去解决问题时，实质上就是按照面向过程的思想去解决问题。我们罗列的步骤就是过程，按照步骤解决问题就是面向过程。</p>
<p>　　传统的面向过程的编程思想总结起来就八个字——<strong>自顶向下，逐步细化</strong>！实现步骤如下：</p>
<ol>
<li>将要实现的功能描述为一个从开始到结束按部就班的连续的步骤（过程）；</li>
<li>依次逐步完成这些步骤，如果某一步的难度较大，又可以将该步骤再次细化为若干个子步骤，以此类推，一直到结束得到想要的结果；</li>
<li>程序的主体是函数，一个函数就是一个封装起来的模块，可以实现一定的功能，各个子步骤往往就是通过各个函数来完成的，从而实现代码的重用和模块化编程！</li>
</ol>
<p>案例：学生到校报道注册</p>
<p>面向过程流程图：</p>
<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g7zb7rqab3j30as0frq3o.jpg" alt="面向过程流程图.png"></p>
<p>面向过程，就是按照我们分析好了的步骤，按部就班的依次执行就行了！所以当我们用面向过程的思想去编程或解决问题时，首先一定要把详细的实现过程弄清楚。一旦过程设计清楚，代码的实现简直轻而易举。</p>
<h1 id="二、面向对象"><a href="#二、面向对象" class="headerlink" title="二、面向对象"></a>二、面向对象</h1><p>　　讨论完了面向过程，我们再来认识下面向对象。所谓的面向对象，就是在编程的时候尽可能的去模拟真实的现实世界，按照现实世界中的逻辑去处理一个问题，分析问题中参与其中的有<strong>哪些实体</strong>，这些实体应该<strong>有什么属性和方法</strong>，我们<strong>如何通过调用这些实体的属性和方法</strong>去解决问题。</p>
<p>现实世界中，任何一个操作或者是业务逻辑的实现都需要一个实体来完成，也就是说，<strong>实体就是动作的支配者</strong>，没有实体，就肯定没有动作发生！</p>
<p>　　现在让我们思考下，上述注册报名的每一个步骤都有哪些动词？</p>
<p>　　提出 提供 缴 收 获得 分配 增加</p>
<p>　　有动词就一定有实现这个动作的实体！</p>
<p>　　所谓的模拟现实世界，就是使计算机的编程语言在解决相关业务逻辑的方式，与真实的业务逻辑的发生保持一致！需要使每一个动作的背后都一个完成这个动作的实体！</p>
<p>　　因为任何功能的实现都是依赖于一个具体的<strong>实体的“动作|操作|行动”，</strong>可以看作是一个又一个的实体在发挥其各自的“能力”并在内部进行协调有序的调用过程！</p>
<p>　　当采用面向对象的思想解决问题时，可分为下面几步：</p>
<pre><code>1. 分析哪些动作是由哪些实体发出的；
2. 定义这些实体，为其增加相应的属性和功能；
3. 让实体去执行相应的功能或动作。
</code></pre><p>　　采用面向对象的思想，解决上面的报名问题，应该如下：</p>
<p><strong>第一步：分析那些动作是由哪些实体发出的</strong></p>
<ul>
<li>学生提出报名</li>
<li>学生缴费</li>
<li>机构收费</li>
<li>教师分配教室</li>
<li>班级增加学生信息</li>
</ul>
<p>　　于是，在整个过程中，一共有四个实体：</p>
<p>　　学生、机构、教师、班级！</p>
<p>　　在现实中的一个具体的实体，就是计算机编程中的一个对象！</p>
<p><strong>第二步：定义这些实体，为其增加相应的属性和功能</strong></p>
<p>　　属性就是实体在现实世界中的一些特征表现。如：</p>
<ul>
<li><ul>
<li>人的属性：姓名、性别、身高、三围、体重、电话号码、家庭住址、籍贯等</li>
<li>手机的属性：品牌、价格、颜色、尺寸、待机时间等</li>
</ul>
</li>
</ul>
<p>　　功能就是能完成的动作，在面向对象的术语中，动作就叫作方法或者函数。如：</p>
<ul>
<li><ul>
<li>人的动作（功能）：吃饭、睡觉、学习、打游戏、走路、跑步、缴费！</li>
<li>手机的动作（功能）：打电话、发短信、拍照、打游戏、视频、看电影等</li>
</ul>
</li>
</ul>
<p>　　下图显示了在上述实例中出现的实体以及相应的属性和功能：</p>
<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g7zb8bxxfvj30gn0ef3zn.jpg" alt="面向对象实体的属性和方法.jpg"></p>
<p><strong>第三步：让实体去执行相应的功能或动作</strong></p>
<ul>
<li>学生提出报名</li>
<li>学生缴费</li>
<li>学校收费</li>
<li>教师分配教室</li>
<li>班级增加学生信息</li>
</ul>
<p>　　所以说，面向过程主要是针对功能，而面向对象主要是针对能够实现该功能的背后的实体。面向对象实质上就是面向实体，所以当我们使用面向对象进行编程时，一定要建立这样一个观念：万物皆对象！</p>
<h1 id="三、面向对象和面向过程的比较"><a href="#三、面向对象和面向过程的比较" class="headerlink" title="三、面向对象和面向过程的比较"></a>三、面向对象和面向过程的比较</h1><p>　　在我们将面向过程和面向对象讨论完后，会明显的感觉两者之间有着很大的区别。面向过程简单直接，易于入门理解，模块化程度较低。而面向对象相对于面向过程较为复杂，不易理解，模块化程度较高。可总结为下面三点：</p>
<ol>
<li>都可以实现代码重用和模块化编程，但是面对对象的模块化更深，数据更封闭，也更安全！因为面向对象的封装性更强！</li>
<li>面对对象的思维方式更加贴近于现实生活，更容易解决大型的复杂的业务逻辑</li>
<li>从前期开发角度上来看，面对对象远比面向过程要复杂，但是从维护和扩展功能的角度上来看，面对对象远比面向过程要简单！</li>
</ol>
<p>　　如何选择面向对象还是面向过程，对于一个有着丰富开发经验的老手来说，这是个得心应手的过程。而对于一个新手而言，其实从两者的对比就可以看出，当我们的业务逻辑比较简单时，使用面向过程能更快的实现。但是当我们的业务逻辑比较复杂时，为了将来的维护和扩展，还是面向对象更为靠谱点！当然，当我们被经理催着上交项目时，不要再选择纠结了，哪个能让你更快的完成项目就用哪个吧！</p>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
  </entry>
  <entry>
    <title>Vue 自定义组件</title>
    <url>/2019/10/22/Vue/Vue-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。</p><h1 id="创建单文件组件"><a href="#创建单文件组件" class="headerlink" title="创建单文件组件"></a>创建单文件组件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;stylus&quot; rel=&quot;stylesheet/stylus&quot;&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>

<h1 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h1><p>注册分为两种：局部注册和全局注册。</p>
<h2 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h2><p>注册一个全局组件，可以使用Vue.component(tagName, options)。 把构造函数注册到my-component这个 id Vue.component(‘my-component’, MyComponent)，为了写法更简单，也可以直接传入 option 对象来代替构造函数，Vue.component() 会为你隐式调用 Vue.extend() 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 注册全局组件,指定之前设定的元素名,然后传入对象</span><br><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line"> template: &apos;&lt;div&gt;hello world!&lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>之后就能在父级实例的模板中使用注册过的组件了 (<strong>务必在初始化根实例之前注册组件</strong>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;my-component&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>
<h2 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h2><p>我们没有必要，也不应该全局注册所有组件。你可以限制一个组件仅对另一个组件及其后代可用，只要在另一个组件的 components 选项中传入这个组件即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> import header from &apos;./components/header/header.vue&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    &apos;v-header&apos;: header</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="组件构成"><a href="#组件构成" class="headerlink" title="组件构成"></a>组件构成</h1><h2 id="data对象"><a href="#data对象" class="headerlink" title="data对象"></a>data对象</h2><p><strong>data 必须是函数</strong>。因为如果不是函数的，声明多个组件的时候，他们共享的就是同一个data，这样就会乱掉。如果通过函数返回，那么每个组件维持自己的data作用域。该data属性只在其component中可见。</p>
<h2 id="通过-prop-传递数据"><a href="#通过-prop-传递数据" class="headerlink" title="通过 prop 传递数据"></a>通过 prop 传递数据</h2><p>组件实例的作用域是孤立的,组件和组件之间，即使有同名属性，值也不共享。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 props 把数据传给子组件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;child&apos;, &#123;</span><br><span class="line">  // 声明 props</span><br><span class="line">  props: [&apos;message&apos;],</span><br><span class="line">  // 就像 data 一样，prop 可以用在模板内</span><br><span class="line">  // 同样也可以在 vm 实例中像 “this.message” 这样使用</span><br><span class="line">  template: &apos;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是HTML 特性是不区分大小写的。所以，当使用的不是字符串模版，camelCased (驼峰式) 命名的 prop 需要转换为相对应的 kebab-case (短横线隔开式) 命名，这点在angularjs的指令中也一样。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;child&apos;, &#123;</span><br><span class="line">  // camelCase in JavaScript</span><br><span class="line">  props: [&apos;myMessage&apos;],</span><br><span class="line">  template: &apos;&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在vue2.0中prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop 。如果你这么做了，Vue 会在控制台给出警告。这点官方文档给出了明确的说明和解决办法。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/f6178cdde341" target="_blank" rel="noopener">VUE2.0 自定义组件初体验</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue之props验证</title>
    <url>/2019/10/22/Vue/Vue%E4%B9%8Bprops%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<h1 id="为什么要有props验证"><a href="#为什么要有props验证" class="headerlink" title="为什么要有props验证"></a>为什么要有props验证</h1><p>但是上面这种方式是建立在大家都很遵守约定的情况下的，想象一下当有一个人要使用foo-component组件的时候，他可能对于其要接受的参数有什么要求并不是很清楚，因此传入的参数可能会在开发子组件的人的意料之外，程序就会发生错误，就像我们在函数调用之前先检查一下函数一样，props也可以进行一个预先检查。</p><a id="more"></a>
<p>平时调用函数的时候在函数开头的地方都是一坨糊糊的参数检查，这种写法很不好了，所有后来就有了校验器模式（别去百度了，我随口取的名字），校验器模式就是指把在函数开头的对参数校验的部分提取出来作为一个公共的部分来管理，让一个什么东西来专门负责校验，当类型不正确的时候就抛个异常根本不去调用这个函数，很多框架设计时都是这么设计的（Spring MVC、Struts2等等），props也提供了这个功能，想一下如果没有这个功能的话，为了保证正确性我们可能需要在每次使用props属性之前都写一坨代码来检查。校验器最大的好处就是大多数情况下我们只需要声明我需要什么样的数据，让校验器检查好了再塞给我。</p>
<h1 id="使用props"><a href="#使用props" class="headerlink" title="使用props"></a>使用props</h1><p>在Vue中父组件向子组件中传送数据是通过props实现的，一个简单的使用props的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;title&gt;Vue Study&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;foo-component :foo-message=&quot;fooMessage&quot;&gt;&lt;/foo-component&gt;  </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;lib/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    var fooComponent = &#123;</span><br><span class="line">        props: [&apos;fooMessage&apos;],</span><br><span class="line">        template: &apos;&lt;div&gt; &#123;&#123; fooMessage &#125;&#125; &lt;/div&gt;&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">     </span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        components: &#123;</span><br><span class="line">            &apos;foo-component&apos;: fooComponent</span><br><span class="line">        &#125;,</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            fooMessage: 123</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h1 id="type参数数据类型"><a href="#type参数数据类型" class="headerlink" title="type参数数据类型"></a>type参数数据类型</h1><p>可以使用type来声明这个参数可以接受的数据的类型，当检查规则只有一个的时候type可以略写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;title&gt;Vue Study&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;foo-component :foo-message=&quot;fooMessage&quot;&gt;&lt;/foo-component&gt;  </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;lib/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    var fooComponent = &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">            fooMessage: Number</span><br><span class="line">        &#125;,</span><br><span class="line">        template: &apos;&lt;div&gt; &#123;&#123; fooMessage &#125;&#125; &lt;/div&gt;&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">     </span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        components: &#123;</span><br><span class="line">            &apos;foo-component&apos;: fooComponent</span><br><span class="line">        &#125;,</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            fooMessage: 123</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>当传入的参数类型不正确的时候Vue会发出提示</p>
<h2 id="type接受多个类型"><a href="#type接受多个类型" class="headerlink" title="type接受多个类型"></a>type接受多个类型</h2><p>当参数可以是多种类型的其中一个的时候，使用数组来表示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;title&gt;Vue Study&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;foo-component :foo-message=&quot;fooMessage&quot;&gt;&lt;/foo-component&gt;  </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;lib/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    var fooComponent = &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">            fooMessage: [Number, String]</span><br><span class="line">        &#125;,</span><br><span class="line">        template: &apos;&lt;div&gt; &#123;&#123; fooMessage &#125;&#125; &lt;/div&gt;&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">     </span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        components: &#123;</span><br><span class="line">            &apos;foo-component&apos;: fooComponent</span><br><span class="line">        &#125;,</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            fooMessage: 123</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="validator"><a href="#validator" class="headerlink" title="validator"></a>validator</h2><p>当校验规则很复杂，默认提供的校验规则无法满足的时候可以使用自定义函数来校验。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;title&gt;Vue Study&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;foo-component :foo-message=&quot;fooMessage&quot;&gt;&lt;/foo-component&gt;  </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;lib/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    var fooComponent = &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">            fooMessage: &#123;</span><br><span class="line">                validator: function(value)&#123;</span><br><span class="line">                    return value&gt;=0 &amp;&amp; value&lt;=128;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        template: &apos;&lt;div&gt; &#123;&#123; fooMessage &#125;&#125; &lt;/div&gt;&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">     </span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        components: &#123;</span><br><span class="line">            &apos;foo-component&apos;: fooComponent</span><br><span class="line">        &#125;,</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            fooMessage: 100</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="type能够指定的类型"><a href="#type能够指定的类型" class="headerlink" title="type能够指定的类型"></a>type能够指定的类型</h2><p>type可以是以下原生类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;my-component&apos;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span><br><span class="line">    propA: Number,</span><br><span class="line">    // 多个可能的类型</span><br><span class="line">    propB: [String, Number],</span><br><span class="line">    // 必填的字符串,可以使用required选项来声明这个参数是否必须传入。</span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;,</span><br><span class="line">    // 带有默认值的数字</span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 100</span><br><span class="line">    &#125;,</span><br><span class="line">    // 带有默认值的对象</span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      // 对象或数组默认值必须从一个工厂函数获取</span><br><span class="line">      default: function () &#123;</span><br><span class="line">        return &#123; message: &apos;hello&apos; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 自定义验证函数</span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: function (value) &#123;</span><br><span class="line">        // 这个值必须匹配下列字符串中的一个</span><br><span class="line">        return [&apos;success&apos;, &apos;warning&apos;, &apos;danger&apos;].indexOf(value) !== -1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="required"><a href="#required" class="headerlink" title="required"></a>required</h1><p>可以使用required选项来声明这个参数是否必须传入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;title&gt;Vue Study&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;foo-component :foo-message=&quot;fooMessage&quot;&gt;&lt;/foo-component&gt;  </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;lib/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    var fooComponent = &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">            fooMessage: &#123;</span><br><span class="line">                type: Number,</span><br><span class="line">                required: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        template: &apos;&lt;div&gt; &#123;&#123; fooMessage &#125;&#125; &lt;/div&gt;&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">     </span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        components: &#123;</span><br><span class="line">            &apos;foo-component&apos;: fooComponent</span><br><span class="line">        &#125;,</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            fooMessage: 256</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h1 id="default"><a href="#default" class="headerlink" title="default"></a>default</h1><p>使用default选项来指定当父组件未传入参数时props变量的默认值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;title&gt;Vue Study&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;foo-component&gt;&lt;/foo-component&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;lib/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    var fooComponent = &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">            fooMessage: &#123;</span><br><span class="line">                type: Number,</span><br><span class="line">                default: 128</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        template: &apos;&lt;div&gt; &#123;&#123; fooMessage &#125;&#125; &lt;/div&gt;&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">     </span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        components: &#123;</span><br><span class="line">            &apos;foo-component&apos;: fooComponent</span><br><span class="line">        &#125;,</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            fooMessage: 256</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>当父组件未传入参数时子组件的值是128，当父组件传入参数时是其指定的参数，比如这里可以是256。</p>
<p>当type的类型为Array或者Object的时候default必须是一个函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;title&gt;Vue Study&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;foo-component&gt;&lt;/foo-component&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;lib/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    var fooComponent = &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">            fooMessage: &#123;</span><br><span class="line">                type: Array,</span><br><span class="line">                default: function()&#123;</span><br><span class="line">                    return [&apos;foo&apos;, &apos;bar&apos;];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        template: &apos;&lt;div&gt; &#123;&#123; fooMessage &#125;&#125; &lt;/div&gt;&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">     </span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        components: &#123;</span><br><span class="line">            &apos;foo-component&apos;: fooComponent</span><br><span class="line">        &#125;,</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            fooMessage: [&apos;f&apos;, &apos;o&apos;, &apos;o&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h1 id="一个综合的例子"><a href="#一个综合的例子" class="headerlink" title="一个综合的例子"></a>一个综合的例子</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line"></span><br><span class="line">    // fooA只接受数值类型的参数</span><br><span class="line"></span><br><span class="line">    fooA: Number,</span><br><span class="line"></span><br><span class="line">    // fooB可以接受字符串和数值类型的参数</span><br><span class="line"></span><br><span class="line">    fooB: [String, Number],</span><br><span class="line"></span><br><span class="line">    // fooC可以接受字符串类型的参数，并且这个参数必须传入</span><br><span class="line"></span><br><span class="line">    fooC: &#123;</span><br><span class="line"></span><br><span class="line">        type: String,</span><br><span class="line"></span><br><span class="line">        required: true</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // fooD接受数值类型的参数，如果不传入的话默认就是100</span><br><span class="line"></span><br><span class="line">    fooD: &#123;</span><br><span class="line"></span><br><span class="line">        type: Number,</span><br><span class="line"></span><br><span class="line">        default: 100</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // fooE接受对象类型的参数</span><br><span class="line"></span><br><span class="line">    fooE: &#123;</span><br><span class="line"></span><br><span class="line">        type: Object,</span><br><span class="line"></span><br><span class="line">        // 当为对象类型设置默认值时必须使用函数返回</span><br><span class="line"></span><br><span class="line">        default: function()&#123;</span><br><span class="line"></span><br><span class="line">            return &#123; message: &apos;Hello, world&apos; &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // fooF使用一个自定义的验证器</span><br><span class="line"></span><br><span class="line">    fooF: &#123;</span><br><span class="line"></span><br><span class="line">        validator: function(value)&#123;</span><br><span class="line"></span><br><span class="line">            return value&gt;=0 &amp;&amp; value&lt;=100;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener">Vue官方文档</a></p>
<p><a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener">Vue笔记之prop</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>router路由跳转使用query传递参数刷新后数据无法获取</title>
    <url>/2019/10/22/Vue/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/router%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E4%BD%BF%E7%94%A8query%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E5%88%B7%E6%96%B0%E5%90%8E%E6%95%B0%E6%8D%AE%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96/</url>
    <content><![CDATA[<blockquote>
<p>问题描述: 路由进行页面的跳转时,使用query进参数传递,query中存储一个较为复杂的对象,页面初次载入时数据可以成功获取,刷新页面后数据显示<code>{accountInfo: &quot;[object Object]&quot;}</code></p>
</blockquote><p>#代码示例</p><p>路由跳转代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (data.code === 200) &#123;</span><br><span class="line">    this.$router.push(&#123;</span><br><span class="line">        name: &apos;admin/&apos;,</span><br><span class="line">        query:&#123;</span><br><span class="line">            accountInfo:data.data,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a>


<p>获取参数,初次载入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(this.$route.query);//&#123;accountInfo: &#123;…&#125;&#125; 正常显示</span><br></pre></td></tr></table></figure></p>
<p>刷新页面<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(this.$route.query);//`&#123;accountInfo: &quot;[object Object]&quot;&#125;`获取不到内部数据</span><br></pre></td></tr></table></figure></p>
<p>#问题出现原因:<br>不清楚,router 里也设置了。传递的参数 如果是普通格式没问题，如果是对象，刷新后不管是params 还是 query 都会消失，</p>
<h1 id="问题解决方案"><a href="#问题解决方案" class="headerlink" title="问题解决方案:"></a>问题解决方案:</h1><h2 id="1-使用JSON转译"><a href="#1-使用JSON转译" class="headerlink" title="1. 使用JSON转译"></a>1. 使用JSON转译</h2><p>###JSON.stringify（） 把对象变成字符串，然后再传递，没有问题。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let accountInfoJson = data.data;</span><br><span class="line">accountInfoJson = JSON.stringify(accountInfoJson);</span><br><span class="line">if (data.code === 200) &#123;</span><br><span class="line">    this.$router.push(&#123;</span><br><span class="line">        name: &apos;admin/&apos;,</span><br><span class="line">        query:&#123;</span><br><span class="line">            accountInfo:accountInfoJson,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###获取参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> let accountInfo = JSON.parse(this.$route.query.accountInfo);</span><br><span class="line">console.log(accountInfo);//可以成功获取参数</span><br></pre></td></tr></table></figure>
<p>缺点:<br>再次进行路由跳转时,需要再次传递该参数,否则会无法获取</p>
<h2 id="2-使用HTML5的web存储"><a href="#2-使用HTML5的web存储" class="headerlink" title="2.使用HTML5的web存储"></a>2.使用HTML5的web存储</h2><p>HTML5 提供了两种在客户端存储数据的新方法：</p>
<ul>
<li>localStorage - 没有时间限制的数据存储</li>
<li>sessionStorage - 针对一个 session 的数据存储</li>
</ul>
<h3 id="数据储存"><a href="#数据储存" class="headerlink" title="数据储存"></a>数据储存</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reqwest(&#123;</span><br><span class="line">    url: &apos;/a/login&apos;,</span><br><span class="line">    method: &apos;post&apos;,</span><br><span class="line">    data: dataJson,</span><br><span class="line">    type: &apos;json&apos;,</span><br><span class="line">    contentType: &apos;application/json&apos;,</span><br><span class="line">&#125;).then((data) =&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    let accountInfoJson = data.data;</span><br><span class="line">    accountInfoJson = JSON.stringify(accountInfoJson);</span><br><span class="line">    sessionStorage .setItem(&quot;accountInfo&quot;,accountInfoJson);</span><br><span class="line">    if (data.code === 200) &#123;</span><br><span class="line">        this.$router.push(&#123;</span><br><span class="line">            name: &apos;admin/&apos;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="取出数据"><a href="#取出数据" class="headerlink" title="取出数据"></a>取出数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let accountInfoJson = sessionStorage.getItem(&quot;accountInfo&quot;);</span><br><span class="line">let accountInfo =  JSON.parse(accountInfoJson);</span><br><span class="line">console.log(accountInfo);//注意JSON转译</span><br></pre></td></tr></table></figure>
<p><strong>缺点</strong>:<br>如果存储用户的身份信息,注意退出登录时清除数据</p>
<h2 id="3-在vue中设置全局变量"><a href="#3-在vue中设置全局变量" class="headerlink" title="3. 在vue中设置全局变量"></a>3. 在vue中设置全局变量</h2><p>global.vue 以一个特定模块来组织管理这些全局量，需要引用的地方导入该模块.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    let accountInfo = &#123;&#125;;</span><br><span class="line">    export default</span><br><span class="line">    &#123;</span><br><span class="line">        accountInfo</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="存储变量"><a href="#存储变量" class="headerlink" title="存储变量"></a><strong>存储变量</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import global from &apos;./global&apos;;//引入全局变量</span><br><span class="line">reqwest(&#123;</span><br><span class="line">    url: &apos;/a/login&apos;,</span><br><span class="line">    method: &apos;post&apos;,</span><br><span class="line">    data: dataJson,</span><br><span class="line">    type: &apos;json&apos;,</span><br><span class="line">    contentType: &apos;application/json&apos;,</span><br><span class="line">&#125;).then((data) =&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    global.accountInfo =  data.data; //把数据存储在全局变量</span><br><span class="line">    if (data.code === 200) &#123;</span><br><span class="line">        this.$router.push(&#123;</span><br><span class="line">            name: &apos;admin/&apos;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="取出变量"><a href="#取出变量" class="headerlink" title="取出变量"></a>取出变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import global from &apos;./global&apos;;//引入全局变量</span><br><span class="line"></span><br><span class="line">console.log(global.accountInfo);</span><br></pre></td></tr></table></figure>
<p><strong>缺点</strong>:<br>页面刷新,该参数会无法获取</p>
<blockquote>
<p>问题描述: 路由进行页面的跳转时,使用query进参数传递,query中存储一个较为复杂的对象,页面初次载入时数据可以成功获取,刷新页面后数据显示<code>{accountInfo: &quot;[object Object]&quot;}</code></p>
</blockquote>
<p>#代码示例</p>
<p>路由跳转代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (data.code === 200) &#123;</span><br><span class="line">    this.$router.push(&#123;</span><br><span class="line">        name: &apos;admin/&apos;,</span><br><span class="line">        query:&#123;</span><br><span class="line">            accountInfo:data.data,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取参数,初次载入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(this.$route.query);//&#123;accountInfo: &#123;…&#125;&#125; 正常显示</span><br></pre></td></tr></table></figure></p>
<p>刷新页面<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(this.$route.query);//`&#123;accountInfo: &quot;[object Object]&quot;&#125;`获取不到内部数据</span><br></pre></td></tr></table></figure></p>
<p>#问题出现原因:<br>不清楚,router 里也设置了。传递的参数 如果是普通格式没问题，如果是对象，刷新后不管是params 还是 query 都会消失，</p>
<h1 id="问题解决方案-1"><a href="#问题解决方案-1" class="headerlink" title="问题解决方案:"></a>问题解决方案:</h1><h2 id="1-使用JSON转译-1"><a href="#1-使用JSON转译-1" class="headerlink" title="1. 使用JSON转译"></a>1. 使用JSON转译</h2><p>###JSON.stringify（） 把对象变成字符串，然后再传递，没有问题。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let accountInfoJson = data.data;</span><br><span class="line">accountInfoJson = JSON.stringify(accountInfoJson);</span><br><span class="line">if (data.code === 200) &#123;</span><br><span class="line">    this.$router.push(&#123;</span><br><span class="line">        name: &apos;admin/&apos;,</span><br><span class="line">        query:&#123;</span><br><span class="line">            accountInfo:accountInfoJson,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###获取参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> let accountInfo = JSON.parse(this.$route.query.accountInfo);</span><br><span class="line">console.log(accountInfo);//可以成功获取参数</span><br></pre></td></tr></table></figure>
<p>缺点:<br>再次进行路由跳转时,需要再次传递该参数,否则会无法获取</p>
<h2 id="2-使用HTML5的web存储-1"><a href="#2-使用HTML5的web存储-1" class="headerlink" title="2.使用HTML5的web存储"></a>2.使用HTML5的web存储</h2><p>HTML5 提供了两种在客户端存储数据的新方法：</p>
<ul>
<li>localStorage - 没有时间限制的数据存储</li>
<li>sessionStorage - 针对一个 session 的数据存储</li>
</ul>
<h3 id="数据储存-1"><a href="#数据储存-1" class="headerlink" title="数据储存"></a>数据储存</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reqwest(&#123;</span><br><span class="line">    url: &apos;/a/login&apos;,</span><br><span class="line">    method: &apos;post&apos;,</span><br><span class="line">    data: dataJson,</span><br><span class="line">    type: &apos;json&apos;,</span><br><span class="line">    contentType: &apos;application/json&apos;,</span><br><span class="line">&#125;).then((data) =&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    let accountInfoJson = data.data;</span><br><span class="line">    accountInfoJson = JSON.stringify(accountInfoJson);</span><br><span class="line">    sessionStorage .setItem(&quot;accountInfo&quot;,accountInfoJson);</span><br><span class="line">    if (data.code === 200) &#123;</span><br><span class="line">        this.$router.push(&#123;</span><br><span class="line">            name: &apos;admin/&apos;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="取出数据-1"><a href="#取出数据-1" class="headerlink" title="取出数据"></a>取出数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let accountInfoJson = sessionStorage.getItem(&quot;accountInfo&quot;);</span><br><span class="line">let accountInfo =  JSON.parse(accountInfoJson);</span><br><span class="line">console.log(accountInfo);//注意JSON转译</span><br></pre></td></tr></table></figure>
<p><strong>缺点</strong>:<br>如果存储用户的身份信息,注意退出登录时清除数据</p>
<h2 id="3-在vue中设置全局变量-1"><a href="#3-在vue中设置全局变量-1" class="headerlink" title="3. 在vue中设置全局变量"></a>3. 在vue中设置全局变量</h2><p>global.vue 以一个特定模块来组织管理这些全局量，需要引用的地方导入该模块.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    let accountInfo = &#123;&#125;;</span><br><span class="line">    export default</span><br><span class="line">    &#123;</span><br><span class="line">        accountInfo</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="存储变量-1"><a href="#存储变量-1" class="headerlink" title="存储变量"></a><strong>存储变量</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import global from &apos;./global&apos;;//引入全局变量</span><br><span class="line">reqwest(&#123;</span><br><span class="line">    url: &apos;/a/login&apos;,</span><br><span class="line">    method: &apos;post&apos;,</span><br><span class="line">    data: dataJson,</span><br><span class="line">    type: &apos;json&apos;,</span><br><span class="line">    contentType: &apos;application/json&apos;,</span><br><span class="line">&#125;).then((data) =&gt; &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    global.accountInfo =  data.data; //把数据存储在全局变量</span><br><span class="line">    if (data.code === 200) &#123;</span><br><span class="line">        this.$router.push(&#123;</span><br><span class="line">            name: &apos;admin/&apos;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="取出变量-1"><a href="#取出变量-1" class="headerlink" title="取出变量"></a>取出变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import global from &apos;./global&apos;;//引入全局变量</span><br><span class="line"></span><br><span class="line">console.log(global.accountInfo);</span><br></pre></td></tr></table></figure>
<p><strong>缺点</strong>:<br>页面刷新,该参数会无法获取</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>遇到的问题</category>
      </categories>
  </entry>
  <entry>
    <title>使用vue的表单组件,编辑页面设置默认值失败</title>
    <url>/2019/10/22/Vue/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/%E4%BD%BF%E7%94%A8vue%E7%9A%84%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6-%E7%BC%96%E8%BE%91%E9%A1%B5%E9%9D%A2%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%80%BC%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h1><p>使用vue的表单组件,编辑页面设置默认值失败,其他表单项目均设置成功,只有图片地址的input值无法成功渲染</p><h1 id="问题解决流程"><a href="#问题解决流程" class="headerlink" title="问题解决流程:"></a>问题解决流程:</h1><p>仔细对比该表单项目与其他表单项目,以及结合之前angular的经验,猜测可能是v-if影响了数据的绑定,去除v-if后数据成功渲染</p><h1 id="问题出现原因"><a href="#问题出现原因" class="headerlink" title="问题出现原因:"></a>问题出现原因:</h1><p>该表单项目使用了v-if(条件默认为false),因为生命周期的原因,数据第一次无法<br>渲染<br>step1. v-if条件为假,表单元素在html中没有生成<br>step2. 数据绑定,找不到该表单元素的dom,数据渲染失败<br>step3. v-if条件修改为真,表单元素在html中生成</p><a id="more"></a>


<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h1><p>使用v-show</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>遇到的问题</category>
      </categories>
  </entry>
  <entry>
    <title>vue-cli脚手架3.0版本搭建项目，运行时报错</title>
    <url>/2019/10/22/Vue/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/vue-cli%E8%84%9A%E6%89%8B%E6%9E%B63-0%E7%89%88%E6%9C%AC%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>vue-cli脚手架3.0版本搭建项目，运行时报错</p><h1 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Vue warn] : You are using the runtime-only build of Vue where the template option is not available. Either pre-compile the templates into render functions, or use the compiler-included build. (found in root instance)</span><br></pre></td></tr></table></figure><a id="more"></a>

<h1 id="问题出现原因"><a href="#问题出现原因" class="headerlink" title="问题出现原因"></a>问题出现原因</h1><p>template 选项不能用，但 vue-router 的例子中都在用，甚至将代码全部替换成例子中的代码依旧无法运行，但在 vue-router 项目里就可以运行。<br>分别打断点运行，发现两者竟然跑的不是同一段代码！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;;</span><br></pre></td></tr></table></figure></p>
<p>同样的 import 语句，却有不一样的结果，<br>vue-router 中引的是 vue.js，<br>而在我的项目中引的竟然是 vue.common.js…common…mon…n…</p>
<p>为什么会引 vue.common.js，from ‘vue’ 不该引的是 vue.js 么？这就要引入另一个知识点：package.json。<br>package.json 中的 main 属性决定了，当项目被引入时，输出的是哪个文件，而 vue 的 package.json 中的 main 指向的是 dist/vue.common.js。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>import Vue from ‘vue/dist/vue’;</p>
<p>参考文献：<a href="https://segmentfault.com/a/1190000006435886" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006435886</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>遇到的问题</category>
      </categories>
  </entry>
  <entry>
    <title>js命名规范</title>
    <url>/2019/10/22/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/js%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>从事前端开发也有一段时间了，一直在遵循着规范化开发，从 js 也逐渐转向了 ts ，在这个过程中也有了很多收获，在此把自己的开发心得写下来。</p><p>本文参考了<a href="http://www.cnblogs.com/polk6/p/4660195.html#Menu3-FrameDev" target="_blank" rel="noopener">JavaScript 开发规范</a>，并做了补充和修改，同时删去了框架开发相关的内容(侵删)。</p><h2 id="1-命名规范"><a href="#1-命名规范" class="headerlink" title="1. 命名规范"></a>1. 命名规范</h2><p>ECMAScript 规范中标识符采用驼峰大小写格式，驼峰命名法由小(大)写字母开始，后续每个单词首字母都大写。根据首字母是否大写，分为两种方式：</p><a id="more"></a>


<ol>
<li>Pascal Case 大驼峰式命名法：首字母大写。eg：StudentInfo、UserInfo、ProductInfo</li>
<li>Camel Case 小驼峰式命名法：首字母小写。eg：studentInfo、userInfo、productInfo</li>
</ol>
<p>标识符，则包括变量、函数名、类名、属性名和函数或类的参数，每个命名方法又略有不同，下面详细解释一下：</p>
<h3 id="1-1-变量"><a href="#1-1-变量" class="headerlink" title="1.1 变量"></a>1.1 变量</h3><p><strong>命名方法</strong>：小驼峰式命名法。</p>
<p><strong>命名规范</strong>：前缀应当是名词。(函数的名字前缀为动词，以此区分变量和函数)</p>
<p><strong>命名建议</strong>：尽量在变量名字中体现所属类型，如:length、count等表示数字类型；而包含name、title表示为字符串类型。</p>
<p><strong>eg</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 好的命名方式</span><br><span class="line">let maxCount = 10;</span><br><span class="line">let tableTitle = &apos;LoginTable&apos;;</span><br><span class="line">// 不好的命名方式</span><br><span class="line">let setCount = 10;</span><br><span class="line">let getTitle = &apos;LoginTable&apos;;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-常量"><a href="#1-2-常量" class="headerlink" title="1.2 常量"></a>1.2 常量</h3><p><strong>命名方法</strong>：名称全部大写。</p>
<p><strong>命名规范</strong>：使用大写字母和下划线来组合命名，下划线用以分割单词。</p>
<p><strong>eg</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const MAX_COUNT = 10;</span><br><span class="line">const URL = &apos;http://www.foreverz.com&apos;;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-函数"><a href="#1-3-函数" class="headerlink" title="1.3 函数"></a>1.3 函数</h3><p><strong>命名方法</strong>：小驼峰式命名法。</p>
<p><strong>命名规范</strong>：前缀应当为动词。</p>
<p><strong>命名建议</strong>：可使用常见动词约定</p>
<table>
<thead>
<tr>
<th>动词</th>
<th>含义</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>can</td>
<td>判断是否可执行某个动作(权限)</td>
<td>函数返回一个布尔值。true：可执行；false：不可执行</td>
</tr>
<tr>
<td>has</td>
<td>判断是否含有某个值</td>
<td>函数返回一个布尔值。true：含有此值；false：不含有此值</td>
</tr>
<tr>
<td>is</td>
<td>判断是否为某个值</td>
<td>函数返回一个布尔值。true：为某个值；false：不为某个值</td>
</tr>
<tr>
<td>get</td>
<td>获取某个值</td>
<td>函数返回一个非布尔值</td>
</tr>
<tr>
<td>set</td>
<td>设置某个值</td>
<td>无返回值、返回是否设置成功或者返回链式对象</td>
</tr>
<tr>
<td>load</td>
<td>加载某些数据</td>
<td>无返回值或者返回是否加载完成的结果</td>
</tr>
</tbody>
</table>
<p><strong>eg</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 是否可阅读</span><br><span class="line">function canRead(): boolean &#123;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line">// 获取名称</span><br><span class="line">function getName(): string &#123;</span><br><span class="line">  return this.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-类-amp-构造函数"><a href="#1-4-类-amp-构造函数" class="headerlink" title="1.4 类 &amp; 构造函数"></a>1.4 类 &amp; 构造函数</h3><p><strong>命名方法</strong>：大驼峰式命名法，首字母大写。</p>
<p><strong>命名规范</strong>：前缀为名称。</p>
<p><strong>eg</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  public name: string;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const person = new Person(&apos;mevyn&apos;);</span><br></pre></td></tr></table></figure>
<h3 id="1-5-类的成员"><a href="#1-5-类的成员" class="headerlink" title="1.5 类的成员"></a>1.5 类的成员</h3><p>类的成员包含：</p>
<ol>
<li>公共属性和方法：跟变量和函数的命名一样。</li>
<li>私有属性和方法：前缀为_(下划线)，后面跟公共属性和方法一样的命名方式。</li>
</ol>
<p><strong>eg</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  private _name: string;</span><br><span class="line">  constructor() &#123; &#125;</span><br><span class="line">  // 公共方法</span><br><span class="line">  getName() &#123;</span><br><span class="line">    return this._name;</span><br><span class="line">  &#125;</span><br><span class="line">  // 公共方法</span><br><span class="line">  setName(name) &#123;</span><br><span class="line">    this._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const person = new Person();</span><br><span class="line">person.setName(&apos;mervyn&apos;);</span><br><span class="line">person.getName(); // -&gt;mervyn</span><br></pre></td></tr></table></figure>
<h2 id="2-注释规范"><a href="#2-注释规范" class="headerlink" title="2. 注释规范"></a>2. 注释规范</h2><p>js 支持三种不同类型的注释：行内注释、单行注释和多行注释：</p>
<h3 id="2-1-行内注释"><a href="#2-1-行内注释" class="headerlink" title="2.1 行内注释"></a>2.1 行内注释</h3><p><strong>说明</strong>：行内注释以两个斜线开始，以行尾结束。</p>
<p><strong>语法</strong>：code // 这是行内注释</p>
<p><strong>使用方式</strong>：//(双斜线)与代码之间保留一个空格，并且//(双斜线)与注释文字之间保留一个空格。</p>
<p><strong>命名建议</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 用来显示一个解释的评论</span><br><span class="line">// -&gt; 用来显示表达式的结果，</span><br><span class="line">// &gt;用来显示 console 的输出结果，</span><br></pre></td></tr></table></figure>
<p><strong>eg</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test() &#123; // 测试函数</span><br><span class="line">  console.log(&apos;Hello World!&apos;); // &gt;Hello World!</span><br><span class="line">  return 3 + 2; // -&gt;5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-单行注释"><a href="#2-2-单行注释" class="headerlink" title="2.2 单行注释"></a>2.2 单行注释</h3><p><strong>说明</strong>：单行注释以两个斜线开始，以行尾结束。</p>
<p><strong>语法</strong>：// 这是单行注释</p>
<p><strong>使用方式</strong>：单独一行：//(双斜线)与注释文字之间保留一个空格。</p>
<p><strong>eg</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 调用了一个函数；1)单独在一行</span><br><span class="line">setTitle();</span><br></pre></td></tr></table></figure>
<h3 id="2-3-多行注释"><a href="#2-3-多行注释" class="headerlink" title="2.3 多行注释"></a>2.3 多行注释</h3><p><strong>说明</strong>：以 <code>/*</code> 开头， <code>*/</code> 结尾</p>
<p><strong>语法</strong>：<code>/* 注释说明 */</code></p>
<p><strong>使用方法</strong>：若开始<code>/*</code>和结束<code>*/</code>都在一行，推荐采用单行注释。若至少三行注释时，第一行为<code>/*</code>，最后行为<code>*/</code>，其他行以<code>*</code>开始，并且注释文字与<code>*</code>保留一个空格。</p>
<p><strong>eg</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* 代码执行到这里后会调用setTitle()函数</span><br><span class="line">* setTitle()：设置title的值</span><br><span class="line">*/</span><br><span class="line">setTitle();</span><br></pre></td></tr></table></figure>
<h3 id="2-4-函数-方法-注释"><a href="#2-4-函数-方法-注释" class="headerlink" title="2.4 函数(方法)注释"></a>2.4 函数(方法)注释</h3><p><strong>说明</strong>：函数(方法)注释也是多行注释的一种，但是包含了特殊的注释要求，参照<a href="http://www.css88.com/doc/jsdoc/" target="_blank" rel="noopener">JSDoc</a></p>
<p><strong>语法</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line">* 函数说明 </span><br><span class="line">* @关键字 </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p><strong>常用注释关键字</strong>：(只列出一部分，并不是全部)</p>
<table>
<thead>
<tr>
<th>注释名</th>
<th>语法</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>@param</td>
<td>@param 参数名 {参数类型} 描述信息</td>
<td>描述参数的信息</td>
<td>@param name {String} 传入名称</td>
</tr>
<tr>
<td>@return</td>
<td>@return {返回类型} 描述信息</td>
<td>描述返回值的信息</td>
<td>@return {Boolean} true:可执行;false:不可执行</td>
</tr>
<tr>
<td>@author</td>
<td>@author 作者信息 [附属信息：如邮箱、日期]</td>
<td>描述此函数作者的信息</td>
<td>@author 张三 2015/07/21</td>
</tr>
<tr>
<td>@version</td>
<td>@version XX.XX.XX</td>
<td>描述此函数的版本号</td>
<td>@version 1.0.3</td>
</tr>
<tr>
<td>@example</td>
<td>@example 示例代码</td>
<td>演示函数的使用</td>
<td>@example setTitle(‘测试’)</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 合并Grid的行</span><br><span class="line">* @param grid &#123;Ext.Grid.Panel&#125; 需要合并的Grid</span><br><span class="line">* @param cols &#123;Array&#125; 需要合并列的Index(序号)数组；从0开始计数，序号也包含。</span><br><span class="line">* @param isAllSome &#123;Boolean&#125; ：是否2个tr的cols必须完成一样才能进行合并。true：完成一样；false(默认)：不完全一样</span><br><span class="line">* @return void</span><br><span class="line">* @author polk6 2015/07/21 </span><br><span class="line">* @example</span><br><span class="line">* _________________ _________________</span><br><span class="line">* | 年龄 | 姓名 | | 年龄 | 姓名 |</span><br><span class="line">* ----------------- mergeCells(grid,[0]) -----------------</span><br><span class="line">* | 18 | 张三 | =&gt; | | 张三 |</span><br><span class="line">* ----------------- - 18 ---------</span><br><span class="line">* | 18 | 王五 | | | 王五 |</span><br><span class="line">* ----------------- -----------------</span><br><span class="line">*/</span><br><span class="line">function mergeCells(grid: Ext.Grid.Panel, cols: Number[], isAllSome: boolean = false) &#123;</span><br><span class="line">  // Do Something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只是详细讲解了 标识符命名规范 和 代码注释规范，还有很多其它的规范没来得及填充，可以参考一下<a href="https://github.com/sivan/javascript-style-guide/blob/master/es5/README.md" target="_blank" rel="noopener">Airbnb JavaScript Style Guide</a></p>
<p>参考书籍和文章：</p>
<p><a href="https://book.douban.com/subject/10546125/" target="_blank" rel="noopener">JavaScript高级程序设计（第3版）</a></p>
<p><a href="http://www.cnblogs.com/polk6/p/4660195.html#Menu3-FrameDev" target="_blank" rel="noopener">JavaScript 开发规范</a></p>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
  </entry>
  <entry>
    <title>Vue路由跳转时传参</title>
    <url>/2019/10/22/Vue/Vue%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E6%97%B6%E4%BC%A0%E5%8F%82/</url>
    <content><![CDATA[<blockquote>
<p>本文主要介绍了vue中使用路由进行页面的跳转时,vue的路由如何传递参数,第二个页面如何获取参数.</p>
</blockquote>
<a id="more"></a>
<h1 id="一-通过router-link进行跳转"><a href="#一-通过router-link进行跳转" class="headerlink" title="一. 通过router-link进行跳转"></a>一. 通过router-link进行跳转</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-link</span><br><span class="line">:to=&quot;&#123;</span><br><span class="line">path: &apos;yourPath&apos;,</span><br><span class="line">    params: &#123;</span><br><span class="line">    name: &apos;name&apos;,</span><br><span class="line">        dataObj: data</span><br><span class="line">&#125;,</span><br><span class="line">query: &#123;</span><br><span class="line">    name: &apos;name&apos;,</span><br><span class="line">        dataObj: data</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;&gt;</span><br><span class="line">&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>path -&gt; 是要跳转的路由路径,也可以是路由文件里面配置的 name 值,两者都可以进行路由导航</li>
<li>params -&gt; 是要传送的参数,参数可以直接key:value形式传递</li>
<li>query -&gt; 是通过 url 来传递参数的同样是key:value形式传递</li>
</ol>
<h1 id="二-通过编程导航-router进行路由跳转"><a href="#二-通过编程导航-router进行路由跳转" class="headerlink" title="二. 通过编程导航 $router进行路由跳转"></a>二. 通过编程导航 $router进行路由跳转</h1><h2 id="1-路径后拼接参数"><a href="#1-路径后拼接参数" class="headerlink" title="1.路径后拼接参数"></a>1.路径后拼接参数</h2><p><strong>通过路径后直接拼接来传递参数</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getDescribe(id) &#123;</span><br><span class="line">// 直接调用$router.push 实现携带参数的跳转</span><br><span class="line">        this.$router.push(&#123;</span><br><span class="line">          path: `/describe/$&#123;id&#125;`,</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>对应路由配置</strong><br><strong>注意:</strong>此方法需要修改对应路由配置,需要在path中添加/:id来对应 $router.push 中path携带的参数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;/describe/:id&apos;,</span><br><span class="line">    name: &apos;Describe&apos;,</span><br><span class="line">    component: Describe</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>获取传递的参数值</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$route.params.id</span><br></pre></td></tr></table></figure></p>
<p><strong>注意:</strong>此处不是<code>$router</code>,而是<code>$route</code>,没有”r”.</p>
<h2 id="2-通过params来传递参数"><a href="#2-通过params来传递参数" class="headerlink" title="2. 通过params来传递参数"></a>2. 通过params来传递参数</h2><p><strong>传递参数</strong><br>通过路由属性中的name来确定匹配的路由，通过params来传递参数。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$router.push(&#123;</span><br><span class="line">         name: &apos;Describe&apos;,</span><br><span class="line">         params: &#123;</span><br><span class="line">           id: id</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>对应路由配置</strong><br>注意这里不能使用:/id来传递参数了，因为已经使用params来携带参数了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     path: &apos;/describe&apos;,</span><br><span class="line">     name: &apos;Describe&apos;,</span><br><span class="line">     component: Describe</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>获取参数</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$route.params.id</span><br></pre></td></tr></table></figure></p>
<p><strong>注意:</strong>此处不是<code>$router</code>,而是<code>$route</code>,没有”r”.</p>
<h2 id="3-通过query来传递参数"><a href="#3-通过query来传递参数" class="headerlink" title="3. 通过query来传递参数"></a>3. 通过query来传递参数</h2><p><strong>传递参数</strong><br>使用path来匹配路由，然后通过query来传递参数<br>这种情况下 query传递的参数会显示在url后面?id=？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$router.push(&#123;</span><br><span class="line">          path: &apos;/describe&apos;,</span><br><span class="line">          query: &#123;</span><br><span class="line">            id: id</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>对应路由配置</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;/describe&apos;,</span><br><span class="line">    name: &apos;Describe&apos;,</span><br><span class="line">    component: Describe</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>获取参数</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$route.query.id</span><br></pre></td></tr></table></figure></p>
<p><strong>注意:</strong>此处不是<code>$router</code>,而是<code>$route</code>,没有”r”.</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue $emit $refs子父组件间方法的调用</title>
    <url>/2019/10/22/Vue/Vue-emit-refs%E5%AD%90%E7%88%B6%E7%BB%84%E4%BB%B6%E9%97%B4%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue组件之间传参</title>
    <url>/2019/10/22/Vue/Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E5%8F%82/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>vue常用指令</title>
    <url>/2019/10/19/Vue/vue%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>指令 (Directives) 是带有<code>v-</code> 前缀的特殊特性。指令特性的值预期是单个 JavaScript 表达式 (<code>v-for</code> 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</p><h1 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h1><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>用于动态改变内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello Vue!&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind:"></a><code>v-bind</code>:</h2><p>用于动态改变标签内的属性</p>
<p>将这个元素节点的 title 特性和 Vue 实例的 message 属性保持一致。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app-2&quot;&gt;</span><br><span class="line">  &lt;span v-bind:title=&quot;message&quot;&gt;</span><br><span class="line">    鼠标悬停几秒钟查看此处动态绑定的提示信息！</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var app2 = new Vue(&#123;</span><br><span class="line">  el: &apos;#app-2&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;页面加载于 &apos; + new Date().toLocaleString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a><code>v-model</code></h2><p>主要用于实现表单输入和应用状态之间的双向绑定 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app-6&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;input v-model=&quot;message&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var app6 = new Vue(&#123;</span><br><span class="line">  el: &apos;#app-6&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello Vue!&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a><code>v-if</code></h2><p>于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a><code>v-show</code></h2><p>于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。 不同的是带有 <code>v-show</code> 的元素始终会被渲染并保留在 DOM 中。<code>v-show</code>只是简单地切换元素的 CSS 属性 display。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般来说，<code>v-if</code>有更高的切换开销，而<code>v-show</code>有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用<code>v-show</code>较好；如果在运行时条件很少改变，则使用 <code>v-if</code>较好。</p>
<h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><p>以用 <code>v-for</code> 指令基于一个数组来渲染一个列表。<code>v-for</code>指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul id=&quot;example-1&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in items&quot;&gt;</span><br><span class="line">    &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var example1 = new Vue(&#123;</span><br><span class="line">  el: &apos;#example-1&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [</span><br><span class="line">      &#123; message: &apos;Foo&apos; &#125;,</span><br><span class="line">      &#123; message: &apos;Bar&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<ul>
<li>Foo</li>
<li>Bar</li>
</ul>
<h1 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h1><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a><code>v-on</code></h2><p>用<code>v-on</code>指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;example-1&quot;&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;counter += 1&quot;&gt;Add 1&lt;/button&gt;</span><br><span class="line">  &lt;p&gt;The button above has been clicked &#123;&#123; counter &#125;&#125; times.&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var example1 = new Vue(&#123;</span><br><span class="line">  el: &apos;#example-1&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">Vue.js官方文档</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>hexo使用next主题更新文章报错页面空白</title>
    <url>/2019/10/18/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/hexo%E4%BD%BF%E7%94%A8next%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E6%96%87%E7%AB%A0%E6%8A%A5%E9%94%99%E9%A1%B5%E9%9D%A2%E7%A9%BA%E7%99%BD/</url>
    <content><![CDATA[<h1 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h1><p>hexo更新主题next报错应用程序未找到<br>hexo版本：3.7.1<br>next版本：7.4.1</p><h2 id="报错信息："><a href="#报错信息：" class="headerlink" title="报错信息："></a>报错信息：</h2><p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g82iw8p8y3j30gc07674i.jpg" alt="91d3f82d-8c77-4450-b9aa-02b197d13b18.png"></p><p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g82iwjplqjj31he0h1abd.jpg" alt="a9290383-eb46-46e4-8f83-3e0397b3523b.png"></p><h1 id="解决过程："><a href="#解决过程：" class="headerlink" title="解决过程："></a>解决过程：</h1><h2 id="定位报错文章"><a href="#定位报错文章" class="headerlink" title="定位报错文章"></a>定位报错文章</h2><p>一步步重现我更新的操作，发现时移入文章后开始报这个错，然后定位报错的文章（一个个试看哪个移动后报错），定位到了如下文章：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 目前流行的组件库有哪些？css，js各有哪些流行的库？</span><br><span class="line">categories:</span><br><span class="line">  - 层叠样式表CSS</span><br><span class="line">  - 深度思考</span><br><span class="line">date: 2019-10-11 22:17:53</span><br><span class="line">tags:</span><br><span class="line">---</span><br><span class="line"># CSS流行组件库</span><br><span class="line"></span><br><span class="line">## Bootstrap </span><br><span class="line"></span><br><span class="line">Bootstrap，让你的页面更简洁、直观、强悍、移动设备优先的前端开发框架,让web开发更迅速、更简单。它还提供了更优雅的HTML和CSS规范，它即是由动态CSS语言Less写成。有着丰富的网格布局系统以及丰富的可重用组件，还有强大的支持十几的JavaScript、jQuery插件以及组件定制等。</span><br><span class="line"></span><br><span class="line">Bootstrap中文网地址：http://www.bootcss.com/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># JS流行组件库</span><br><span class="line"></span><br><span class="line">## jQuery </span><br><span class="line"></span><br><span class="line">jQuery是最常用的JavaScript库，它革命性的在客户端开发，将CSS选择器引入到DOM节点检索加链接来应用事件处理程序，动画和Ajax调用.jQuery近年来备受青睐，对于一个很需要的的JavaScript的功能的项目来说，jQuery的的的绝对是一个可行的选择。</span><br><span class="line"></span><br><span class="line">官网地址： https://jquery.com/ </span><br><span class="line"></span><br><span class="line">## ElementUI</span><br><span class="line"></span><br><span class="line">Element-Ul是饿了么前端团队推出的一款基于Vue.js 2.0 的桌面端UI框架，手机端有对应框架是Mint UI 。适合于Vue的UI框架；</span><br><span class="line"></span><br><span class="line">官网地址：http://element-cn.eleme.io/#/zh-CN</span><br><span class="line"></span><br><span class="line">## Ant Design</span><br><span class="line"></span><br><span class="line">服务于企业级产品的设计体系，基于确定和自然的设计价值观上的模块化解决方案，让设计者和开发者专注于更好的用户体验。 </span><br><span class="line"></span><br><span class="line">官网地址：&lt;https://ant.design/index-cn&gt; </span><br><span class="line"></span><br><span class="line">## UI Bootstrap</span><br><span class="line"></span><br><span class="line">基于Angular2的一款组件库，有手风琴，日期选择器，弹出窗口等组件。</span><br><span class="line"></span><br><span class="line">官网地址：&lt;https://angular-ui.github.io/bootstrap/&gt;</span><br></pre></td></tr></table></figure></p><a id="more"></a>



<h2 id="定位报错代码"><a href="#定位报错代码" class="headerlink" title="定位报错代码"></a>定位报错代码</h2><p>一行行删除代码，发现删除如下行代码，编译后不再报错。<br>报错代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## jQuery</span><br></pre></td></tr></table></figure></p>
<p>代码区块：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># CSS流行组件库</span><br><span class="line"></span><br><span class="line">## Bootstrap </span><br><span class="line"></span><br><span class="line">Bootstrap，让你的页面更简洁、直观、强悍、移动设备优先的前端开发框架,让web开发更迅速、更简单。它还提供了更优雅的HTML和CSS规范，它即是由动态CSS语言Less写成。有着丰富的网格布局系统以及丰富的可重用组件，还有强大的支持十几的JavaScript、jQuery插件以及组件定制等。</span><br><span class="line"></span><br><span class="line">Bootstrap中文网地址：http://www.bootcss.com/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># JS流行组件库</span><br><span class="line"></span><br><span class="line">## jQuery</span><br></pre></td></tr></table></figure></p>
<h1 id="问题解决方案"><a href="#问题解决方案" class="headerlink" title="问题解决方案"></a>问题解决方案</h1><p>将jQuery前面加一些文字</p>
<h1 id="问题出现原因："><a href="#问题出现原因：" class="headerlink" title="问题出现原因："></a>问题出现原因：</h1><p>我依次尝试了一下几种写法试图找一下规律：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 123 正常渲染</span><br><span class="line">## JS库jQuery 正常渲染</span><br><span class="line">## **jQuery** 报错,页面空白</span><br><span class="line">## jquery  报错,页面空白</span><br><span class="line">## eg:jquery  报错,页面空白</span><br><span class="line">## eg:jQuery  报错,页面空白</span><br><span class="line">## jQuery 报错,页面空白</span><br></pre></td></tr></table></figure></p>
<p>大概可能是jQuery影响了hexo的编译吧，具体原因不明，去github上问一下再来补充吧。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>问题解决耗时：3小时<br>这么一个小小的问题导致整个页面崩溃，而且还这么难定位，从报错信息根本无从下手，真是难受。<br>本问题解决使用了寻找bug的一般流程和二分排除法。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://tianxintiandisheng.github.io/2018/08/24/项目开发/如何验证程序是否完成，测试以及修正Bug" target="_blank" rel="noopener">如何验证程序是否完成，测试以及deBug?</a></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>知道css有个content属性吗？有什么作用？有什么应用？</title>
    <url>/2019/10/11/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%8315/%E7%9F%A5%E9%81%93css%E6%9C%89%E4%B8%AAcontent%E5%B1%9E%E6%80%A7%E5%90%97%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="CSS-content"><a href="#CSS-content" class="headerlink" title="CSS content"></a>CSS content</h1><p>content 属性与 :before 及 :after 伪元素配合使用，来插入生成内容。 </p><p>实例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">a:after &#123;content: &quot; (&quot; attr(href) &quot;)&quot;;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;&lt;a href=&quot;https://tianxintiandisheng.github.io&quot;&gt;天心天地生的个人博客&lt;/a&gt; - 免费的在线笔记&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;b&gt;注意:&lt;/b&gt;仅当 !DOCTYPE已经定义 IE8支持 content属性&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>


<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><ul>
<li>最基本的 – 生成内容  content属性与:before及:after伪元素配合使用生成文本内容 </li>
<li>嵌入文字符号 </li>
<li>使用计数器创建号码内容  </li>
<li>为多语言内容插入正确的引号  </li>
<li>用图片替换文字  </li>
<li>显示相对应的链接图标  </li>
<li>使用属性值作为content内容 </li>
</ul>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？</title>
    <url>/2019/10/11/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%8315/%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%A0%BC%E5%BC%8F%E5%90%97%EF%BC%9F%E8%B0%88%E8%B0%88%E7%90%86%E8%A7%A3%E3%80%82%E5%9C%A8%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E4%B8%AD%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E5%BE%AE%E6%A0%BC%E5%BC%8F%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="微格式"><a href="#微格式" class="headerlink" title="微格式"></a>微格式</h1><p>建立在已有的、被广泛采用的标准基础之上的一组简单的、开放的数据格式（microformats.org官方定义）。</p><p>是把语义嵌入到HTML以便有助于分离式开发而制定的一些简单约定，是兼顾人机可读性设计的数据表达方式，对Web网页进行语义注解的方法。</p><p>这种方法依托于标准的Web页面写作技术，例如，XHTML，这样引入语义信息对浏览器等所有现存的Web技术冲击最小。采用Microformat的 Web页面，在XHTML文档中给一些标签（Tag）增加一些属性（attribute），这些属性对信息的语义结构进行注解，处理XHTML文档的软件，</p><a id="more"></a>


<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="简单的微格式"><a href="#简单的微格式" class="headerlink" title="简单的微格式"></a>简单的微格式</h2><p>我们从上面的描述知道，微格式实际就是为现有的(X)HTML元素添加元数据和其他属性，增强语义。那么我们就来看一个简单的微格式应用吧。</p>
<p>以前我们是这样写一个链接到首页的<code>&lt;a&gt;&lt;/a&gt;</code>代码的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=”http://www.bbon.cn”&gt;Web Design Blog&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>而现在我们要为这个代码元素<code>&lt;a&gt;</code>加上 rel属性。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=”http://www.bbon.cn“ rel=”homepage”&gt;Web Design Blog&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<p>上面的链接标记<code>&lt;a&gt;</code>包括rel=”home”属性，该属性显示链接的目标页面是该网站的首页。通过为已有的链接元素添加语义化属性，就为这个链接添加了具体的结构和意义。</p>
<h2 id="hCard-微格式"><a href="#hCard-微格式" class="headerlink" title="hCard 微格式"></a>hCard 微格式</h2><p>hCard是一种微格式，用来发布个人，公司，组织，地点等详细的联系信息。它可以包含在(X)HTML，Atom，RSS等可扩展置标语言中。hCard使用vCard（RFC 2426）的属性和值来实现这些功能。</p>
<p>它可以使分析器（比如其他网站，Firefox的Operator插件）获得详细的信息，并通过别的网站或者地图工具进行显示，或者载入到地址簿等其他程序。</p>
<h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><p>如下HTML代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;div&gt;Joe Doe&lt;/div&gt;</span><br><span class="line">&lt;div&gt;The Example Company&lt;/div&gt;</span><br><span class="line">&lt;div&gt;604-555-1234&lt;/div&gt;</span><br><span class="line">&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p> 加入微格式后，成为： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;vcard&quot;&gt;</span><br><span class="line">&lt;div class=&quot;fn&quot;&gt;Joe Doe&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;org&quot;&gt;The Example Company&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;tel&quot;&gt;604-555-1234&lt;/div&gt;</span><br><span class="line">&lt;a class=&quot;url&quot; href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>这里，正式名称（class=”fn”），组织（class=”org”），电话号码（class=”tel”）和url（class=”url”）分别用相应的class标示；同时，所有内容都包含在class=”vcard”里。 </p>
<h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><p>这里是维基媒体基金会的联系方式，可以作为hCard的一个真实示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Wikimedia Foundation Inc.</span><br><span class="line"></span><br><span class="line">200 2nd Ave. South #358</span><br><span class="line"></span><br><span class="line">St. Petersburg, FL 33701-4313</span><br><span class="line"></span><br><span class="line">USA</span><br><span class="line"></span><br><span class="line">Phone: +1-727-231-0101</span><br><span class="line"></span><br><span class="line">Email: info@wikimedia.org</span><br><span class="line"></span><br><span class="line">Fax: +1-727-258-0207</span><br></pre></td></tr></table></figure>
<p>加入微格式后，成为： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;vcard&quot;&gt;</span><br><span class="line">&lt;div class=&quot;fn org&quot;&gt;Wikimedia Foundation Inc.&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;adr&quot;&gt;</span><br><span class="line">&lt;div class=&quot;street-address&quot;&gt;200 2nd Ave. South #358&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;span class=&quot;locality&quot;&gt;St. Petersburg&lt;/span&gt;,</span><br><span class="line">&lt;span class=&quot;region&quot;&gt;FL&lt;/span&gt; &lt;span class=&quot;postal-code&quot;&gt;33701-4313&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;country-name&quot;&gt;USA&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;Phone: &lt;span class=&quot;tel&quot;&gt;+1-727-231-0101&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;Email: &lt;span class=&quot;email&quot;&gt;info@wikimedia.org&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;span class=&quot;tel&quot;&gt;&lt;span class=&quot;type&quot;&gt;Fax&lt;/span&gt;:</span><br><span class="line">&lt;span class=&quot;value&quot;&gt;+1-727-258-0207&lt;/span&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>注意，在这个例子中，正式名称（class=”fn”）和组织（class=”org”）写在了一个属性中，表示这是一个组织，而不是个人。 </p>
<h1 id="在前端构建中微格式的意义"><a href="#在前端构建中微格式的意义" class="headerlink" title="在前端构建中微格式的意义"></a>在前端构建中微格式的意义</h1><p>那么，微格式在实际应用中的意义和作用又是什么呢？微格式按照某种已有的被广泛应用的标准，通过对内容块的语义标记，可以让外部应用程序、聚合程序和搜索引擎能够做以下事情：</p>
<ol>
<li>在爬取Web内容时，能够更为准确地识别内容块的语义；</li>
<li>对内容进行操作，包括提供访问、校对，还可以将其转化成其他的相关格式，提供给外部程序和Web服务使用。</li>
</ol>
<p>总结： 可以对网站进行SEO优化，如果需要可以考虑。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/deng131/article/details/83632737" target="_blank" rel="noopener">什么是微格式及实例</a></p>
<p>版权声明：本文为CSDN博主「deng131」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/deng131/article/details/83632737" target="_blank" rel="noopener">https://blog.csdn.net/deng131/article/details/83632737</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>HTML5的离线储存怎么使用？</title>
    <url>/2019/10/11/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%8315/HTML5%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%82%A8%E5%AD%98%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<p>HTML5 提拱更好的本地存储规范 localStorage 和 sessionStorage , 它们将数据存储在本地，而且在http请求时不会携带 Storage 里的信息, 使用方式也很简单: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">localStorage.setItem(&apos;key&apos;, &apos;value&apos;);</span><br><span class="line">localStorage.getItem(&apos;key&apos;);</span><br><span class="line">localStorage.removeItem(&apos;key&apos;);</span><br><span class="line">sessionStorage.setItem(&apos;key&apos;, &apos;value&apos;);</span><br><span class="line">sessionStorage.getItem(&apos;key&apos;);</span><br><span class="line">sessionStorage.removeItem(&apos;key&apos;);</span><br></pre></td></tr></table></figure><a id="more"></a>

<p>sessionStorage 和 localStorage 使用方式及特性基本一致，</p>
<p>唯一的区别是：</p>
<ul>
<li>localStorage - 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。</li>
<li>sessionStorage - 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。</li>
</ul>
<p>参考资料：<a href="https://www.runoob.com/html/html5-webstorage.html" target="_blank" rel="noopener">HTML5 Web 存储</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>渐进增强和优雅降级之间有什么不同?</title>
    <url>/2019/10/11/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%8315/%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/</url>
    <content><![CDATA[<h1 id="渐进增强"><a href="#渐进增强" class="headerlink" title="渐进增强"></a>渐进增强</h1><p>在网页开发中，渐进增强认为应该专注于内容本身。一开始针对低版本的浏览器构建页面，满足最基本的功能，再针对高级浏 览器进行效果，交互，追加各种功能以达到更好用户体验。</p><p><strong>总结： 以最低要求，实现最基础功能为基本，向上兼容.</strong>  </p><h1 id="优雅降级"><a href="#优雅降级" class="headerlink" title="优雅降级"></a>优雅降级</h1><p>在网页开发中，优雅降级指的是一开始针对一个高版本的浏览器构建页面，先完善所有的功能。然后针对各个不同的浏览器进行测试，修复，保证低级浏览器也有基本功能 就好，低级浏览器被认为“简陋却无妨 (poor, but passable)” 可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较 大的错误之外，其它的差异将被直接忽略。</p><a id="more"></a>


<p><strong>总结： 以高要求，高版本为基准，向下兼容。</strong>  </p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>Quirks模式是什么？它和Standards模式有什么区别？</title>
    <url>/2019/10/11/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%8315/Quirks%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E5%92%8CStandards%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="Quirks怪癖模式是什么"><a href="#Quirks怪癖模式是什么" class="headerlink" title="Quirks怪癖模式是什么"></a>Quirks怪癖模式是什么</h1><p> 从IE6开始，引入了Standards模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。 </p><p> 在IE6之前CSS还不够成熟，所以IE5等之前的浏览器对CSS的支持很差， IE6将对CSS提供更好的支持，然而这时的问题就来了，因为有很多页面是基于旧的布局方式写的，而如果IE6 支持CSS则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制呢？  在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。遇到这种问题时的一个常见做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数 不为真时，就使用旧功能，这样就能不破坏原有的程序，又提供新功能。IE6也是类似这样做的，它将DTD（文档类型定义）当成了这个“参数”，因为以前的页面大家都不会去写DTD，所以IE6就假定 如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是Quirks模式（怪癖模式，诡异模式，怪异模式）。 </p><a id="more"></a>

<h1 id="Quirks和Standards模式有什么区别"><a href="#Quirks和Standards模式有什么区别" class="headerlink" title="Quirks和Standards模式有什么区别"></a>Quirks和Standards模式有什么区别</h1><p>总体会有布局、样式解析和脚本执行三个方面的区别。</p>
<p>盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在Quirks 模式下，IE的宽度和高度还包含了padding和border。  </p>
<p>设置行内元素的高宽：在Standards模式下，给等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。  </p>
<p>设置百分比的高度：在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的  用margin:0 auto设置水平居中：使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效。 </p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>目前流行的组件库有哪些？css，js各有哪些流行的库？</title>
    <url>/2019/10/11/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%8315/%E7%9B%AE%E5%89%8D%E6%B5%81%E8%A1%8C%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BA%93%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9Fcss%EF%BC%8Cjs%E5%90%84%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B5%81%E8%A1%8C%E7%9A%84%E5%BA%93%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="CSS流行组件库"><a href="#CSS流行组件库" class="headerlink" title="CSS流行组件库"></a>CSS流行组件库</h1><h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><p>Bootstrap，让你的页面更简洁、直观、强悍、移动设备优先的前端开发框架,让web开发更迅速、更简单。它还提供了更优雅的HTML和CSS规范，它即是由动态CSS语言Less写成。有着丰富的网格布局系统以及丰富的可重用组件，还有强大的支持十几的JavaScript、jQuery插件以及组件定制等。</p><a id="more"></a>
<p>Bootstrap中文网地址：<a href="http://www.bootcss.com/" target="_blank" rel="noopener">http://www.bootcss.com/</a></p>
<h1 id="JS流行组件库"><a href="#JS流行组件库" class="headerlink" title="JS流行组件库"></a>JS流行组件库</h1><h2 id="Js库jQuery"><a href="#Js库jQuery" class="headerlink" title="Js库jQuery"></a>Js库jQuery</h2><p>jQuery是最常用的JavaScript库，它革命性的在客户端开发，将CSS选择器引入到DOM节点检索加链接来应用事件处理程序，动画和Ajax调用.jQuery近年来备受青睐，对于一个很需要的的JavaScript的功能的项目来说，jQuery的的的绝对是一个可行的选择。</p>
<p>官网地址： <a href="https://jquery.com/" target="_blank" rel="noopener">https://jquery.com/</a> </p>
<h2 id="ElementUI"><a href="#ElementUI" class="headerlink" title="ElementUI"></a>ElementUI</h2><p>Element-Ul是饿了么前端团队推出的一款基于Vue.js 2.0 的桌面端UI框架，手机端有对应框架是Mint UI 。适合于Vue的UI框架；</p>
<p>官网地址：<a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">http://element-cn.eleme.io/#/zh-CN</a></p>
<h2 id="Ant-Design"><a href="#Ant-Design" class="headerlink" title="Ant Design"></a>Ant Design</h2><p>服务于企业级产品的设计体系，基于确定和自然的设计价值观上的模块化解决方案，让设计者和开发者专注于更好的用户体验。 </p>
<p>官网地址：<a href="https://ant.design/index-cn" target="_blank" rel="noopener">https://ant.design/index-cn</a> </p>
<h2 id="UI-Bootstrap"><a href="#UI-Bootstrap" class="headerlink" title="UI Bootstrap"></a>UI Bootstrap</h2><p>基于Angular2的一款组件库，有手风琴，日期选择器，弹出窗口等组件。</p>
<p>官网地址：<a href="https://angular-ui.github.io/bootstrap/" target="_blank" rel="noopener">https://angular-ui.github.io/bootstrap/</a> </p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>为什么要做组件库？</title>
    <url>/2019/10/11/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%8312-14/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E7%BB%84%E4%BB%B6%E5%BA%93%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="传统开发方式的弊端"><a href="#传统开发方式的弊端" class="headerlink" title="传统开发方式的弊端"></a>传统开发方式的弊端</h1><p>在大型软件系统中，web应用的前后端已经实现了分离，而随着REST软件架构的发展，后端服务逐步倾向于微服务，简单来说就是将一个大型后端服务，拆分成多个小服务，它们分别部署，降低了开发的复杂性，而且提高了系统的可伸缩性。而前端方面，随着技术的发展，开发的复杂度也越来越高，传统开发模式总是存在着开发效率低，维护成本高等的弊端。  </p><a id="more"></a>
<h1 id="弊端产生的原因"><a href="#弊端产生的原因" class="headerlink" title="弊端产生的原因"></a>弊端产生的原因</h1><p>传统开发方式效率低以及维护成本高的主要原因在于很多时候是将一个系统做成了整块应用，而且往往随着业务的增长或者变更，系统的复杂度会呈现指数级的增长，经常出现的情况就是一个小小的改动或者一个小功能的增加可能会引起整体逻辑的修改，造成牵一发而动全身。  </p>
<p>针对此弊端，其实业界早就有了一些探索，我们希望一个大且复杂的场景能够被分解成几个小的部分，这些小的部分彼此之间互不干扰，可以单独开发，单独维护，而且他们之间可以随意的进行组合。就拿电脑主机来说，一台整机包括CPU，主板，内存，硬盘等等，而这些部件其实都是由不同的公司进行生产的，他们彼此之间根据一套标准分别生产，最后组装在一起。当某个部件出现问题时，不需要将整台主机都进行维修，只需要将坏的部件拿下来，维修之后再将其组合上就可以了。这种化繁为简的思想在后端开发中的体现是微服务，而在前端开发中的体现就是组件化。  </p>
<h1 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h1><p>随着React，angular等以组件（指令等）为主的优秀前端框架的出现，前端组件化逐渐成为前端开发的迫切需求，当然这一迫切需求也逐渐成为一种主流，一种共识，它不仅提高了前端的开发效率，同时也降低了维护成本。开发者们不需要再面对一堆复杂且难阅读的代码，转而只需要关注以组件方式存在的代码片段。 </p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>固定宽度布局开发WebApp如何实现多终端下自适应？</title>
    <url>/2019/10/11/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%8312-14/%E5%9B%BA%E5%AE%9A%E5%AE%BD%E5%BA%A6%E5%B8%83%E5%B1%80%E5%BC%80%E5%8F%91WebApp%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BB%88%E7%AB%AF%E4%B8%8B%E8%87%AA%E9%80%82%E5%BA%94%EF%BC%9F/</url>
    <content><![CDATA[<p>现在人通过手机浏览网页占了大多数，随着浏览方式的改变，网页在webapp下面实现多终端自适应，无论对于避免工程师无谓的重复劳动或者是项目管理的便捷性上来说重要性都是十分巨大的。 </p><h1 id="固定宽度布局"><a href="#固定宽度布局" class="headerlink" title="固定宽度布局"></a>固定宽度布局</h1><p>固定宽度式布局是目前国内最常用的布局方法，优点就是固定宽度使得其布局最简便，使得开发人员对布局和定位有更大的控制能力。</p><a id="more"></a>

<p>但是，固定宽度的布局也有缺点，因为它的宽度是固定的，无论窗口尺寸有多大，它的尺寸总是不变，所以无法充分利用可用空间。因此，它们也常常被认为是糟糕的权宜之计。</p>
<p>固定宽度的布局的示例，这个大家都是拿手布局方法。</p>
<p>html代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">     &lt;div class=&quot;primary&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;primary&quot;&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;secondary&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;secondary&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>css样式代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.wrapper &#123;</span><br><span class="line">  width: 920px; </span><br><span class="line">  margin: 0 auto; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.content &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.content .primary &#123; </span><br><span class="line">  width: 670px;</span><br><span class="line">  float: right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.content .secondary &#123; </span><br><span class="line">  width: 230px;</span><br><span class="line">  float: left; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">.content .primary .primary &#123;</span><br><span class="line">    width: 400px;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.content .primary .secondary &#123;</span><br><span class="line">    width: 230px;</span><br><span class="line">    padding-right: 20px;</span><br><span class="line">    float: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考资料：<a href="https://www.cnblogs.com/qiheng/archive/2014/04/21/3676904.html" target="_blank" rel="noopener">网页的三种布局(固定宽度式,流体式,弹性式) </a></p>
<h1 id="固定宽度多终端自适应"><a href="#固定宽度多终端自适应" class="headerlink" title="固定宽度多终端自适应"></a>固定宽度多终端自适应</h1><h2 id="固定宽度布局在移动端遇到的问题"><a href="#固定宽度布局在移动端遇到的问题" class="headerlink" title="固定宽度布局在移动端遇到的问题"></a>固定宽度布局在移动端遇到的问题</h2><h3 id="默认viewoort导致横向滚动条"><a href="#默认viewoort导致横向滚动条" class="headerlink" title="默认viewoort导致横向滚动条"></a>默认viewoort导致横向滚动条</h3><p>移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是<strong>浏览器会出现横向滚动条</strong>，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。 </p>
<h3 id="CSS中的1PX并不等于设备的1PX"><a href="#CSS中的1PX并不等于设备的1PX" class="headerlink" title="CSS中的1PX并不等于设备的1PX"></a>CSS中的1PX并不等于设备的1PX</h3><p>在css中我们一般使用px作为单位，在桌面浏览器中css的1个像素往往都是对应着电脑屏幕的1个物理像素，这可能会造成我们的一个错觉，那就是css中的像素就是设备的物理像素。但实际情况却并非如此，css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。</p>
<p>还有一个因素也会引起css中px的变化，那就是用户缩放。例如，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;meta&gt;</code>标签是如何控制网页的尺寸和缩放浏览器的说明。</p>
<p><strong>width=device-width</strong>部分将页面的宽度设置为跟随设备的屏幕宽度（视设备而定）。</p>
<p><strong>initial-scale=1.0</strong>部分设置浏览器首次加载页面时的初始缩放级别。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/jnshu_it/article/details/85758753" target="_blank" rel="noopener">定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>移动端有哪些常见布局方式？</title>
    <url>/2019/10/11/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%8312-14/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%EF%BC%9F/</url>
    <content><![CDATA[<ol>
<li><p>响应式布局。 </p>
<p>可以用px作为像素，网页进行平铺。全屏的用100%。高度可以用px写死，宽度可以用百分比。不管网页怎么拉伸，高度不变，宽度会相应的扩大。</p>
</li>
<li><p>em/rem 方式布局。 </p>
<p>可以设置好html，body的字体大小，然后用不同的尺寸手机访问的时候，我们可以去修改body的字体大小，网页（网页的内容用rem设置宽度、高度）的之内容会自动进行缩放。</p>
</li>
<li><p>可以按照设计稿的宽 高 来写css，然后通过js判断不同尺寸屏幕，修改 里面 scale的比例大小。 </p>
<p>比如设计稿是 640 * 1136<br>我们可以按 640宽度写网页 也可以按320宽度写网页。<br>然后<br>默认宽度可以设置为你写网页的宽度。<br>然后再通过js 来控制scale的比例缩放即可 也可以控制 最小宽度 跟 最大宽度。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何做默认样式重置？resetting 和 normalizing 之间有什么区别？</title>
    <url>/2019/10/10/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%8312-14/%E5%A6%82%E4%BD%95%E5%81%9A%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F%E9%87%8D%E7%BD%AE%EF%BC%9Fresetting-%E5%92%8C-normalizing-%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="什么是CSS-resetting？"><a href="#什么是CSS-resetting？" class="headerlink" title="什么是CSS resetting？"></a>什么是CSS resetting？</h1><p>在HTML标签在浏览器里有默认的样式，例如 p 标签有上下边距，strong标签有字体加粗样式，em标签有字体倾斜样式。不同浏览器的默认样式之间也会有差别，例如ul默认带有缩进的样式，在IE下，它的缩进是通过margin实现的，而Firefox下，它的缩进是由padding实现的。在切换页面的时候，浏览器的默认样式往往会给我们带来麻烦，影响开发效率。所以解决的方法就是一开始就将浏览器的默认样式全部去掉，更准确说就是通过重新定义标签样式。“覆盖”浏览器的CSS默认属性。最最简单的说法就是把浏览器提供的默认样式覆盖掉！这就是CSS reset。</p><a id="more"></a>
<h2 id="CSS-Reset的作用"><a href="#CSS-Reset的作用" class="headerlink" title="CSS Reset的作用"></a>CSS Reset的作用</h2><p>CSS Reset让各个浏览器的CSS样式有一个统一的基准，而实现这一基准最主要的方式就是“清零”</p>
<h1 id="什么是normalizing？"><a href="#什么是normalizing？" class="headerlink" title="什么是normalizing？"></a>什么是normalizing？</h1><p>Normalize.css 只是一个很小的CSS文件，但它在默认的HTML元素样式上 提供了跨浏览器的高度一致性。相比于传统的CSS reset，Normalize.css 是一种现代的、为HTML5准备的优质替代方案。Normalize.css现在已经被 用于Twitter Bootstrap、HTML5 Boilerplate、GOV.UK、Rdio、CSS Tricks 以及许许多多其他框架、工具和网站上。</p>
<h2 id="normalize创造的目的"><a href="#normalize创造的目的" class="headerlink" title="normalize创造的目的"></a>normalize创造的目的</h2><p>保护有用的浏览器默认样式而不是完全去掉它们</p>
<h1 id="resetting-和-normalizing-之间有什么区别？"><a href="#resetting-和-normalizing-之间有什么区别？" class="headerlink" title="resetting 和 normalizing 之间有什么区别？"></a>resetting 和 normalizing 之间有什么区别？</h1><ol>
<li>Normalize.css 保护了有价值的默认值<br>Reset通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。 相比之下，Normalize.css保持了许多默认的浏览器样式。这就意味着你不用再 为所有公共的排版元素重新设置样式。当一个元素在不同的浏览器中有不同的默认值时， Normalize.css会力求让这些样式保持一致并尽可能与现代标准相符合。</li>
<li>Normalize.css 修复了浏览器的bug<br>它修复了常见的桌面端和移动端浏览器的bug。 这往往超出了Reset所能做到的范畴。关于这一点， Normalize.css修复的问题包含了HTML5元素的显示设置、 预格式化文字的font-size问题、在IE9中SVG的溢出、许多 出现在各浏览器和操作系统中的与表单相关的bug。</li>
<li>Normalize.css 不会让你的调试工具变的杂乱<br>使用Reset最让人困扰的地方莫过于在浏览器调试工具中大段大段的继承链， 如下图所示。在Normalize.css中就不会有这样的问题，因为在我们的准则中 对多选择器的使用时非常谨慎的，我们仅会有目的地对目标元素设置样式。</li>
<li>Normalize.css 是模块化的<br>这个项目已经被拆分为多个相关却又独立的部分， 这使得你能够很容易也很清楚地知道哪些元素被设置了特定的值。 因此这能让你自己选择性地移除掉某些永远不会用到部分（比如表单的一般化）。</li>
<li>Normalize.css 拥有详细的文档<br>Normalize.css的代码基于详细而全面的跨浏览器研究与测试。 这个文件中拥有详细的代码说明并在Github Wiki中有进一步的说明。 这意味着你可以找到每一行代码具体完成了什么工作、为什么要写这句代码、 浏览器之间的差异，并且你可以更容易地进行自己的测试。<br>总得来说，CSS Reset 是革命党 ，CSS Reset 里最激进那一派提倡不管你有用没用， 通通给我脱了衣服，于是 *{margin:0;} 等等运动，把人家全拍了。看似是众生平等了， 实则是浪费了资源又占不到便宜，有求于人家的时候还得给加回去，实在需要人家的默认 样式了怎么办？自己看着办吧。<br>Normalize.css 是改良派。他们提倡，各个元素都有其存在的道理， 简单粗暴地一视同仁是不好的。谁都有谁的作用，给他们制定个规范，确保他们 在任何浏览器里都干好自己的活儿就好了。</li>
</ol>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>CSS编码规范</title>
    <url>/2019/10/10/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/CSS%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>CSS作为网页样式的描述语言，在百度一直有着广泛的应用。本文档的目标是使CSS代码风格保持一致，容易被理解和被维护。</p><p>虽然本文档是针对CSS设计的，但是在使用各种CSS的预编译器(如less、sass、stylus等)时，适用的部分也应尽量遵循本文档的约定。</p><h2 id="2-代码风格"><a href="#2-代码风格" class="headerlink" title="2 代码风格"></a>2 代码风格</h2><h3 id="2-1-文件"><a href="#2-1-文件" class="headerlink" title="2.1 文件"></a>2.1 文件</h3><p> <strong>[建议]</strong> <code>CSS</code> 文件使用无 <code>BOM</code> 的 <code>UTF-8</code> 编码。</p><a id="more"></a>


<p>解释：</p>
<p>UTF-8 编码具有更广泛的适应性。BOM 在使用程序或工具处理文件时可能造成不必要的干扰。</p>
<h3 id="2-2-缩进"><a href="#2-2-缩进" class="headerlink" title="2.2 缩进"></a>2.2 缩进</h3><p> <strong>[强制]</strong> 使用 <code>4</code> 个空格做为一个缩进层级，不允许使用 <code>2</code> 个空格 或 <code>tab</code> 字符。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.selector</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-空格"><a href="#2-3-空格" class="headerlink" title="2.3 空格"></a>2.3 空格</h3><p> <strong>[强制]</strong> <code>选择器</code> 与 <code>{</code> 之间必须包含空格。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.selector</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>[强制]</strong> <code>属性名</code> 与之后的 <code>:</code> 之间不允许包含空格， <code>:</code> 与 <code>属性值</code> 之间必须包含空格。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">margin</span>: 0;</span><br></pre></td></tr></table></figure>
<p> <strong>[强制]</strong> <code>列表型属性值</code> 书写在单行时，<code>,</code> 后必须跟一个空格。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-family</span>: <span class="selector-tag">Arial</span>, <span class="selector-tag">sans-serif</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-行长度"><a href="#2-4-行长度" class="headerlink" title="2.4 行长度"></a>2.4 行长度</h3><p> <strong>[强制]</strong> 每行不得超过 <code>120</code> 个字符，除非单行不可分割。</p>
<p>解释：</p>
<p>常见不可分割的场景为URL超长。</p>
<p> <strong>[建议]</strong> 对于超长的样式，在样式值的 <code>空格</code> 处或 <code>,</code> 后换行，建议按逻辑分组。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不同属性值按逻辑分组 */</span></span><br><span class="line"><span class="selector-tag">background</span>:</span><br><span class="line">    <span class="selector-tag">transparent</span> <span class="selector-tag">url</span>(<span class="selector-tag">aVeryVeryVeryLongUrlIsPlacedHere</span>)</span><br><span class="line">    <span class="selector-tag">no-repeat</span> 0 0;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可重复多次的属性，每次重复一行 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>:</span><br><span class="line">    <span class="selector-tag">url</span>(<span class="selector-tag">aVeryVeryVeryLongUrlIsPlacedHere</span>)</span><br><span class="line">    <span class="selector-tag">url</span>(<span class="selector-tag">anotherVeryVeryVeryLongUrlIsPlacedHere</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类似函数的属性值可以根据函数调用的缩进进行 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">-webkit-gradient</span>(</span><br><span class="line">    <span class="selector-tag">linear</span>,</span><br><span class="line">    <span class="selector-tag">left</span> <span class="selector-tag">bottom</span>,</span><br><span class="line">    <span class="selector-tag">left</span> <span class="selector-tag">top</span>,</span><br><span class="line">    <span class="selector-tag">color-stop</span>(0<span class="selector-class">.04</span>, <span class="selector-tag">rgb</span>(88,94,124)),</span><br><span class="line">    <span class="selector-tag">color-stop</span>(0<span class="selector-class">.52</span>, <span class="selector-tag">rgb</span>(115,123,162))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="2-5-选择器"><a href="#2-5-选择器" class="headerlink" title="2.5 选择器"></a>2.5 选择器</h3><p> <strong>[强制]</strong> 当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.post</span>,</span><br><span class="line"><span class="selector-class">.page</span>,</span><br><span class="line"><span class="selector-class">.comment</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-class">.post</span>, <span class="selector-class">.page</span>, <span class="selector-class">.comment</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>[强制]</strong> <code></code>、<code>+</code>、<code>~</code> 选择器的两边各保留一个空格。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">main</span>  <span class="selector-tag">nav</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">label</span> + <span class="selector-tag">input</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> ~ <span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#69C</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">mainnav</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">label</span>+<span class="selector-tag">input</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:checked</span>~<span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#69C</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>[强制]</strong> 属性选择器中的值必须用双引号包围。</p>
<p>解释：</p>
<p>不允许使用单引号，不允许不使用引号。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">article</span><span class="selector-attr">[character="juliet"]</span> &#123;</span><br><span class="line">    <span class="attribute">voice-family</span>: <span class="string">"Vivien Leigh"</span>, victoria, female</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">article</span><span class="selector-attr">[character='juliet']</span> &#123;</span><br><span class="line">    <span class="attribute">voice-family</span>: <span class="string">"Vivien Leigh"</span>, victoria, female</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-属性"><a href="#2-6-属性" class="headerlink" title="2.6 属性"></a>2.6 属性</h3><p> <strong>[强制]</strong> 属性定义必须另起一行。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.selector</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-class">.selector</span> &#123; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<p> <strong>[强制]</strong> 属性定义后必须以分号结尾。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.selector</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-class">.selector</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-通用"><a href="#3-通用" class="headerlink" title="3 通用"></a>3 通用</h2><h3 id="3-1-选择器"><a href="#3-1-选择器" class="headerlink" title="3.1 选择器"></a>3.1 选择器</h3><p> <strong>[强制]</strong> 如无必要，不得为 <code>id</code>、<code>class</code> 选择器添加类型选择器进行限定。</p>
<p>解释：</p>
<p>在性能和维护性上，都有一定的影响。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-id">#error</span>,</span><br><span class="line"><span class="selector-class">.danger-message</span> &#123;</span><br><span class="line">    <span class="attribute">font-color</span>: <span class="number">#c00</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">dialog</span><span class="selector-id">#error</span>,</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.danger-message</span> &#123;</span><br><span class="line">    <span class="attribute">font-color</span>: <span class="number">#c00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>[建议]</strong> 选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-id">#username</span> <span class="selector-tag">input</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.comment</span> <span class="selector-class">.avatar</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-class">.page</span> <span class="selector-class">.header</span> <span class="selector-class">.login</span> <span class="selector-id">#username</span> <span class="selector-tag">input</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.comment</span> <span class="selector-tag">div</span> * &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-属性缩写"><a href="#3-2-属性缩写" class="headerlink" title="3.2 属性缩写"></a>3.2 属性缩写</h3><p> <strong>[建议]</strong> 在可以使用缩写的情况下，尽量使用属性缩写。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.post</span> &#123;</span><br><span class="line">    <span class="attribute">font</span>: <span class="number">12px</span>/<span class="number">1.5</span> arial, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-class">.post</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: arial, sans-serif;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>[建议]</strong> 使用 <code>border</code> / <code>margin</code> / <code>padding</code> 等缩写时，应注意隐含值对实际数值的影响，确实需要设置多个方向的值时才使用缩写。</p>
<p>解释：</p>
<p>border / margin / padding 等缩写会同时设置多个属性的值，容易覆盖不需要覆盖的设定。如某些方向需要继承其他声明的值，则应该分开设置。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* centering &lt;article class="page" horizontally and highlight featured ones */</span></span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.page</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: auto;</span><br><span class="line">    <span class="attribute">margin-left</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.featured</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#69c</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-class">.page</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span> auto; <span class="comment">/* introducing redundancy */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.featured</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#69c</span>; <span class="comment">/* introducing redundancy */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-属性书写顺序"><a href="#3-3-属性书写顺序" class="headerlink" title="3.3 属性书写顺序"></a>3.3 属性书写顺序</h3><p> <strong>[建议]</strong> 同一 rule set 下的属性在书写时，应按功能进行分组，并以 <strong>Formatting Model（布局方式、位置）  Box Model（尺寸）  Typographic（文本相关）  Visual（视觉效果）</strong> 的顺序书写，以提高代码的可读性。</p>
<p>解释：</p>
<ul>
<li>Formatting Model 相关属性包括：<code>position</code> / <code>top</code> / <code>right</code> / <code>bottom</code> / <code>left</code> / <code>float</code> / <code>display</code> / <code>overflow</code> 等</li>
<li>Box Model 相关属性包括：<code>border</code> / <code>margin</code> / <code>padding</code> / <code>width</code> / <code>height</code> 等</li>
<li>Typographic 相关属性包括：<code>font</code> / <code>line-height</code> / <code>text-align</code> / <code>word-wrap</code> 等</li>
<li>Visual 相关属性包括：<code>background</code> / <code>color</code> / <code>transition</code> / <code>list-style</code> 等</li>
</ul>
<p>另外，如果包含 <code>content</code> 属性，应放在最前面。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="comment">/* formatting model: positioning schemes / offsets / z-indexes / display / ...  */</span></span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">overflow-x</span>: hidden;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* box model: sizes / margins / paddings / borders / ...  */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* typographic: font / aligns / text styles / ... */</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* visual: colors / shadows / gradients / ... */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">-webkit-transition</span>: color <span class="number">1s</span>;</span><br><span class="line">       <span class="attribute">-moz-transition</span>: color <span class="number">1s</span>;</span><br><span class="line">            <span class="attribute">transition</span>: color <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-清除浮动"><a href="#3-4-清除浮动" class="headerlink" title="3.4 清除浮动"></a>3.4 清除浮动</h3><p> <strong>[建议]</strong> 当元素需要撑起高度以包含内部的浮动元素时，通过对伪类设置 <code>clear</code> 或触发 <code>BFC</code> 的方式进行 <code>clearfix</code>。尽量不使用增加空标签的方式。</p>
<p>解释：</p>
<p>触发 BFC 的方式很多，常见的有：</p>
<ul>
<li>float 非 none</li>
<li>position 非 static</li>
<li>overflow 非 visible</li>
</ul>
<p>如希望使用更小副作用的清除浮动方法，参见 <a href="http://nicolasgallagher.com/micro-clearfix-hack/" target="_blank" rel="noopener">A new micro clearfix hack</a> 一文。</p>
<p>另需注意，对已经触发 BFC 的元素不需要再进行 clearfix。</p>
<h3 id="3-5-important"><a href="#3-5-important" class="headerlink" title="3.5 !important"></a>3.5 !important</h3><p> <strong>[建议]</strong> 尽量不使用 <code>!important</code> 声明。</p>
<p> <strong>[建议]</strong> 当需要强制指定样式且不允许任何场景覆盖时，通过标签内联和 <code>!important</code> 定义样式。</p>
<p>解释：</p>
<p>必须注意的是，仅在设计上 <code>确实不允许任何其它场景覆盖样式</code> 时，才使用内联的 <code>!important</code> 样式。通常在第三方环境的应用中使用这种方案。下面的 z-index 章节是其中一个特殊场景的典型样例。</p>
<h3 id="3-6-z-index"><a href="#3-6-z-index" class="headerlink" title="3.6 z-index"></a>3.6 z-index</h3><p> <strong>[建议]</strong> 将 <code>z-index</code> 进行分层，对文档流外绝对定位元素的视觉层级关系进行管理。</p>
<p>解释：</p>
<p>同层的多个元素，如多个由用户输入触发的 Dialog，在该层级内使用相同的 <code>z-index</code> 或递增 <code>z-index</code>。</p>
<p>建议每层包含100个 <code>z-index</code> 来容纳足够的元素，如果每层元素较多，可以调整这个数值。</p>
<p> <strong>[建议]</strong> 在可控环境下，期望显示在最上层的元素，<code>z-index</code> 指定为 <code>999999</code>。</p>
<p>解释：</p>
<p>可控环境分成两种，一种是自身产品线环境；还有一种是可能会被其他产品线引用，但是不会被外部第三方的产品引用。</p>
<p>不建议取值为 <code>2147483647</code>。以便于自身产品线被其他产品线引用时，当遇到层级覆盖冲突的情况，留出向上调整的空间。</p>
<p> <strong>[建议]</strong> 在第三方环境下，期望显示在最上层的元素，通过标签内联和 <code>!important</code>，将 <code>z-index</code> 指定为 <code>2147483647</code>。</p>
<p>解释：</p>
<p>第三方环境对于开发者来说完全不可控。在第三方环境下的元素，为了保证元素不被其页面其他样式定义覆盖，需要采用此做法。</p>
<h2 id="4-值与单位"><a href="#4-值与单位" class="headerlink" title="4 值与单位"></a>4 值与单位</h2><h3 id="4-1-文本"><a href="#4-1-文本" class="headerlink" title="4.1 文本"></a>4.1 文本</h3><p> <strong>[强制]</strong> 文本内容必须用双引号包围。</p>
<p>解释：</p>
<p>文本类型的内容可能在选择器、属性值等内容中。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">html</span><span class="selector-attr">[lang|="zh"]</span> <span class="selector-tag">q</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">"Microsoft YaHei"</span>, sans-serif;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">"“"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">html</span><span class="selector-attr">[lang|="zh"]</span> <span class="selector-tag">q</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">"Microsoft YaHei"</span>, sans-serif;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">"”"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">html</span><span class="selector-attr">[lang|=zh]</span> <span class="selector-tag">q</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">'Microsoft YaHei'</span>, sans-serif;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">'“'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">html</span><span class="selector-attr">[lang|=zh]</span> <span class="selector-tag">q</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">"Microsoft YaHei"</span>, sans-serif;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">"”"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-数值"><a href="#4-2-数值" class="headerlink" title="4.2 数值"></a>4.2 数值</h3><p> <strong>[强制]</strong> 当数值为 0 - 1 之间的小数时，省略整数部分的 <code>0</code>。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">panel</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: .<span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">panel</span> &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-url"><a href="#4-3-url" class="headerlink" title="4.3 url()"></a>4.3 url()</h3><p> <strong>[强制]</strong> <code>url()</code> 函数中的路径不加引号。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(bg.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>[建议]</strong> <code>url()</code> 函数中的绝对路径可省去协议名。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(//baidu.com/img/bg.png) no-repeat <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-长度"><a href="#4-4-长度" class="headerlink" title="4.4 长度"></a>4.4 长度</h3><p> <strong>[强制]</strong> 长度为 <code>0</code> 时须省略单位。 (也只有长度单位可省)</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-颜色"><a href="#4-5-颜色" class="headerlink" title="4.5 颜色"></a>4.5 颜色</h3><p> <strong>[强制]</strong> RGB颜色值必须使用十六进制记号形式 <code>#rrggbb</code>。不允许使用 <code>rgb()</code>。 </p>
<p>解释：</p>
<p>带有alpha的颜色信息可以使用 <code>rgba()</code>。使用 <code>rgba()</code> 时每个逗号后必须保留一个空格。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">2px</span> <span class="built_in">rgba</span>(0, 128, 0, .3);</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#008000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">2px</span> <span class="built_in">rgba</span>(0,128,0,.3);</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgb</span>(0, 128, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>[强制]</strong> 颜色值可以缩写时，必须使用缩写形式。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#aca</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#aaccaa</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>[强制]</strong> 颜色值不允许使用命名色值。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#90ee90</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>[建议]</strong> 颜色值中的英文字符采用小写。如不用小写也需要保证同一项目内保持大小写一致。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#aca</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#90ee90</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ACA</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#90EE90</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-class">.success</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ACA</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#90ee90</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-6-2D-位置"><a href="#4-6-2D-位置" class="headerlink" title="4.6 2D 位置"></a>4.6 2D 位置</h3><p> <strong>[强制]</strong> 必须同时给出水平和垂直方向的位置。</p>
<p>解释：</p>
<p>2D 位置初始值为 <code>0% 0%</code>，但在只有一个方向的值时，另一个方向的值会被解析为 center。为避免理解上的困扰，应同时给出两个方向的值。<a href="http://www.w3.org/TR/CSS21/colors.html#propdef-background-position" target="_blank" rel="noopener">background-position属性值的定义</a></p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-position</span>: center top; <span class="comment">/* 50% 0% */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-position</span>: top; <span class="comment">/* 50% 0% */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-文本编排"><a href="#5-文本编排" class="headerlink" title="5 文本编排"></a>5 文本编排</h2><h3 id="5-1-字体族"><a href="#5-1-字体族" class="headerlink" title="5.1 字体族"></a>5.1 字体族</h3><p> <strong>[强制]</strong> <code>font-family</code> 属性中的字体族名称应使用字体的英文 <code>Family Name</code>，其中如有空格，须放置在引号中。</p>
<p>解释：</p>
<p>所谓英文 Family Name，为字体文件的一个元数据，常见名称如下：</p>
<table>
<thead>
<tr>
<th>字体</th>
<th>操作系统</th>
<th>Family Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>宋体 (中易宋体)</td>
<td>Windows</td>
<td>SimSun</td>
</tr>
<tr>
<td>黑体 (中易黑体)</td>
<td>Windows</td>
<td>SimHei</td>
</tr>
<tr>
<td>微软雅黑</td>
<td>Windows</td>
<td>Microsoft YaHei</td>
</tr>
<tr>
<td>微软正黑</td>
<td>Windows</td>
<td>Microsoft JhengHei</td>
</tr>
<tr>
<td>华文黑体</td>
<td>Mac/iOS</td>
<td>STHeiti</td>
</tr>
<tr>
<td>冬青黑体</td>
<td>Mac/iOS</td>
<td>Hiragino Sans GB</td>
</tr>
<tr>
<td>文泉驿正黑</td>
<td>Linux</td>
<td>WenQuanYi Zen Hei</td>
</tr>
<tr>
<td>文泉驿微米黑</td>
<td>Linux</td>
<td>WenQuanYi Micro Hei</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">"Microsoft YaHei"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>[强制]</strong> <code>font-family</code> 按「西文字体在前、中文字体在后」、「效果佳 (质量高/更能满足需求) 的字体在前、效果一般的字体在后」的顺序编写，最后必须指定一个通用字体族( <code>serif</code> / <code>sans-serif</code> )。</p>
<p>解释：</p>
<p>更详细说明可参考<a href="http://www.zhihu.com/question/19911793/answer/13329819" target="_blank" rel="noopener">本文</a>。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Display according to platform */</span></span><br><span class="line"><span class="selector-class">.article</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Arial, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Specific for most platforms */</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">"Helvetica Neue"</span>, Arial, <span class="string">"Hiragino Sans GB"</span>, <span class="string">"WenQuanYi Micro Hei"</span>, <span class="string">"Microsoft YaHei"</span>, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>[强制]</strong> <code>font-family</code> 不区分大小写，但在同一个项目中，同样的 <code>Family Name</code> 大小写必须统一。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Arial, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Arial, <span class="string">"Microsoft YaHei"</span>, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: arial, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: Arial, <span class="string">"Microsoft YaHei"</span>, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-字号"><a href="#5-2-字号" class="headerlink" title="5.2 字号"></a>5.2 字号</h3><p> <strong>[强制]</strong> 需要在 Windows 平台显示的中文内容，其字号应不小于 <code>12px</code>。</p>
<p>解释：</p>
<p>由于 Windows 的字体渲染机制，小于 12px 的文字显示效果极差、难以辨认。</p>
<h3 id="5-3-字体风格"><a href="#5-3-字体风格" class="headerlink" title="5.3 字体风格"></a>5.3 字体风格</h3><p> <strong>[建议]</strong> 需要在 Windows 平台显示的中文内容，不要使用除 <code>normal</code> 外的 <code>font-style</code>。其他平台也应慎用。</p>
<p>解释：</p>
<p>由于中文字体没有 italic 风格的实现，所有浏览器下都会 fallback 到 obilique 实现 (自动拟合为斜体)，小字号下 (特别是 Windows 下会在小字号下使用点阵字体的情况下) 显示效果差，造成阅读困难。</p>
<h3 id="5-4-字重"><a href="#5-4-字重" class="headerlink" title="5.4 字重"></a>5.4 字重</h3><p> <strong>[强制]</strong> <code>font-weight</code> 属性必须使用数值方式描述。</p>
<p>解释：</p>
<p>CSS 的字重分 100 – 900 共九档，但目前受字体本身质量和浏览器的限制，实际上支持 400 和 700 两档，分别等价于关键词 normal 和 bold。</p>
<p>浏览器本身使用一系列<a href="http://www.w3.org/TR/CSS21/fonts.html#propdef-font-weight" target="_blank" rel="noopener">启发式规则</a>来进行匹配，在 &lt;700 时一般匹配字体的 Regular 字重，=700 时匹配 Bold 字重。</p>
<p>但已有浏览器开始支持 =600 时匹配 Semibold 字重 (见<a href="http://justineo.github.io/slideshows/font/#/3/15" target="_blank" rel="noopener">此表</a>)，故使用数值描述增加了灵活性，也更简短。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-5-行高"><a href="#5-5-行高" class="headerlink" title="5.5 行高"></a>5.5 行高</h3><p> <strong>[建议]</strong> <code>line-height</code> 在定义文本段落时，应使用数值。</p>
<p>解释：</p>
<p>将 line-height 设置为数值，浏览器会基于当前元素设置的 font-size 进行再次计算。在不同字号的文本段落组合中，能达到较为舒适的行间间隔效果，避免在每个设置了 font-size 都需要设置 line-height。</p>
<p>当 line-height 用于控制垂直居中时，还是应该设置成与容器高度一致。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-变换与动画"><a href="#6-变换与动画" class="headerlink" title="6 变换与动画"></a>6 变换与动画</h2><p> <strong>[强制]</strong> 使用 <code>transition</code> 时应指定 <code>transition-property</code>。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">transition</span>: color <span class="number">1s</span>, border-color <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>[建议]</strong> 尽可能在浏览器能高效实现的属性上添加过渡和动画。</p>
<p>解释：</p>
<p>见<a href="http://www.html5rocks.com/en/tutorials/speed/high-performance-animations/" target="_blank" rel="noopener">本文</a>，在可能的情况下应选择这样四种变换：</p>
<ul>
<li><code>transform: translate(npx, npx);</code></li>
<li><code>transform: scale(n);</code></li>
<li><code>transform: rotate(ndeg);</code></li>
<li><code>opacity: 0..1;</code></li>
</ul>
<p>典型的，可以使用 translate 来代替 left 作为动画属性。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">transition</span>: transform <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(20px); <span class="comment">/* move right for 20px */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transition</span>: left <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">20px</span>; <span class="comment">/* move right for 20px */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-响应式"><a href="#7-响应式" class="headerlink" title="7 响应式"></a>7 响应式</h2><p><strong>[强制]</strong> <code>Media Query</code> 不得单独编排，必须与相关的规则一起定义。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Good */</span></span><br><span class="line"><span class="comment">/* header styles */</span></span><br><span class="line">@<span class="keyword">media</span> (...) &#123;</span><br><span class="line">    <span class="comment">/* header styles */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* main styles */</span></span><br><span class="line">@<span class="keyword">media</span> (...) &#123;</span><br><span class="line">    <span class="comment">/* main styles */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* footer styles */</span></span><br><span class="line">@<span class="keyword">media</span> (...) &#123;</span><br><span class="line">    <span class="comment">/* footer styles */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bad */</span></span><br><span class="line"><span class="comment">/* header styles */</span></span><br><span class="line"><span class="comment">/* main styles */</span></span><br><span class="line"><span class="comment">/* footer styles */</span></span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> (...) &#123;</span><br><span class="line">    <span class="comment">/* header styles */</span></span><br><span class="line">    <span class="comment">/* main styles */</span></span><br><span class="line">    <span class="comment">/* footer styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>[强制]</strong> <code>Media Query</code> 如果有多个逗号分隔的条件时，应将每个条件放在单独一行中。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span></span><br><span class="line">(-webkit-min-device-pixel-ratio: 2), /* Webkit-based browsers */</span><br><span class="line">(<span class="selector-tag">min--moz-device-pixel-ratio</span>: 2),    <span class="comment">/* Older Firefox browsers (prior to Firefox 16) */</span></span><br><span class="line">(<span class="selector-tag">min-resolution</span>: 2<span class="selector-tag">dppx</span>),             <span class="comment">/* The standard way */</span></span><br><span class="line">(<span class="selector-tag">min-resolution</span>: 192<span class="selector-tag">dpi</span>) &#123;           <span class="comment">/* dppx fallback */</span></span><br><span class="line">    <span class="comment">/* Retina-specific stuff here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>[建议]</strong> 尽可能给出在高分辨率设备 (Retina) 下效果更佳的样式。</p>
<h2 id="8-兼容性"><a href="#8-兼容性" class="headerlink" title="8 兼容性"></a>8 兼容性</h2><h3 id="8-1-属性前缀"><a href="#8-1-属性前缀" class="headerlink" title="8.1 属性前缀"></a>8.1 属性前缀</h3><p> <strong>[强制]</strong> 带私有前缀的属性由长到短排列，按冒号位置对齐。</p>
<p>解释：</p>
<p>标准属性放在最后，按冒号对齐方便阅读，也便于在编辑器内进行多行编辑。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-box-sizing</span>: border-box;</span><br><span class="line">       <span class="attribute">-moz-box-sizing</span>: border-box;</span><br><span class="line">            <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-Hack"><a href="#8-2-Hack" class="headerlink" title="8.2 Hack"></a>8.2 Hack</h3><p> <strong>[建议]</strong> 需要添加 <code>hack</code> 时应尽可能考虑是否可以采用其他方式解决。</p>
<p>解释：</p>
<p>如果能通过合理的 HTML 结构或使用其他的 CSS 定义达到理想的样式，则不应该使用 hack 手段解决问题。通常 hack 会导致维护成本的增加。</p>
<p> <strong>[建议]</strong> 尽量使用 <code>选择器 hack</code> 处理兼容性，而非 <code>属性 hack</code>。</p>
<p>解释：</p>
<p>尽量使用符合 CSS 语法的 selector hack，可以避免一些第三方库无法识别 hack 语法的问题。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* IE 7 */</span></span><br><span class="line">*<span class="selector-pseudo">:first-child</span> + <span class="selector-tag">html</span> <span class="selector-id">#header</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IE 6 */</span></span><br><span class="line">* <span class="selector-tag">html</span> <span class="selector-id">#header</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>[建议]</strong> 尽量使用简单的 <code>属性 hack</code>。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">_display</span>: inline; <span class="comment">/* fix double margin */</span></span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    *zoom: 1; /* triggering hasLayout */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-Expression"><a href="#8-3-Expression" class="headerlink" title="8.3 Expression"></a>8.3 Expression</h3><p> <strong>[强制]</strong> 禁止使用 <code>Expression</code>。</p>
<hr>
<p>参考资料: <a href="https://github.com/fex-team/styleguide/blob/master/css.md" target="_blank" rel="noopener">css编码规范</a></p>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
  </entry>
  <entry>
    <title>开发过程中应该遵守哪些编码规范和class命名规范？</title>
    <url>/2019/10/10/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%8312-14/%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%BA%94%E8%AF%A5%E9%81%B5%E5%AE%88%E5%93%AA%E4%BA%9B%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E5%92%8Cclass%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%EF%BC%9F/</url>
    <content><![CDATA[<p>真正阅读程序的是人，而不是计算机，所以所写代码具有良好的可读性，是优秀程序员必备的素质之一。在大型的系统开发中，往往需要很多人的通力配合，例如，开源软件Linux 之所以能够为全球顶尖程序员共享、协作开发，也得益于规范化和标准化的编码规范。规范应该尽量一致；即使有例外，也只能是少数情况，而不能是很多例外。好的代码规范能够提高代码的可读性便于协作沟通，好的模式能够在上层设计上避免不必要的 bug 出现。 </p><a id="more"></a>
<h1 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h1><h2 id="HTML规范"><a href="#HTML规范" class="headerlink" title="HTML规范"></a>HTML规范</h2><p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g7tjm466ilj30qv0cj74i.jpg" alt="html规范1.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g7tjmyv3lgj311m0n175l.jpg" alt="html规范2.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g7tjnbe90ij315b0mxta4.jpg" alt="html规范3.png"> </p>
<p>参考资料:<a href="http://lesson.jnshu.com/l/subjectContent/1087/?id=&amp;lobtn=2" target="_blank" rel="noopener">开发过程中应该遵守哪些编码规范和class命名规范？ </a></p>
<h2 id="CSS规范"><a href="#CSS规范" class="headerlink" title="CSS规范"></a>CSS规范</h2><p>css规范目录如下,<a href="https://github.com/fex-team/styleguide/blob/master/css.md" target="_blank" rel="noopener">详细内容点击查看</a></p>
<p>1 前言</p>
<p>2 代码风格</p>
<p>　　2.1 文件</p>
<p>　　2.2 缩进</p>
<p>　　2.3 空格</p>
<p>　　2.4 行长度</p>
<p>　　2.5 选择器</p>
<p>　　2.6 属性</p>
<p>3 通用</p>
<p>　　3.1 选择器</p>
<p>　　3.2 属性缩写</p>
<p>　　3.3 属性书写顺序</p>
<p>　　3.4 清除浮动</p>
<p>　　3.5 !important</p>
<p>　　3.6 z-index</p>
<p>4 值与单位</p>
<p>　　4.1 文本</p>
<p>　　4.2 数值</p>
<p>　　4.3 url()</p>
<p>　　4.4 长度</p>
<p>　　4.5 颜色</p>
<p>　　4.6 2D 位置</p>
<p>5 文本编排</p>
<p>　　5.1 字体族</p>
<p>　　5.2 字号</p>
<p>　　5.3 字体风格</p>
<p>　　5.4 字重</p>
<p>　　5.5 行高</p>
<p>6 变换与动画</p>
<p>7 响应式</p>
<p>8 兼容性</p>
<p>　　8.1 属性前缀</p>
<p>　　8.2 Hack</p>
<p>　　8.3 Expression</p>
<p>#class命名规范</p>
<h2 id="class命名的常用方式"><a href="#class命名的常用方式" class="headerlink" title="class命名的常用方式"></a>class命名的常用方式</h2><h3 id="原子类命名规则"><a href="#原子类命名规则" class="headerlink" title="原子类命名规则"></a>原子类命名规则</h3><p>将复用性高的单条属性直接命名成类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.ml5&#123;margin-left:5px;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模块命名规则"><a href="#模块命名规则" class="headerlink" title="模块命名规则"></a>模块命名规则</h3><p>按照职能划分命名规则</p>
<p>例如，模块是nav，便可以命名nav-tittle、nav-left</p>
<h3 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h3><p>BEM思想是由于项目开发中，每个组件都是唯一无二的，其名字也是独一无二的，组件内部元素的名字都加上组件名，并用元素的名字作为选择器，自然组件内的样式就不会与组件外的样式冲突了。这是通过组件名的唯一性来保证选择器的唯一性，从而保证样式不会污染到组件外。</p>
<p>BEM的命名规矩很容易记：block-name__element-name–modifier-name，也就是模块名+元素名+修饰器名</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、规则命名中，一律采用小写加中划线的方式，不允许使用大写字母或_</p>
<p>2、命名避免使用中文拼音，应该采用更简明有语义的英文单词进行组合</p>
<p>3、不允许通过1、2、3等序号进行命名；避免class与id重名</p>
<p>4、class用于标识某一个类型的对象，命名必须言简意赅</p>
<p>5、尽可能提高代码模块的复用，样式尽量用组合的方式</p>
<p>6、规则名称中不应该包含颜色（red/blue）、定位（left/right）等与具体显示效果相关的信息。应该用意义命名，而不是样式显示结果命名</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何使用gulp编辑(编译)less？</title>
    <url>/2019/10/10/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%8311/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8gulp%E7%BC%96%E8%BE%91less%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="什么是gulp"><a href="#什么是gulp" class="headerlink" title="什么是gulp"></a>什么是gulp</h1><p>gulp是自动化构建工具,构建工具可以使繁琐的工作简单化，提高开发人员的工作效率，对于前端开发开发人员来说，我们通常用gulp来合并文件，压缩文件，编译less和sass文件等。 </p><h1 id="安装gulp"><a href="#安装gulp" class="headerlink" title="安装gulp"></a>安装gulp</h1><p>gulp 是基于 node 实现的，那么我们就需要先安装 node。 </p><p>打开 <a href="https://nodejs.org/" target="_blank" rel="noopener">https://nodejs.org/</a> 点击绿色的 <strong>INSTALL</strong> 按钮下载安装 node。 </p><a id="more"></a>


<p>npm 是 node 的包管理工具，可以利用它安装 gulp 所需的包。（在安装 node 时已经自动安装了 npm）</p>
<p>在命令行输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g gulp</span><br></pre></td></tr></table></figure>
<p>若一直没安装成功，请<a href="https://github.com/nimojs/blog/issues/20" target="_blank" rel="noopener">使用 cnpm 安装</a>(npm的国内加速镜像)</p>
<p>意思是：使用 npm 安装全局性的(<code>-g</code>) gulp 包。</p>
<blockquote>
<p>如果你安装失败，请输入<code>sudo npm install -g gulp</code>使用管理员权限安装。（可能会要求输入密码）</p>
</blockquote>
<p>安装时请注意命令行的提示信息，安装完成后可在命令行输入 <code>gulp -v</code> 以确认安装成功。</p>
<h1 id="如何使用gulp编译less"><a href="#如何使用gulp编译less" class="headerlink" title="如何使用gulp编译less"></a>如何使用gulp编译less</h1><p>你可以 <a href="https://github.com/nimojs/gulp-book/archive/master.zip" target="_blank" rel="noopener">下载所有示例代码</a> - <a href="https://github.com/nimojs/gulp-book/tree/master/demo/chapter5" target="_blank" rel="noopener">或在线查看代码</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获取 gulp</span><br><span class="line">var gulp = require(&apos;gulp&apos;)</span><br><span class="line">// 获取 gulp-less 模块</span><br><span class="line">var less = require(&apos;gulp-less&apos;)</span><br><span class="line"></span><br><span class="line">// 编译less</span><br><span class="line">// 在命令行输入 gulp images 启动此任务</span><br><span class="line">gulp.task(&apos;less&apos;, function () &#123;</span><br><span class="line">    // 1. 找到 less 文件</span><br><span class="line">    gulp.src(&apos;less/**.less&apos;)</span><br><span class="line">    // 2. 编译为css</span><br><span class="line">        .pipe(less())</span><br><span class="line">    // 3. 另存文件</span><br><span class="line">        .pipe(gulp.dest(&apos;dist/css&apos;))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 在命令行使用 gulp auto 启动此任务</span><br><span class="line">gulp.task(&apos;auto&apos;, function () &#123;</span><br><span class="line">    // 监听文件修改，当文件被修改则执行 images 任务</span><br><span class="line">    gulp.watch(&apos;less/**.less&apos;, [&apos;less&apos;])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 使用 gulp.task(&apos;default&apos;) 定义默认任务</span><br><span class="line">// 在命令行使用 gulp 启动 less 任务和 auto 任务</span><br><span class="line">gulp.task(&apos;default&apos;, [&apos;less&apos;, &apos;auto&apos;])</span><br></pre></td></tr></table></figure>
<p>你可以访问 <a href="https://github.com/plus3network/gulp-less" target="_blank" rel="noopener">gulp-less</a> 以查看更多用法。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.kancloud.cn/thinkphp/gulp-guide/43994" target="_blank" rel="noopener">gulp入门指南</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>less和sass有什么区别？</title>
    <url>/2019/10/10/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%8311/less%E5%92%8Csass%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="1-编译环境不一样"><a href="#1-编译环境不一样" class="headerlink" title="1.编译环境不一样"></a>1.编译环境不一样</h1><p>Sass的安装需要Ruby环境，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译成css文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。 </p><a id="more"></a>
<h1 id="2-变量符不一样"><a href="#2-变量符不一样" class="headerlink" title="2.变量符不一样"></a>2.变量符不一样</h1><p>Less是@，而Scss是$，而且变量的作用域也不一样。 </p>
<h1 id="3-输出设置"><a href="#3-输出设置" class="headerlink" title="3.输出设置"></a>3.输出设置</h1><p>Less没有输出设置，Sass提供4中输出选项：nested, compact, compressed 和 expanded。<br>输出样式的风格可以有四种选择，默认为nested<br>nested：嵌套缩进的css代码<br>expanded：展开的多行css代码<br>compact：简洁格式的css代码<br>compressed：压缩后的css代码 </p>
<h1 id="4-条件语句"><a href="#4-条件语句" class="headerlink" title="4.条件语句"></a>4.条件语句</h1><p>Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持。</p>
<h1 id="5-引用外部CSS文件"><a href="#5-引用外部CSS文件" class="headerlink" title="5.引用外部CSS文件"></a>5.引用外部CSS文件</h1><p>引用外部CSS文件 scss引用的外部文件命名必须以_开头, 如下例所示:其中_test1.scss,test2.scss、<em>test3.scss文件分别设置的h1 h2 h3。文件名如果以下划线</em>开头的话，Sass会认为该文件是一个引用文件，不会将其编译为css文件. </p>
<h1 id="6-工具库的不同"><a href="#6-工具库的不同" class="headerlink" title="6.工具库的不同"></a>6.工具库的不同</h1><p>Sass和Less的工具库不同 .</p>
<p>Sass有工具库Compass, 简单说，Sass和Compass的关系有点像Javascript和jQuery的关系,Compass是Sass的工具库。在它的基础上，封装了一系列有用的模块和模板，补充强化了Sass的功能。 </p>
<p>Less有UI组件库Bootstrap,Bootstrap是web前端开发中一个比较有名的前端UI组件库，Bootstrap的样式文件部分源码就是采用Less语法编写。</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何使用sass?</title>
    <url>/2019/10/10/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%8311/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8sass/</url>
    <content><![CDATA[<h1 id="什么是sass"><a href="#什么是sass" class="headerlink" title="什么是sass"></a>什么是sass</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Sass 是一门高于 CSS 的元语言，它能用来清晰地、结构化地描述文件样式，有着比普通 CSS 更加强大的功能。<br>Sass 能够提供更简洁、更优雅的语法，同时提供多种功能来创建可维护和管理的样式表。 </p><h2 id="sass和scss有什么区别？"><a href="#sass和scss有什么区别？" class="headerlink" title="sass和scss有什么区别？"></a>sass和scss有什么区别？</h2><p>Sass 和 SCSS 其实是同一种东西，我们平时都称之为 Sass，两者之间不同之处有以下两点：<br>文件扩展名不同，Sass 是以“.sass”后缀为扩展名，而 SCSS 是以“.scss”后缀为扩展名<br>语法书写方式不同，Sass 是以严格的缩进式语法规则来书写，不带大括号({})和分号(;)，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。</p><a id="more"></a>

<h1 id="安装sass"><a href="#安装sass" class="headerlink" title="安装sass"></a>安装sass</h1><p>1.安装环境ruby<br>2.打开的Ruby 的 Command 控制面板命令终端，输入下面的命令：<br>gem install sass</p>
<h1 id="sass转译"><a href="#sass转译" class="headerlink" title="sass转译"></a>sass转译</h1><p>因为 Sass 开发之后，要让 Web 页面能调用 Sass 写好的东西，就得有这么一个过程，这个过程就称之为 Sass 编译过程。Sass 的编译有多种方法：</p>
<ul>
<li>命令编译</li>
<li>工具编译 eg：koala</li>
<li>使用webstorm关联scss自动转译<br>1.找到setting下的tools（工具），tools下有一个file watchers，找到并点击。<br>2.点击右侧工具栏中的“+”按钮，添加所需要监控的文件类型<br>3.进行相关设置</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>具体语法及使用见sass中文文档</p>
<p><a href="https://www.sasscss.com/docs/" target="_blank" rel="noopener">sass中文文档</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何使用less?</title>
    <url>/2019/10/10/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%8311/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8less/</url>
    <content><![CDATA[<h1 id="什么是less"><a href="#什么是less" class="headerlink" title="什么是less"></a>什么是less</h1><p>less是一门动态的css语言，使得css样式更加灵活地作用于html标签。</p><p>less作为css的一种形式扩展，它并没有减少css的功能，而是在现有的css语法上，为css加入了程序是式语言的特性。less包含一套自定义的语法及一个解析器， 用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的css文件。</p><a id="more"></a>

<h1 id="为什么使用less"><a href="#为什么使用less" class="headerlink" title="为什么使用less"></a>为什么使用less</h1><p>css是一门非程序式语言，没有变量，没有函数，SCOPE（作用域），需要书写大量看似没有逻辑的代码，即不方便维护与扩展，也不利于复用。 为了方便前端开发的工作量，出现了sass和less. </p>
<h1 id="如何使用less"><a href="#如何使用less" class="headerlink" title="如何使用less"></a>如何使用less</h1><h2 id="在-Node-js-环境中使用-Less"><a href="#在-Node-js-环境中使用-Less" class="headerlink" title="在 Node.js 环境中使用 Less"></a>在 Node.js 环境中使用 Less</h2><p><code>npm install -g less</code> <code>&gt; lessc styles.less styles.css</code> </p>
<h2 id="在浏览器环境中使用-Less"><a href="#在浏览器环境中使用-Less" class="headerlink" title="在浏览器环境中使用 Less"></a>在浏览器环境中使用 Less</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;styles.less&quot; /&gt;</span><br><span class="line">&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/less.js/3.10.0-beta/less.min.js&quot; &gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>less样式文件一定要在引入less.js前先引入。 </p>
<p>备注：请在服务器环境下使用！本地直接打开可能会报错！  </p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul>
<li>命令编译</li>
<li>工具编译 eg：koala</li>
<li>使用webstorm关联less自动转译 </li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://less.bootcss.com/" target="_blank" rel="noopener">less快速入门</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>自适应小屏幕设备时，该如何布局？</title>
    <url>/2019/10/10/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%8310/%E8%87%AA%E9%80%82%E5%BA%94%E5%B0%8F%E5%B1%8F%E5%B9%95%E8%AE%BE%E5%A4%87%E6%97%B6%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E5%B8%83%E5%B1%80%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="什么时自适应网页设计"><a href="#什么时自适应网页设计" class="headerlink" title="什么时自适应网页设计"></a>什么时自适应网页设计</h1><p>页面能适配众多不同的终端设备，让同一张网页自动适应不同大小的屏幕，根据屏幕宽度，自动调整布局.</p><p>2010年，Ethan Marcotte提出了”自适应网页设计”（Responsive Web Design）这个名词，指可以自动识别屏幕宽度、并做出相应调整的网页设计。响应式网页设计是自适应网页设计的子集。响应式网页设计指的是页面的布局（流动网格、灵活的图像及媒介查询）。总体目标就是去解决设备多样化问题。响应式布局等于流动网格布局，而自适应布局等于使用固定分割点来进行布局。当固定宽度与流动宽度结合起来时，自适应布局就是一种响应式设计，而不仅仅是它的一种替代方法。</p><a id="more"></a>

<h1 id="如何进行自适应网页设计"><a href="#如何进行自适应网页设计" class="headerlink" title="如何进行自适应网页设计"></a>如何进行自适应网页设计</h1><p>1.学会运用 css3 Media Queries，根据不同的屏幕分辨率，选择应用不同的css规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@media screen and (max-width:400px)&#123;</span><br><span class="line"></span><br><span class="line">    .class &#123;</span><br><span class="line"></span><br><span class="line">         background:#ccc;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>2.在网页头部加上viewport标签</p>
<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code></p>
<p>该属性可以控制视窗口宽度的大小。它可以被设置为实际的具体像素width= 600或为特殊设备设置宽度值。 viewport设置属性如下：</p>
<p>width：可设定数值，或者指定为 device-width</p>
<p>height：可设定数值，或者指定為 device-height</p>
<p>initial-scale：第一次进入页面的初始比例</p>
<p>minimum-scale：允许缩小最小比例</p>
<p>maximum-scale：允许放大最大比例</p>
<p>user-scalable：允许使用者缩放，1 or 0 (yes or no)</p>
<p>3.不使用绝对宽度</p>
<p>4.字体最好不要用绝对大小(px)，而使用相对大小(em)</p>
<p>5.流动布局（fluid grid）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.main &#123; float: rightright; width: 70%; &#125;</span><br><span class="line"></span><br><span class="line">.leftBar &#123; float: left; width: 25%; &#125;</span><br></pre></td></tr></table></figure>
<p>6 图片的自动缩放，等比缩放</p>
<p><code>img{ max-width: 100%; }</code></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何改变默认radio和select的样式？</title>
    <url>/2019/10/10/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%8310/%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98%E9%BB%98%E8%AE%A4radio%E5%92%8Cselect%E7%9A%84%E6%A0%B7%E5%BC%8F%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="改变默认radio样式"><a href="#改变默认radio样式" class="headerlink" title="改变默认radio样式"></a>改变默认radio样式</h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>step1.可以为<code>&lt;label&gt;</code>元素添加生成性内容(伪元素)，并基于单选按钮的状态来为其设置样式；<br>step2. 然后把真正的单选按钮隐藏起来；<br>step3. 最后把生成内容美化一下。</p><h2 id="编码实战"><a href="#编码实战" class="headerlink" title="编码实战"></a>编码实战</h2><p>1、可以为<code>&lt;label&gt;</code>元素添加生成性内容(伪元素)，并基于单选按钮的状态来为其设置样式；<br>为label设置样式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">label::before&#123;</span><br><span class="line">display: inline-block;</span><br><span class="line">content: &quot;&quot;;</span><br><span class="line">width: 10rem;</span><br><span class="line">height: 10rem;</span><br><span class="line">border: 10px solid #d7d7d7;</span><br><span class="line">border-radius: 50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a>

<ol start="2">
<li><p>然后把真正的单选按钮隐藏起来；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input[type=&quot;radio&quot;] &#123; position: absolute; clip: rect(0, 0, 0, 0); &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后把生成内容美化一下。<br>为label选中时设置样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input[type=&quot;radio&quot;]:checked + label::before &#123; background-color: #01cd78; background-clip: content-box; padding: .2em; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="改变默认select样式"><a href="#改变默认select样式" class="headerlink" title="改变默认select样式"></a>改变默认select样式</h1><h2 id="HTML代码"><a href="#HTML代码" class="headerlink" title="HTML代码"></a>HTML代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt; &lt;select name=&quot;&quot;&gt; &lt;option value=&quot;芝士&quot;&gt;芝士&lt;/option&gt; &lt;option value=&quot;奶油&quot;&gt;奶油&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>给select添加父元素div目的是为了，用div的样式覆盖住select样式。</p>
<h2 id="CSS代码"><a href="#CSS代码" class="headerlink" title="CSS代码"></a>CSS代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">                //用div的样式代替select的样式</span><br><span class="line">                width: 200px;</span><br><span class="line">                height: 40px;</span><br><span class="line">                border-radius: 5px;</span><br><span class="line">                //盒子阴影修饰作用,自己随意</span><br><span class="line">                box-shadow: 0 0 5px #ccc;</span><br><span class="line">                position: relative;</span><br><span class="line">            &#125;</span><br><span class="line">            select&#123;</span><br><span class="line">                //清除select的边框样式</span><br><span class="line">                border: none;</span><br><span class="line">                //清除select聚焦时候的边框颜色</span><br><span class="line">                outline: none;</span><br><span class="line">                //将select的宽高等于div的宽高</span><br><span class="line">                width: 100%;</span><br><span class="line">                height: 40px;</span><br><span class="line">                line-height: 40px;</span><br><span class="line">                //隐藏select的下拉图标</span><br><span class="line">                appearance: none;</span><br><span class="line">                -webkit-appearance: none;</span><br><span class="line">                -moz-appearance: none;</span><br><span class="line">                //通过padding-left的值让文字居中</span><br><span class="line">                padding-left: 60px;</span><br><span class="line">            &#125;</span><br><span class="line">            //使用伪类给select添加自己想用的图标</span><br><span class="line">            div:after&#123;</span><br><span class="line">                content: &quot;&quot;;</span><br><span class="line">                width: 14px;</span><br><span class="line">                height: 8px;</span><br><span class="line">                background: url(img/xiala.png) no-repeat center;</span><br><span class="line">                //通过定位将图标放在合适的位置</span><br><span class="line">                position: absolute;</span><br><span class="line">                right: 20px;</span><br><span class="line">                top: 45%;</span><br><span class="line">                //给自定义的图标实现点击下来功能</span><br><span class="line">                pointer-events: none;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>媒体查询如何使用？</title>
    <url>/2019/10/10/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%839/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h1><p>媒体查询是非常别致的”有条件的 CSS 规则”。它只适用于一些基于某些规定条件的 CSS。如果满足那些条件，则应用相应的样式。 </p><h1 id="为什么使用媒体查询"><a href="#为什么使用媒体查询" class="headerlink" title="为什么使用媒体查询"></a>为什么使用媒体查询</h1><p>使用@media媒体查询，可以针对不同的媒体类型定义不同的样式。</p><h1 id="媒体查询的使用"><a href="#媒体查询的使用" class="headerlink" title="媒体查询的使用"></a>媒体查询的使用</h1><h2 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h2><p> 媒体查询有两种引入方法：</p><p>link元素中的CSS媒体查询 </p><p>css样式表中媒体查询 </p><a id="more"></a>




<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- link元素中的CSS媒体查询 --&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 样式表中的CSS媒体查询 --&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">@media (max-width: 600px) &#123;</span><br><span class="line">  .facet_sidebar &#123;</span><br><span class="line">    display: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p>你可以使用逻辑操作符，包括<code>not</code>、<code>and</code>和<code>only</code>等，构建复杂的媒体查询。<code>and</code>操作符用来把多个<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries#Media_features" target="_blank" rel="noopener">媒体属性</a>组合成一条媒体查询，对成链式的特征进行请求，只有当每个属性都为真时，结果才为真。<code>not</code>操作符用来对一条媒体查询的结果进行取反。<code>only</code>操作符仅在媒体查询匹配成功的情况下被用于应用一个样式，这对于防止让选中的样式在老式浏览器中被应用到。若使用了<code>not</code>或<code>only</code>操作符，必须明确指定一个媒体类型。</p>
<p>你也可以将多个媒体查询以逗号分隔放在一起；只要其中任何一个为真，整个媒体语句就返回真。相当于<code>or</code>操作符。</p>
<p>eg：and 关键字用于合并多个媒体属性或合并媒体属性与媒体类型,只有当每个属性都为真时，结果才为真  <code>@media and (max-width:600px) and (min-width: 800px;){......}</code>,此代码表示屏幕宽度在600-800px时，使用上述样式。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>最好在使用媒体查询时引入如下meta标签保证媒体查询的精准.</p>
<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;</code></p>
<p>width = device-width：宽度等于当前设备的宽度<br>initial-scale:初始的缩放比例(默认设置为1.0)<br>minimum-scale:允许用户缩放到的最小比例(默认设置为1.0)<br>maximum-scale:允许用户缩放到的最大比例(默认设置为1.0)<br>user-scalable:用户是否可以手动缩放(默认设置为no，因为我们不希望用户放大缩小页面)</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries" target="_blank" rel="noopener">MDN-CSS媒体查询</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>响应式的优点与缺点？</title>
    <url>/2019/10/10/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%839/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9%EF%BC%9F/</url>
    <content><![CDATA[<p>响应式网站是在2010年提出来的，是为了能让网页在不同设备下兼容多个终端，而不是为每个终端特定一种版本。 </p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>1.在不同设备下能有不同的页面排版，这也是响应式最大的优点，在分辨率不同，设备环境进行一些不同的设计，所有开发维护和运营上，相对多个版本成本会降低很多。 </p><p>2.兼容性好，能在不同的设备下浏览。 </p><a id="more"></a>


<p>3.方便后期维护页面，只需要对必要的页面进行修改，不会影响其他页面。 </p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>1.页面加载过多的代码，当你在pc端加载的时候，css样式也会将手机端的冗余代码一块加载，这样就直接影响了加载速度。 </p>
<p>2.在响应式设计中，图片和视频都是统一加载的，当你在设备低的手机上加载不符合当前需要的图片或者视频，就会过多的消耗用户的流量。 </p>
<p>3.局限性，对于响应式，局限性较大，不适合一些大型的门户网或者电商网站，一般门户网或电商网站一个界面内容较多，而响应式最忌讳较多内容，代码过多会影响运行速度。<br>对大型门户或电商网站来说，响应式设计目前确实不太适合。因为响应式设计的基本原则是不会因设备不同而给予用户不同的内容（比如在低分辩率设备上删减某些内容），而大型门户或电商网站的单页内容非常多，当缩减到低分辨率设备上，又要保证内容全部可浏览时，必然导致页面拉长，浏览困难度增加。所以很多大型门户或电商网站都会提供一个移动设备版的网站，或者干脆直接让用户缩放网页进行浏览。</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何使用bootstrap栅格系统？</title>
    <url>/2019/10/10/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%839/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8bootstrap%E6%A0%85%E6%A0%BC%E7%B3%BB%E7%BB%9F%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="bootstrap栅格系统"><a href="#bootstrap栅格系统" class="headerlink" title="bootstrap栅格系统"></a>bootstrap栅格系统</h1><h2 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap"></a>bootstrap</h2><p>Bootstrap 是一个用于快速开发 Web 应用程序和网站的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的。 </p><h2 id="bootstrap栅格系统-1"><a href="#bootstrap栅格系统-1" class="headerlink" title="bootstrap栅格系统"></a>bootstrap栅格系统</h2><p>Bootstrap 提供了一套响应式、移动设备优先的流式网格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。 </p><a id="more"></a>

<h1 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h1><p>1、数据行(.row)必须包含在容器（.container）中，以便为其赋予合适的对齐方式和内距(padding)。  </p>
<p>2、在行(.row)中可以添加列(.column)，但列数之和不能超过平分的总列数，比如12。  </p>
<p>3、具体内容应当放置在列容器（column）之内，而且只有列（column）才可以作为行容器(.row)的直接子元素  </p>
<p>4、通过设置内距（padding）从而创建列与列之间的间距。然后通过为第一列和最后一列设置负值的外距（margin）来抵消内距(padding)的影响 。</p>
<h1 id="编码实战"><a href="#编码实战" class="headerlink" title="编码实战"></a>编码实战</h1><p>HTML代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;col-*-*&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;col-*-*&quot;&gt;&lt;/div&gt;      </span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">   &lt;div class=&quot;row&quot;&gt;...&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;....</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.runoob.com/bootstrap/bootstrap-grid-system.html" target="_blank" rel="noopener">菜鸟教程bootstrap栅格系统</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>margin负值在页面布局中有哪些应用？</title>
    <url>/2019/10/10/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%838/margin%E8%B4%9F%E5%80%BC%E5%9C%A8%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<ol>
<li><p>左右列固定，中间列自适应布局 </p>
<p>此例适用于左右栏宽度固定，中间栏宽度自适应的布局。由于网页的主体部分一般在中间，很多网页都需要中间列优先加载，而这种布局刚好满足此需求。</p>
</li>
<li><p>去除列表右边框 </p>
<p>项目中经常会使用浮动列表展示信息，为了美观通常为每个列表之间设置一定的间距（margin-right）,当父元素的宽度固定式，每一行的最右端的li元素的右边距就多余了，去除的方法通常是为最右端的li添加class，设置margin-right:0; 这种方法需要动态判断为哪些li元素添加class，麻烦！！！利用负margin就可以实现下面这种效果：</p>
</li>
<li><p>负边距+定位：水平垂直居中 </p>
<p>使用绝对定位将div定位到body的中心，然后使用负margin（content宽高的一半），将div的中心拉回到body的中心，已到达水平垂直居中的效果。</p>
</li>
<li><p>去除列表最后一个li元素的border-bottom </p>
<p>列表中我们经常会添加border-bottom值，最后一个li的border-bottom往往会与外边框重合，视觉上不雅观，往往要移除。</p>
</li>
<li><p>多列等高 </p>
<p>此例关键是给每个框设置大的底部内边距，然后用数值相似的负外边距消除这个高度。这会导致每一列溢出容器元素，如果把外包容器的overflow属性设为hidden，列就在最高点被裁切。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>css有哪些方式可以实现垂直居中？</title>
    <url>/2019/10/10/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%838/css%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>前端在设计一个版面时，通常都会用到水平，垂直居中，水平居中相对来说比较好处理，而垂直居中就稍微复杂点，但他们两个都是我们需要熟练掌握的知识点。</p><h1 id="水平居中设置"><a href="#水平居中设置" class="headerlink" title="水平居中设置"></a>水平居中设置</h1><h2 id="1-行内元素"><a href="#1-行内元素" class="headerlink" title="1.行内元素"></a>1.行内元素</h2><p>设置 text-align:center  </p><h2 id="2-定宽块状元素"><a href="#2-定宽块状元素" class="headerlink" title="2.定宽块状元素"></a>2.定宽块状元素</h2><p>设置 左右 margin 值为 auto  </p><h2 id="3-不定宽块状元素"><a href="#3-不定宽块状元素" class="headerlink" title="3.不定宽块状元素"></a>3.不定宽块状元素</h2><ul>
<li>在元素外加入 table 标签（完整的，包括 table、tbody、tr、td），该元素写在 td 内，然后设置 margin 的值为 auto  </li>
<li>给该元素设置 display:in-line 方法 </li>
<li>父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left:50%  </li>
</ul><a id="more"></a>



<h1 id="垂直居中设置"><a href="#垂直居中设置" class="headerlink" title="垂直居中设置"></a>垂直居中设置</h1><h2 id="1-父元素高度确定的单行文本"><a href="#1-父元素高度确定的单行文本" class="headerlink" title="1.父元素高度确定的单行文本"></a>1.父元素高度确定的单行文本</h2><p>​    设置 height = line-height  </p>
<h2 id="2-父元素高度确定的多行文本"><a href="#2-父元素高度确定的多行文本" class="headerlink" title="2.父元素高度确定的多行文本"></a>2.父元素高度确定的多行文本</h2><ul>
<li>插入 table （插入方法和水平居中一样），然后设置 vertical-align:middle </li>
<li>先设置 display:table-cell 再设置 vertical-align:middle </li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://tianxintiandisheng.github.io/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%835/%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BCSS3%E7%9A%84Flexbox%EF%BC%88%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B%EF%BC%89%E4%BB%A5%E5%8F%8A%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F/" target="_blank" rel="noopener">Flex大法好！</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>bootstrap有哪些常用组件？</title>
    <url>/2019/10/10/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%838/bootstrap%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h1><p>组件:一般是指软件系统的一部分，承担了特定的职责，可以独立于整个系统进行开发和测试， 一个良好设计的组件应该可以在不同的软件系统中被使用(可复用)。  </p>
<h1 id="目前常用的bootstrap组件："><a href="#目前常用的bootstrap组件：" class="headerlink" title="目前常用的bootstrap组件："></a>目前常用的bootstrap组件：</h1><p>1.轮播图</p>
<p>2.下拉菜单</p>
<p>3.响应式导航栏 </p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>div+css的布局较table布局有什么优点？</title>
    <url>/2019/10/10/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%838/div-css%E7%9A%84%E5%B8%83%E5%B1%80%E8%BE%83table%E5%B8%83%E5%B1%80%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>tableE布局是WEB早期CSS不存在的时候兴起的，是对TABLE标签的不正规使用，Table标签就是表格，是用来显示数据的，而不是用来布局网页的，虽然它有时候布局网页很简单。现在绝大多数的网站都是用DIV+CSS布局，现在的网页越来越倾向于使用DIV的方法来布局网页了。  这两种布局各有各的优缺点。 </p><a id="more"></a>
<h1 id="div-css布局"><a href="#div-css布局" class="headerlink" title="div+css布局"></a>div+css布局</h1><h2 id="div-css布局的优点"><a href="#div-css布局的优点" class="headerlink" title="div+css布局的优点"></a>div+css布局的优点</h2><p>可以通过css样式给框架进行功能强大的属性设置以及给网页的局部进行任意的定位，制作出来的页面浏览速度较快，同时页面的风格可以通过修改单独的css文件进行随意的修改和更新；</p>
<p>1.符合W3C标准，代码结构清晰明了，结构、样式和行为分离，带来足够好的可维护性。 </p>
<p>2.布局精准，网站版面布局修改简单。 </p>
<p>3.加快了页面的加载速度（最重要的）（在IE中要将整个table加载完了才显示内容）。  </p>
<p>4.节约站点所占的空间和站点的流量。  </p>
<p>5.用只包含结构化内容的HTML代替嵌套的标签，提高另外搜索引擎对网页的搜索效率。 </p>
<h2 id="div-css布局的缺点"><a href="#div-css布局的缺点" class="headerlink" title="div+css布局的缺点"></a>div+css布局的缺点</h2><p>每个div容器都需要定义css样式来控制，制作过程相比table方式要复杂。</p>
<h1 id="table布局"><a href="#table布局" class="headerlink" title="table布局"></a>table布局</h1><h2 id="table布局的优点"><a href="#table布局的优点" class="headerlink" title="table布局的优点"></a>table布局的优点</h2><p>1.容易上手。</p>
<p>2.可以形成复杂的变化，简单快速。</p>
<p>3.表现上更加“严谨”，在不同浏览器中都能得到很好的兼容。 </p>
<h2 id="table布局的缺点"><a href="#table布局的缺点" class="headerlink" title="table布局的缺点"></a>table布局的缺点</h2><p>由于html文件中的table标签的浏览速度较慢，所以，使用嵌套表格的方法来布局网页框架会使网页浏览的速度变慢。因为table是中的内容是自适应的，为了自适应，它要计算嵌套最深的节点以满足自适应，所以有可能会有一断时间出现空白才显示。所以是会有问题的。</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>什么是外边距重叠？重叠的结果是什么？</title>
    <url>/2019/10/10/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%838/%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%96%E8%BE%B9%E8%B7%9D%E9%87%8D%E5%8F%A0%EF%BC%9F%E9%87%8D%E5%8F%A0%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="外边距重叠"><a href="#外边距重叠" class="headerlink" title="外边距重叠"></a>外边距重叠</h1><p>边界重叠是指两个或多个盒子(可能相邻也可能嵌套)的相邻边界(其间没有任何非空内容、补白、边框)重合在一起而形成一个单一边界。两个或多个块级盒子的垂直相邻边界会重合。</p><h1 id="外边距重叠的结果"><a href="#外边距重叠的结果" class="headerlink" title="外边距重叠的结果"></a>外边距重叠的结果</h1><p>结果的边界宽度是相邻边界宽度中最大的值。</p><p>如果出现负边界，则在最大的正边界中减去绝对值最大的负边界。</p><p>如果没有正边界，则从零中减去绝对值最大的负边界。  </p><a id="more"></a>



<h1 id="外边距重叠的意义"><a href="#外边距重叠的意义" class="headerlink" title="外边距重叠的意义"></a>外边距重叠的意义</h1><p>外边距的重叠只产生在普通流文档的上下外边距之间，这个看起来有点奇怪的规则，其实有其现实意义。设想，当我们上下排列一系列规则的块级元素（如段落P）时，那么块元素之间因为外边距重叠的存在，段落之间就不会产生双倍的距离。  </p>
<h1 id="防止外边距重叠解决方案"><a href="#防止外边距重叠解决方案" class="headerlink" title="防止外边距重叠解决方案"></a>防止外边距重叠解决方案</h1><p>虽然外边距的重叠有其一定的意义，但有时候我们在设计上却不想让元素之间产生重叠，那么可以有如下几个建议可供参考： </p>
<ul>
<li>外层元素padding代替  </li>
<li>内层元素透明边框 border:1px solid transparent;  </li>
<li>内层元素绝对定位 postion:absolute:  </li>
<li>外层元素 overflow:hidden;  </li>
<li>内层元素 加float:left;或display:inline-block;  </li>
<li>内层元素padding:1px; </li>
</ul>
<hr>
<blockquote>
<p>版权声明：本文为CSDN博主「jnshu_it」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/jnshu_it/article/details/85370693" target="_blank" rel="noopener">https://blog.csdn.net/jnshu_it/article/details/85370693</a></p>
</blockquote>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>主流浏览器内核有哪几种？</title>
    <url>/2019/10/10/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%838/%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h1><p>浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。</p><a id="more"></a>
<p>浏览器最重要或者说最核心的部分是“Rendering Engine”，可大概译为“渲染引擎”，不过一般习惯将之称为“浏览器内核”，负责对网页语法的解释并渲染网页。所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。  </p>
<h1 id="主流浏览器内核"><a href="#主流浏览器内核" class="headerlink" title="主流浏览器内核"></a>主流浏览器内核</h1><h2 id="1-Trident-IE内核"><a href="#1-Trident-IE内核" class="headerlink" title="1.Trident/IE内核"></a>1.Trident/IE内核</h2><p>该内核程序在1997年的IE4中首次被采用，是微软在Mosaic代码的基础之上修改而来的，并沿用到IE11，也被普遍称作”IE内核”。Trident实际上是一款开放的内核，其接口内核设计的相当成熟，因此才有许多采用IE内核而非IE的浏览器(壳浏览器)涌现。由于IE本身的“垄断性”（虽然名义上IE并非垄断，但实际上，特别是从Windows 95年代一直到XP初期，就市场占有率来说IE的确借助Windows的东风处于“垄断”的地位）而使得Trident内核的长期一家独大，微软很长时间都并没有更新Trident内核，这也导致了后面的两个后果： 一是Trident内核曾经几乎与W3C标准脱节（2005年） 二是Trident内核的大量 Bug等安全性问题没有得到及时解决，然后加上一些致力于开源的开发者和一些学者们公开自己认为IE浏览器不安全的观点，也有很多用户转向了其他浏览 器，Firefox和Opera就是这个时候兴起的。 Trident内核的常见浏览器有：IE6、IE7、IE8（Trident 4.0）、IE9（Trident 5.0）、IE10（Trident 6.0）、2345浏览器、腾讯TT、淘宝浏览器、阿云浏览器（早期版本）、瑞星安全浏览器、蚂蚁浏览器、飞腾浏览器、速达浏览器、佐罗浏览器、海豚浏览器等等  </p>
<h2 id="2-Gecko-Firefox内核"><a href="#2-Gecko-Firefox内核" class="headerlink" title="2.Gecko/Firefox内核"></a>2.Gecko/Firefox内核</h2><p>Netscape6开始采用的内核，后来的Mozilla FireFox(火狐浏览器) 也采用了该内核，Gecko的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko内核的浏览器也很多，这也是Gecko内核虽然年轻但市场占有率能够迅速提高的重要原因。事实上，Gecko引擎的由来跟IE不无关系，前面说过IE没有使用W3C的标准，这导致了微软内部一些开发人员的不满；他们与当时已经停止更新了的 Netscape的一些员工一起创办了Mozilla，以当时的Mosaic内核为基础重新编写内核，于是开发出了Gecko。不过事实上，Gecko 内核的浏览器仍然还是Firefox (火狐) 用户最多，所以有时也会被称为Firefox内核。Gecko核心设计的相对成熟，在无法获取源码的情况下，开放程度仅次于IE。由于其本身Open Source。实际上是目前开发程度最好的浏览器。Firefox的扩展能够给浏览者带来完全不同的浏览体验。市面上Gecko内核的浏览器主要分两类，一类是以Mozilla Firefox为代表的，用XUL作为界面描述语言的浏览器：这类浏览器往往继承了Firefox扩展性好的优点，早前的Madfox和Albatross就是这一类型的浏览器。所以，Gecko内核也被称为Firefox内核。 Gecko内核常见的浏览器： Mozilla Firefox、Mozilla SeaMonkey、waterfox（Firefox的64位开源版）、Iceweasel、Epiphany（早期版本）、Flock（早期版本）等等</p>
<h2 id="3-WebKit内核"><a href="#3-WebKit内核" class="headerlink" title="3.WebKit内核"></a>3.WebKit内核</h2><p>Webkit(Safari内核,Chrome内核原型,开源):它是苹果公司自己的内核，也是苹果的Safari浏览器使用的内核。 Webkit引擎包含WebCore排版引擎及JavaScriptCore解析引擎，均是从KDE的KHTML及KJS引擎衍生而来，它们都是自由软件，在GPL条约下授权，同时支持BSD系统的开发。WebKit 内核在手机上的应用也十分广泛，例如 Google 的手机 Gphone、 Apple 的 iPhone, Nokia’s Series 60 browser 等所使用的 Browser 内核引擎，都是基于 WebKit。2003年，Apple 宣布发布首款他们自主开发的 web 浏览器：Safari。它的呈现引擎叫 WebKit。它是 Linux 中的 web 浏览器 Konqueror 呈现引擎 KHTML 的一个分支，几年后，WebKit 的开源吸引了呈现引擎的开发人员。根据最新的浏览器调查表明，该浏览器的市场甚至已经超过了Opera的Presto了——当然这一方面得益于苹果转到x86架构之后的人气暴涨，另外也是因为Safari 3终于推出了Windows版的缘故吧。Google Chrome、360极速浏览器以及搜狗高速浏览器高速模式也使用Webkit作为内核(在脚本理解方面，Chrome使用自己研发的V8引擎)。WebKit 内核在手机上的应用也十分广泛，例如 Google 的手机 Gphone、 Apple 的iPhone， Nokia’s Series 60 browser 等所使用的 Browser 内核引擎，都是基于 WebKit。 WebKit内核常见的浏览器：傲游浏览器3、[1] Apple Safari (Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器，  </p>
<h2 id="4-Presto内核"><a href="#4-Presto内核" class="headerlink" title="4.Presto内核"></a>4.Presto内核</h2><p>Presto是一个由Opera Software开发的浏览器排版引擎，供Opera 7.0及以上使用。该款引擎的特点就是渲染速度的优化达到了极致，也是目前公认网页浏览速度最快的浏览器内核，然而代价是牺牲了网页的兼容性。实际上它是一个动态内核，与其它几个内核的最大的区别就在脚本处理上，Presto有着天生的 优势，页面的全部或者部分都能够在回应脚本事件时等情况下被重新解析。此外该内核在执行Javascrīpt的时候有着最快的速度，根据在同等条件下的测 试，Presto内核执行同等Javascrīpt所需的时间仅有Trident和Gecko内核的约1/3（Trident内核最慢，不过两者相差没有多大）。由于Presto是商业引擎，使用Presto的除开Opera以外，只剩下NDSBrowser、Wii Internet Channle、Nokia 770网络浏览器等，这很大程度上限制了Presto的发展。  </p>
<h2 id="5-Blink内核"><a href="#5-Blink内核" class="headerlink" title="5.Blink内核"></a>5.Blink内核</h2><p>2013 年 4 月 3 日，谷歌在 Chromium Blog 上发表 博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实Blink引擎就是也就是Webkit的分支，就像Webkit是KHTML的分支一样。Blink引擎现在是谷歌公司与Opera Software共同研发， </p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何用css写一个简单的幻灯片效果页面？</title>
    <url>/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%838/%E5%A6%82%E4%BD%95%E7%94%A8css%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%B9%BB%E7%81%AF%E7%89%87%E6%95%88%E6%9E%9C%E9%A1%B5%E9%9D%A2%EF%BC%9F/</url>
    <content><![CDATA[<p>CSS3属性中有关于制作动画的三个属性：Transform,Transition,Animation。</p><p>transform属性向元素应用2D或3D转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</p><p>transition是令一个或多个可以用数值表示的css属性值发生变化时产生过渡效果。</p><p>Animation字面上的意思，就是“动画”的意思.</p><a id="more"></a>



<p>我们使用CSS3的Animation制作动画，实现简单的幻灯片效果，可以省去复杂的js,jquery代码。</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何实现轮播图？</title>
    <url>/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%838/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE%EF%BC%9F/</url>
    <content><![CDATA[<p>通过以下的5个过程，实现轮播图的轮播效果 </p><h1 id="1-动态生成结构"><a href="#1-动态生成结构" class="headerlink" title="1.动态生成结构"></a>1.动态生成结构</h1><p>创建元素和插入元素的方法分别是什么？<br>创建元素：<code>document.creatElement( tagName ) var li = document.creatElement(“li”)；</code><br>插入元素：<code>appendChild( element ) ol.appendChild(“li”);</code><br>通过什么方法复制第一张图片元素？<br>通过<code>cloneNode()</code>方法来复制元素：<code>eg . var firstImg = ulLis[0].cloneNode(true)</code>； 其中<code>cloneNode</code>方法中，如果传递给它的参数是 true，它还将递归复制当前节点的所有子孙节点。否则，它只复制当前节点 </p><a id="more"></a>

<h1 id="2-鼠标经过按钮"><a href="#2-鼠标经过按钮" class="headerlink" title="2.鼠标经过按钮"></a>2.鼠标经过按钮</h1><p>鼠标经过时如何改变按钮样式？<br>a. 清除所有按钮的样式 <code>for (var j = 0; j &lt; olLis.length; j++) { olLis[j].className = “”; }</code><br>b. 给当前鼠标所在按钮添加特殊样式<code>this.className = “current”;</code><br>鼠标经过按钮时如何计算图片盒子移动的距离?<br>通过按钮索引值（this.index）和图片的宽度（imgWidth）来计算图片盒子要移动的距离（target） <code>target = - this.index * imgWidth</code> </p>
<h1 id="3-鼠标点击箭头"><a href="#3-鼠标点击箭头" class="headerlink" title="3.鼠标点击箭头"></a>3.鼠标点击箭头</h1><p><strong>通过什么属性改变左右箭头的隐藏和显示？</strong><br>通过控制左右箭头盒子的display属性来控制左右箭头盒子的显示（block）和隐藏（none）<br>通过什么机制来统一左/右箭头点击时图片切换为当前图片的上/下一张？<br>利用全局变量来统一左右箭头切换图片，在左右箭头点击时，通过pic来计算图片盒子移动的目标位置 <code>var target = -pic * imgWidth;</code><br>当点击左箭头时：pic– –这样target比当前位置数值大imgWidth 图片盒子向右移动一张图片的距离 显示出上一张图片<br>当点击右箭头时：pic++ 这样target比当前位置数值小imgWidth 图片盒子向左移动一张图片的距离 显示出下一张图片 </p>
<h1 id="4-按钮随之变化"><a href="#4-按钮随之变化" class="headerlink" title="4.按钮随之变化"></a>4.按钮随之变化</h1><p>square的取值范围以及其与pic对应情况 </p>
<h1 id="5-添加自动滚动"><a href="#5-添加自动滚动" class="headerlink" title="5.添加自动滚动"></a>5.添加自动滚动</h1><p>图片自动播放下一张和点击右箭头的操作相同<br>图片轮播主要技术点为：<br>一、<code>&lt;ul&gt; &lt;li&gt;</code> 来作导航栏；<br>二、通过设置其属性为<code>overflow:none</code>，使照片集部分隐藏； </p>
<p>三、CSS3的transition 结合 transform 来做动画变换；<br>四、JQUERY通过选择器，控制动画元素属性。 </p>
<p>动画描述<br>一、鼠标放在图片上，会出现左右滑动箭头；<br>二、点击箭头会使图片集左右移动，中间图片会旋转360度，并放大1.2倍；<br>三、图片到边界时不能再滑动</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如果是在手机上查看投票页，没有hover效果时应该怎么办？</title>
    <url>/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%837/%E5%A6%82%E6%9E%9C%E6%98%AF%E5%9C%A8%E6%89%8B%E6%9C%BA%E4%B8%8A%E6%9F%A5%E7%9C%8B%E6%8A%95%E7%A5%A8%E9%A1%B5%EF%BC%8C%E6%B2%A1%E6%9C%89hover%E6%95%88%E6%9E%9C%E6%97%B6%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="为什么hover在手机上没效果？"><a href="#为什么hover在手机上没效果？" class="headerlink" title="为什么hover在手机上没效果？"></a>为什么hover在手机上没效果？</h1><p>让我们再回顾一下hover的定义…</p><p><code>:hover</code>用于选择鼠标指针浮动在上面的元素。</p><p>再想一想…</p><p>手机上哪来的鼠标啊伙计？！</p><p>SO,手机端没有hover特效，当你点击的时候就直接触发click。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p><strong>首先，经试验发现，设置的<code>：hover</code>在Android系统上点击会出现， 但是需要再次点击才会消失；</strong></p><a id="more"></a>





<p><strong>IOS系统上点击无法出现；</strong></p>
<p>手机虽然没有鼠标，但是有触摸事件.</p>
<p>一开始触摸事件是ios版Safari浏览器为了向开发人员传达一些信息新添加的事件。 因为ios设备既没有鼠标也没有键盘，所以在为移动Safari浏览器开发交互性网页的时候， PC端的鼠标和键盘事件是不够用的。</p>
<p>在iPhone 3G发布的时候，其自带的移动Safari浏览器就提供了一些与触摸(touch)操作相关的新事件。 随后，Android上的浏览器也实现了相同的事件。触摸事件(touch)会在用户手指放在屏幕上面的时候、 在屏幕上滑动的时候或者是从屏幕上移开的时候触发。</p>
<p>1.touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。</p>
<p>2.touchmove事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间， 调用preventDefault()事件可以阻止滚动。</p>
<p>3.touchend事件：当手指从屏幕上离开的时候触发。</p>
<p>4.touchcancel事件：touchcancel，是在拖动中断时候触发。</p>
<hr>
<blockquote>
<p>版权声明：本文为CSDN博主「jnshu_it」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/jnshu_it/article/details/85759010" target="_blank" rel="noopener">https://blog.csdn.net/jnshu_it/article/details/85759010</a></p>
</blockquote>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>描述下z-index和叠加上下文是如何形成的？</title>
    <url>/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%837/%E6%8F%8F%E8%BF%B0%E4%B8%8Bz-index%E5%92%8C%E5%8F%A0%E5%8A%A0%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%A2%E6%88%90%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="z-index是什么？"><a href="#z-index是什么？" class="headerlink" title="z-index是什么？"></a>z-index是什么？</h1><p>z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。<br>该属性设置一个定位元素沿 z 轴的位置，z 轴定义为垂直延伸到显示区的轴。如果为正数，则离用户更近，为负数则表示离用户更远。</p><h1 id="z-index和叠加上下文是如何形成的"><a href="#z-index和叠加上下文是如何形成的" class="headerlink" title="z-index和叠加上下文是如何形成的"></a>z-index和叠加上下文是如何形成的</h1><p>一言难尽，献上传送门。</p><a id="more"></a>

<p><a href="https://blog.csdn.net/cat_sky/article/details/80302245" target="_blank" rel="noopener">z-index 层叠上下文的关系</a></p>
<h1 id="使用z-index有什么需要注意的地方？"><a href="#使用z-index有什么需要注意的地方？" class="headerlink" title="使用z-index有什么需要注意的地方？"></a>使用z-index有什么需要注意的地方？</h1><ul>
<li>在开发中尽量避免层叠上下文的多层嵌套，因为层叠上下文嵌套过多的话容易产生混乱，如果对层叠上下文理解不够的话是不好把控的。</li>
<li>非浮层元素（对话框等）尽量不要用z-index（通过层叠顺序或者dom顺序或者通过层叠上下文进行处理）</li>
<li>z-index设置数值时尽量用个位数</li>
<li>让absolute元素覆盖正常文档流内元素（不用设z-index，自然覆盖）</li>
<li>让后一个absolute元素覆盖前一个absolute元素（不用设z-index，只要在HTML端正确设置元素顺序即可）</li>
</ul>
<h1 id="什么情况下使用z-index？"><a href="#什么情况下使用z-index？" class="headerlink" title="什么情况下使用z-index？"></a>什么情况下使用z-index？</h1><p>当absolute元素覆盖另一个absolute元素，且HTML端不方便调整DOM的先后顺序时，需要设置z-index: 1。非常少见的情况下多个absolute交错覆盖，或者需要显示最高层次的模态对话框时，可以设置z-index &gt; 1。</p>
<hr>
<blockquote>
<p>版权声明：本文为CSDN博主「cat_sky」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://blog.csdn.net/cat_sky/article/details/80302245" target="_blank" rel="noopener">https://blog.csdn.net/cat_sky/article/details/80302245</a></p>
</blockquote>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>rgba和opacity的透明效果有什么不同？display和visiblity有什么区别？</title>
    <url>/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%837/rgba%E5%92%8Copacity%E7%9A%84%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9Fdisplay%E5%92%8Cvisiblity%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="rgba和opacity的透明效果有什么不同"><a href="#rgba和opacity的透明效果有什么不同" class="headerlink" title="rgba和opacity的透明效果有什么不同"></a>rgba和opacity的透明效果有什么不同</h1><p>opacity后代元素会随着一起具有透明性，Opacity中的字随着透明值下降越来越看不清楚，而RGBA不具有这样的问题。 </p><h1 id="display和visiblity有什么区别"><a href="#display和visiblity有什么区别" class="headerlink" title="display和visiblity有什么区别"></a>display和visiblity有什么区别</h1><p>display：通常可以设置为none、inline、block<br>visblity：通常可以设置为hidden、visible </p><a id="more"></a>

<p>当display为none，visibility为hidden时，元素都会不见。不过其还有不同之处。</p>
<p>区别：<br>display：none:隐藏元素但不占据该元素原来的空间。父级设置值为none后，无论子级设置任何值都无法显示。（<strong>不占空间，可遗传</strong>）<br>visibility：hidden:隐藏元素并且占据该元素原来的空间。子级设置visible后不受父级影响。（<strong>占空间，不遗传</strong>）</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>什么是浮动？有哪些清除浮动的方法？</title>
    <url>/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%837/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%AE%E5%8A%A8%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h1><p>在了解什么是浮动之前我们先了解一下html元素在普通流排列方式。在普通流中，元素是按照它在 HTML 中的出现的先后顺序自上而下依次排列布局的，在排列过程中所有的行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为一整行。如果没有特殊样式指定，所有元素默认都是按照普通流方式排列布局，即普通流中元素的位置由该元素在 HTML 文档中的位置决定的。</p><a id="more"></a>
<p>浮动使元素脱离文档普通流，漂浮在普通流之上的。浮动元素依然按照其在普通流的位置上出现，然后尽可能的根据设置的浮动方向向左或者向右浮动，直到浮动元素的外边缘遇到包含框或者另一个浮动元素为止，且允许文本和内联元素环绕它。浮动会产生块级框（相当于设置了display:block），而不管该元素本身是什么。</p>
<h1 id="为什么要清除浮动"><a href="#为什么要清除浮动" class="headerlink" title="为什么要清除浮动"></a>为什么要清除浮动</h1><p>如果我们不给父元素设置高度，我们知道如果它里面的元素不浮动的话， 那么这个外层的高是会自动被撑开的。<br>若浮动元素比它的父元素还高，那么它就会溢出父元素外面</p>
<p>当内层元素所有浮动后，则影响更大：</p>
<ul>
<li>背景不能显示</li>
<li>边框不能撑开</li>
<li>高度塌陷等<h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1>方法1：脚底插入clear:both;<br>方法2：父元素BFC(ie8+)或haslayout(ie6/ie7)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 现代浏览器clearfix方案，不支持IE6/7 </span><br><span class="line">.clearfix:after &#123; display: table; content: &quot; &quot;; clear: both; &#125; </span><br><span class="line">​</span><br><span class="line">// 全浏览器通用的clearfix方案// 引入了zoom以支持IE6/7</span><br><span class="line">.clearfix:after &#123; display: table; content: &quot; &quot;; clear: both; &#125; </span><br><span class="line">.clearfix&#123; *zoom: 1; &#125; </span><br><span class="line">​</span><br><span class="line">// 全浏览器通用的clearfix方案【推荐】</span><br><span class="line">// 引入了zoom以支持IE6/7 </span><br><span class="line">// 同时加入:before以解决现代浏览器上边距折叠的问题 </span><br><span class="line">.clearfix:before,</span><br><span class="line"> .clearfix:after &#123; display: table; content: &quot; &quot;; &#125;</span><br><span class="line"> .clearfix:after &#123; clear: both; &#125; </span><br><span class="line">.clearfix&#123; *zoom: 1; &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>什么是CSS sprites？</title>
    <url>/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%837/%E4%BB%80%E4%B9%88%E6%98%AFCSS-sprites%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ss sprites直译过来就是CSS精灵。通常被解释为“CSS图像拼合”或“CSS贴图定位”。其实就是通过将多个图片融合到一张图里面，然后通过CSS background背景定位技术技巧布局网页背景。</p><h1 id="为什么要使用CSS-sprites"><a href="#为什么要使用CSS-sprites" class="headerlink" title="为什么要使用CSS sprites"></a>为什么要使用CSS sprites</h1><p>这样做的好处也是显而易见的，因为图片多的话，会增加http的请求，无疑促使了网站性能的减低，特别是图片特别多的网站，如果能用css sprites降低图片数量，带来的将是速度的提升。 </p><a id="more"></a>

<h1 id="如何使用CSS-sprites"><a href="#如何使用CSS-sprites" class="headerlink" title="如何使用CSS sprites"></a>如何使用CSS sprites</h1><p>css sprites是什么通俗解释：CSS Sprites其实就是把网页中一些背景图片整合拼合成一张图片中，再利用DIV CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片在布局盒子对象位置。<br><a href="https://www.jianshu.com/p/84d7aa090ba1" target="_blank" rel="noopener">前端必备 CSS Sprites雪碧图生成工具</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>HTML中dl、ul、ol用哪个比较好？</title>
    <url>/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%835/HTML%E4%B8%ADdl%E3%80%81ul%E3%80%81ol%E7%94%A8%E5%93%AA%E4%B8%AA%E6%AF%94%E8%BE%83%E5%A5%BD%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ul，ol，dl标签是CSS网页布局中常用的列表元素。 列表将具有相似特征或先后顺序的内容按照从上到下的顺序排列起来。</p><h1 id="具体介绍"><a href="#具体介绍" class="headerlink" title="具体介绍"></a>具体介绍</h1><p>1.ul标签：无序列表始于 u l 标签。每个列表项始于l i标签，此列项目默认使用粗体圆点（典型的小黑圆圈）进行标记。</p><p>2.ol标签：有序列表始于ol标签，每个列表项始于li标签，列表项目使用数字进行标记。</p><a id="more"></a>


<p>3.dl标签：dl标签是定义列表，自定义列表不仅仅是一列项目，而是项目及其注释的组合。自定义列表以 dl 标签开始。每个自定义列表项以 dt 开始。每个自定义列表项的定义以 dd 开始。</p>
<h1 id="应用范围"><a href="#应用范围" class="headerlink" title="应用范围"></a>应用范围</h1><p>ul经常用来实现轮播的小按钮，下拉菜单的各种要用来排列的列表，多个a标签排列等，实用范围非常广。</p>
<p>ol因为它的有序属性，用的范围就比较小了，不是一定要用有序来排列的情况下，一般都是用ul。</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何使用IconFont？</title>
    <url>/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%835/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8IconFont%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="什么是IconFont"><a href="#什么是IconFont" class="headerlink" title="什么是IconFont?"></a>什么是IconFont?</h1><p>IconFont是阿里巴巴旗下的矢量图标库网站，通过搜索关键字可以获取前端开发所需的各类图标。</p><h1 id="如何使用IconFont？"><a href="#如何使用IconFont？" class="headerlink" title="如何使用IconFont？"></a>如何使用IconFont？</h1><p>step 1:百度iconfont,找到阿里巴巴矢量图标库官网,然后注册登录,或者用github登录也行,此步骤跳过; </p><p>step 2:找到图标管理-&gt;我的项目-&gt;然后新建项目: </p><a id="more"></a>


<p>step 3:项目新建完成后,往项目里添加我们要想使用的图标,找到图标库,搜索一个想要的图标,然后添加到购物车; </p>
<p>step 4:添加到购物车完成后,购物车徽章数字应该显示1了,点击右上角的购物车图标,选择添加至项目,选择我们刚刚创建的项目,确定; </p>
<p>step 5:接下来一部比较关键,将打包好的字体文件下载到本地添加到你的项目中,在项目中引用文件中的iconfont.css文件; </p>
<p>step 6:到了最后一步了,如何在项目中使用字体图标呢,其实很简单,创建一个i标签或者span标签,添加两个类名,一个固定的是iconfont,另一个是你想要的那个图标对应的类名:</p>
<blockquote>
<p>参考资料：<a href="https://blog.csdn.net/why12345678901/article/details/89633705" target="_blank" rel="noopener">如何使用IconFont</a></p>
</blockquote>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>title与h1、b与strong、i与em、img的alt与title、src与href有什么区别？</title>
    <url>/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%835/title%E4%B8%8Eh1%E3%80%81b%E4%B8%8Estrong%E3%80%81i%E4%B8%8Eem%E3%80%81img%E7%9A%84alt%E4%B8%8Etitle%E3%80%81src%E4%B8%8Ehref%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="title与h1"><a href="#title与h1" class="headerlink" title="title与h1"></a>title与h1</h1><p><strong>title</strong>的权重高于H1,其适用性要比H1广。</p><h1 id="b与strong、i与em"><a href="#b与strong、i与em" class="headerlink" title="b与strong、i与em"></a>b与strong、i与em</h1><p>物理元素：b、i </p><p>逻辑元素：em、strong </p><p> 物理元素是告诉浏览器我应该以何种格式显示文字，逻辑元素告诉浏览器这些文字有怎么样的重要性。  </p><p><strong>结论</strong>：对于搜索引擎来说<strong>逻辑元素</strong>比物理元素要重视的多。 </p><h1 id="mg的alt与title"><a href="#mg的alt与title" class="headerlink" title="mg的alt与title"></a>mg的alt与title</h1><a id="more"></a>




<p>alt 用于图片没显示时在图片显示区域显示一个说明文字。  title 表示鼠标在图片上停留时，显示一个悬浮框，其中显示的文字。  </p>
<h1 id="src与href"><a href="#src与href" class="headerlink" title="src与href"></a>src与href</h1><p>src是source的缩写，src的内容是页面必不可少的一部分，是引入。src指向的内容会嵌入到文档中当前标签所在的位置。常用的有：img、script、iframe。<br>href是Hypertext Reference的缩写，表示超文本引用。用来建立当前元素和文档之间的链接。常用的有：link、a。</p>
<p><strong>结论</strong>：src用于替换当前元素；href用于在当前文档和引用资源之间建立联系。</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>请解释一下CSS3的Flexbox（弹性盒布局模型）以及适用场景？</title>
    <url>/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%835/%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BCSS3%E7%9A%84Flexbox%EF%BC%88%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B%EF%BC%89%E4%BB%A5%E5%8F%8A%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="Flexbox（弹性盒布局模型）"><a href="#Flexbox（弹性盒布局模型）" class="headerlink" title="Flexbox（弹性盒布局模型）"></a>Flexbox（弹性盒布局模型）</h1><p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p>
<p>参考资料：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a></p>
<h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。–Flex 布局，可以简便、完整、响应式地实现各种页面布局。</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何理解vertical-align与line-height？</title>
    <url>/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%835/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3vertical-align%E4%B8%8Eline-height%EF%BC%9F/</url>
    <content><![CDATA[<p>vertical-align 属性设置元素的垂直对齐方式。<br>line-height 属性设置行间的距离（行高）。</p>
<p>参考资料：<br><a href="https://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/" target="_blank" rel="noopener">CSS深入理解vertical-align和line-height的基友关系</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>css可以绘制哪些常见的特殊形状？</title>
    <url>/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%835/css%E5%8F%AF%E4%BB%A5%E7%BB%98%E5%88%B6%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E7%89%B9%E6%AE%8A%E5%BD%A2%E7%8A%B6%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="为什么使用CSS绘制图形"><a href="#为什么使用CSS绘制图形" class="headerlink" title="为什么使用CSS绘制图形"></a>为什么使用CSS绘制图形</h1><p>在写网页的时候，会遇到需要装饰一些几何图形的情况，用css就可以实现很多特殊形状的绘制。它的特点是放大后图像不会失真，档案的占用空间较小，也可以减少http的请求。 </p><h1 id="CSS绘制图形"><a href="#CSS绘制图形" class="headerlink" title="CSS绘制图形"></a>CSS绘制图形</h1><h2 id="圆形-椭圆形"><a href="#圆形-椭圆形" class="headerlink" title="圆形/椭圆形"></a>圆形/椭圆形</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.circle&#123;</span><br><span class="line"></span><br><span class="line">width:10rem;</span><br><span class="line"></span><br><span class="line">height:10rem;</span><br><span class="line"></span><br><span class="line">border-radius:50%;</span><br><span class="line"></span><br><span class="line">background:orange;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>

<p>椭圆形只需改变矩形的边长 </p>
<h2 id="三角形-梯形"><a href="#三角形-梯形" class="headerlink" title="三角形/梯形"></a>三角形/梯形</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.triangle&#123;</span><br><span class="line"></span><br><span class="line">margin-top:5rem;</span><br><span class="line"></span><br><span class="line">width:0;</span><br><span class="line"></span><br><span class="line">border-bottom:5rem solid#00a000;</span><br><span class="line"></span><br><span class="line">border-left:5rem solid transparent;</span><br><span class="line"></span><br><span class="line">border-right:5rem solid transparent;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>梯形只需设定width的值即可 </p>
<h2 id="平行四边形"><a href="#平行四边形" class="headerlink" title="平行四边形"></a><strong>平行四边形</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parallelogram&#123;</span><br><span class="line"></span><br><span class="line">margin:5rem;</span><br><span class="line"></span><br><span class="line">width:10rem;</span><br><span class="line"></span><br><span class="line">height:5rem;</span><br><span class="line"></span><br><span class="line">transform:skew(30deg);</span><br><span class="line"></span><br><span class="line">background:orange;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>使用fixed的时候，在手机上查看是否会有问题，怎么解决？</title>
    <url>/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%834/%E4%BD%BF%E7%94%A8fixed%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%9C%A8%E6%89%8B%E6%9C%BA%E4%B8%8A%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E4%BC%9A%E6%9C%89%E9%97%AE%E9%A2%98%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>苹果会对position: fixed的元素位置做调整 </p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>尽量避免在移动端开发中使用position: fixed，而是更多使用更现代的布局方式和position: absolute来实现类似需求。</p>
<h1 id="详细解析"><a href="#详细解析" class="headerlink" title="详细解析"></a>详细解析</h1><p><a href="https://blog.csdn.net/jnshu_it/article/details/86611525" target="_blank" rel="noopener">使用fixed的时候，在手机上查看是否会有问题，怎么解决</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何理解HTML结构的语义化？</title>
    <url>/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%834/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3HTML%E7%BB%93%E6%9E%84%E7%9A%84%E8%AF%AD%E4%B9%89%E5%8C%96%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>HTML结构语义化，是最近几年才提出来的，以前的html结构，都是一堆的没有语义的冷冰冰的标签。最泛滥的就是div+css,以前的页面，一上来就是一堆的div+css, </p><p>为了改变这种这种状况，开发者们和官方提出了让HTML结构语义化的概念，并且官方w3c，也在HTML5给出了几个新的语义化的标签。 </p><a id="more"></a>

<h1 id="什么是语义化"><a href="#什么是语义化" class="headerlink" title="什么是语义化"></a>什么是语义化</h1><p>字面意思就是说根据我们所说的话，就能了解其中的含义。</p>
<p>语义化，故名思意，就是你写的HTml结构，是用相对应的有一定语义的英文字母（标签）表示的，标记的，因为HTML本身就是标记语言。不仅对自己来说，容易阅读，书写。别人看你的代码和结构也容易理解，甚至对一些不是做网页开发的人来说，也容易阅读。</p>
<h1 id="什么是HTML语义化"><a href="#什么是HTML语义化" class="headerlink" title="什么是HTML语义化"></a>什么是HTML语义化</h1><p>首先标签语义化是指HTML，不是CSS, 语义化标签只是HTML，CSS不存在语义化。HTML是标签，CSS是属性。</p>
<p>在最初html里标签的语义，我们看到table,就会知道这是列表，看到p，就知道这是段落，看到img知道是图片，看到input就知道这是一个表单，h1~h6是标题。 机器和人类相比笨多了，但是只要我们设定好程序，上面的标签的意思机器也能读懂。</p>
<p> 但是也有些是无语义化的如div—division并不能表示div标签里面内容的属性和表现样式</p>
<p> HTML 标签语义化是让大家直观的通过标签(markup)和属性(attribute)来知道其用途和作用。</p>
<h1 id="怎样判断标签是否语义化"><a href="#怎样判断标签是否语义化" class="headerlink" title="怎样判断标签是否语义化"></a>怎样判断标签是否语义化</h1><p>去掉样式，看网页结构是否组织良好有序，是否仍然有很好的可读性。 </p>
<h1 id="写HTML代码时应注意什么"><a href="#写HTML代码时应注意什么" class="headerlink" title="写HTML代码时应注意什么"></a>写HTML代码时应注意什么</h1><ol>
<li>尽可能少的使用无语义的标签div和span；</li>
<li>在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；</li>
<li>不要使用纯样式标签，如：b、font、u等，改用css设置。</li>
<li>需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；</li>
<li>使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；</li>
<li>每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来 </li>
</ol>
<h1 id="实现HTML语义化好处有哪些"><a href="#实现HTML语义化好处有哪些" class="headerlink" title="实现HTML语义化好处有哪些"></a>实现HTML语义化好处有哪些</h1><ol>
<li>清晰的页面结构。去掉或样式丢失的时候,也能让页面呈现清晰的结构，增强页面的可读性。</li>
<li>支持更多的设备。屏幕阅读器会完全根据你的标记来“读”你的网页。更好的支持浏览器的阅读模式等。</li>
<li>有利于SEO(搜索引擎优化)。和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息，搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重。</li>
<li>便于团队开发和维护。在团队中大家都遵循同一个标准，可以减少很多差异化的东西，方便开发和维护，提高开发效率，甚至实现模块化开发。</li>
<li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://segmentfault.com/a/1190000017824723" target="_blank" rel="noopener">如何理解HTML结构的语义化？</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>常见的表单元素有哪些？各有什么属性？</title>
    <url>/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%834/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%B1%9E%E6%80%A7%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="常用的表单元素"><a href="#常用的表单元素" class="headerlink" title="常用的表单元素"></a>常用的表单元素</h1><ol>
<li><p>form: 定义供用户输入的表单。</p>
</li>
<li><p>fieldset: 定义域。即输入区加有文字的边框。</p>
</li>
<li><p>legend：定义域的标题，即边框上的文字。</p>
</li>
<li><p>label：定义一个控制的标签。如输入框前的文字，用以关联用户的选择。</p>
</li>
<li><p>input: 定义输入域，常用。可设置type属性，从而具有不同功能。</p>
</li>
<li><p>textarea: 定义文本域(一个多行的输入控件)，默认可通过鼠标拖动调整大小。</p>
</li>
<li><p>button: 定义一个按钮。</p>
</li>
<li><p>select: 定义一个选择列表，即下拉列表。</p>
</li>
<li><p>option: 定义下拉列表中的选项。</p>
</li>
</ol><a id="more"></a>
<h1 id="表单元素的具体属性"><a href="#表单元素的具体属性" class="headerlink" title="表单元素的具体属性"></a>表单元素的具体属性</h1><h2 id="form"><a href="#form" class="headerlink" title="form"></a>form</h2><p><code>&lt;form name=&quot;&quot; action=&quot;&quot; method=&quot;get&quot;&gt;……&lt;/form&gt;</code></p>
<p>name : 表单名称；action : 用来指定表单处理程序的位置（url）；method : 定义表单结果从浏览器传送到服务器的方式，默认为”get”（也可以是post）</p>
<h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><p><code>&lt;input type=&quot;&quot; name=&quot;&quot; value=&quot;&quot; size=&quot;&quot;&gt;</code></p>
<p>name:控件名称；value:input控件默认文本值；size:input控件在页面中的显示宽度（必须是正整数）</p>
<p>input常用type属性如下：</p>
<ol>
<li>text：单行文本输入框，可以通过正整数的size控制框长度。</li>
<li>password：密码输入框。</li>
<li>radio：单选按钮，同一组的单选按钮必须要有相同的name。</li>
<li>checkbox：复选框，同一组的单选按钮必须要有相同的name。</li>
<li>button：普通按钮。</li>
<li>submit：提交按钮，每出现一次，一个 Submit 对象就会被创建。</li>
<li>reset：重置按钮，会重置当前表单中全部的内容。</li>
<li>image：图像形式的提交按钮，写法是“”。</li>
<li>hidden：隐藏域，隐藏字段对于用户是不可见的。</li>
<li>file：文件域，用于文件上传。</li>
</ol>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select size=&quot;&quot; multiple=&quot;multiple&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;option hidden&gt;选项1&lt;/option&gt;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>size：下拉菜单的可见选项数；multiple：多选。</p>
<p>在最新的html5中，有一些表单的新增属性，多用于js，如</p>
<p>datalist : 定义填写一个input时，提示几个option用于提示。可通过input的list特性与此元素作关联。</p>
<p>output : 表示计算的结果。可通过for特性与其它能够影响运算的元素（如input）作关联。</p>
<hr>
<blockquote>
<p>版权声明：本文为CSDN博主「jnshu_it」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://blog.csdn.net/jnshu_it/article/details/85370309" target="_blank" rel="noopener">https://blog.csdn.net/jnshu_it/article/details/85370309</a></p>
</blockquote>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>哪些css属性可以设置百分比，其计算原则是什么？</title>
    <url>/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%834/%E5%93%AA%E4%BA%9Bcss%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E7%99%BE%E5%88%86%E6%AF%94%EF%BC%8C%E5%85%B6%E8%AE%A1%E7%AE%97%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="定位属性"><a href="#定位属性" class="headerlink" title="定位属性"></a>定位属性</h1><p>top, right, bottom, left;<br>计算原则：基于父元素</p><h1 id="盒模型属性"><a href="#盒模型属性" class="headerlink" title="盒模型属性"></a>盒模型属性</h1><p>height, width, margin, padding; </p><p>height：基于包含它的块级对象的百分比高度<br>width：基于包含它的块级对象的百分比宽度<br>margin，padding：百分数是相对与父元素的width计算</p><a id="more"></a>


<h1 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h1><p>background-position; </p>
<p>background-position 的默认值是 0% 0%，在功能上相当于 top left。这就解释了背景图像为什么总是从元素内边距区的左上角开始平铺，除非您设置了不同的位置值。</p>
<h1 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h1><p>text-indent, line-height, vertical-align;</p>
<h1 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h1><p>font-size;</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>position定位有哪几种？各有什么特点？</title>
    <url>/2019/10/09/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%834/position%E5%AE%9A%E4%BD%8D%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h1><p>简介：生成相对定位的元素，相对于其正常位置进行定位。 </p><p>生成相对定位的元素，相对于其正常位置进行定位。元素的位置通过left、right、top、button属性进行规定，可以通过z-index进行层次分级。 元素仍保持其未定位前的形状，原本所占的空间仍将保留。（如果没有定位偏移量，对元素本身没有任何影响。所以可以设置父元素的position属性为relative，使其成为子元素的包含块）</p><a id="more"></a>

<h1 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h1><p>简介：生成绝对定位元素。使元素脱离文档流，并相对于其包含块进行定位，包含块可能是文档中的另一个元素或者是初始包含块，元素原先在正常文档流中所占的空间会会被后面元素占据； </p>
<p>元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框；绝对定位元素的包含块由离它最近的 ‘position’ 属性为 ‘absolute’、’relative’ 或者 ‘fixed’ 的祖先元素创建。只要父级元素设置了position并且不是static（默认既是static），那么设定了absolute的子元素即以此为包含块（最近的）。如果都没有定义，那么就相对于整个文档body定位（注意不是相对于浏览器窗口定位） </p>
<h1 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h1><p>简介：生成绝对定位元素，相对于浏览器窗口的定位。 </p>
<p>通常配合z-index一起来使用。比如说网页上悬挂的聊天图标或者广告就是用fixed</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>手机分辨率和网页中的px是一回事吗？</title>
    <url>/2019/10/08/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%833/%E6%89%8B%E6%9C%BA%E5%88%86%E8%BE%A8%E7%8E%87%E5%92%8C%E7%BD%91%E9%A1%B5%E4%B8%AD%E7%9A%84px%E6%98%AF%E4%B8%80%E5%9B%9E%E4%BA%8B%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h1><p>像素即px，是画面中最小的点（单位色块）。像素的大小是没有固定长度值的，不同设备上1个单位像素色块的大小是不一样的。 </p><p>px是一个相对单位，而且在特定设备上总是一个近似值（原则是尽量接近参考像素）。 </p><h1 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h1><p>分辨率=画面水平方向的像素值 * 画面垂直方向的像素值。</p><p>分辨率可以分为两方面：屏幕分辨率和图像分辨率。</p><a id="more"></a>



<ol>
<li><p>屏幕分辨率：     </p>
<p>例如，屏幕分辨率是1024×768，也就是说设备屏幕的水平方向上有1024个像素点，垂直方向上有768个像素点。像素的大小是没有固定长度的，不同设备上一个单位像素色块的大小是不一样的。    例如，尺寸面积大小相同的两块屏幕，分辨率大小可以是不一样的，分辨率高的屏幕上面像素点（色块）就多，所以屏幕内可以展示的画面就更细致，单个色块面积更小。而分辨率低的屏幕上像素点（色块）更少，单个像素面积更大，可以显示的画面就没那么细致。</p>
</li>
<li><p>图像分辨率：    </p>
<p>例如，一张图片分辨率是500x200，也就是说这张图片在屏幕上按1:1放大时，水平方向有500个像素点（色块），垂直方向有200个像素点（色块）。    在同一台设备上，图片分辨率越高，这张图片1:1放大时，图片面积越大；图片分辨率越低，这张图片1:1缩放时，图片面积越小。（可以理解为图片的像素点和屏幕的像素点是一个一个对应的）。    但是，在屏幕上把图片超过100%放大时，为什么图片上像素色块也变的越大，其实是设备通过算法对图像进行了像素补足，我们把图片放的很大后看到的一块一块的方格子，虽然理解为一个图像像素，但是其实是已经补充了很多个屏幕像素；同理，把图片小于100%缩小时，也是通过算法将图片像素进行减少。</p>
</li>
</ol>
<h1 id="移动设备分辨率"><a href="#移动设备分辨率" class="headerlink" title="移动设备分辨率"></a>移动设备分辨率</h1><p>说到移动设备分辨率，这里先提另一个单位dpi(dot per inch)<br>dpi/ppi是表示一个每inch多少个物理像素dot的单位<br>在最开始是160dpi/ppi<br>后来因为技术的提高，为了追求高清屏幕，有了320dpi/ppi以上等等的屏幕<br>下面继续说移动设备分辨率<br>我们可以理解分辨率就是长宽分别有多少个物理像素dot<br>但是设备大小就那么大，所以同样大小的设备，分辨率越高，物理像素堆得越多，屏幕越清晰，也就是dpi越高</p>
<h1 id="网页中的px（css像素）"><a href="#网页中的px（css像素）" class="headerlink" title="网页中的px（css像素）"></a>网页中的px（css像素）</h1><p>在桌面浏览器：1px（下面我们读成‘css像素’）代表1个物理像素，也就是1css像素 = 1物理像素<br>没有加meta viewport标签时候：移动端viewport宽度为980px或者1024px，这时候1css像素不确定是几个物理像素（根据分辨率来算）<br>写个20px的文字看看效果（见演示）<br>在加了meta viewport标签以后呢？我们引入另外一个单位：密度独立像素dp/dip<br>dp/dip是在不同设备都显示为同一大小的单位（见演示）<br>简单理解，在使用了<code>&lt;xmp&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;/xmp&gt;</code>之后，所有1px = 1dp/dip<br>添加meta标签后20px的文字（见演示）<br>设备的独立像素都是可以查到的</p>
<h1 id="UI口中的px像素"><a href="#UI口中的px像素" class="headerlink" title="UI口中的px像素"></a>UI口中的px像素</h1><p>UI图中的像素，也就是psd中我们量出来的像素，比如说任务中psd图的宽度为750px或者640px</p>
<p>UI口中的像素是移动设备分辨率 </p>
<p><strong>注意事项：</strong> 直接按照UI图上px大小写，会偏大。 因为UI图的px和css中的px不是一个单位，一般来说UI图中大小除以2写在css里</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>手机分辨率和网页中的px不相同，px是一个相对单位，而且在特定设备上总是一个近似值（原则是尽量接近参考像素）。 </p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/jnshu_it/article/details/80055739" target="_blank" rel="noopener">手机分辨率和网页中的px是一回事吗？</a></p>
<p><a href="https://www.zhihu.com/question/21149600" target="_blank" rel="noopener">分辨率和像素是什么关系？</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>什么时候用margin好，什么时候用padding好？</title>
    <url>/2019/10/08/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%833/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8margin%E5%A5%BD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8padding%E5%A5%BD%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>margin始终是透明的；margin是用来隔开元素与元素的间距；</p>
<p>padding是用来隔开元素与内容的间隔。  </p>
<h1 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h1><p>margin用于<strong>布局</strong>分开元素使元素与元素互不相干；  </p>
<p>padding用于<strong>元素与内容之间</strong>的间隔，让内容（文字）与（包裹）元素之间有一段“呼吸距离”，还可以调整边框与内容的距离。</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>css有哪些选择器，优先级如何计算？</title>
    <url>/2019/10/07/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%833/css%E6%9C%89%E5%93%AA%E4%BA%9B%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%8C%E4%BC%98%E5%85%88%E7%BA%A7%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>类别选择器、标签选择器、id选择器、通用选择器、后代选择器、子选择器、伪类选择器、群组选择器、相邻同胞选择器  </p><h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><ol>
<li><p>在属性后面使用！important会覆盖页面内任何位置定义的元素样式。 </p>
</li>
<li><p>作为style属性写在元素内的样式 </p>
</li>
<li><p>id选择器  </p>
</li>
<li><p>类选择器  </p>
</li>
<li><p>标签选择器  </p>
</li>
<li><p>通配符选择器 </p>
</li>
<li><p>浏览器自定义或子元素集成父类的样式  </p>
</li>
</ol><a id="more"></a>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/b69de6742357" target="_blank" rel="noopener">简书</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何进行自适应网页设计？</title>
    <url>/2019/10/07/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%833/%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%87%AA%E9%80%82%E5%BA%94%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="什么是自适应网页设计"><a href="#什么是自适应网页设计" class="headerlink" title="什么是自适应网页设计"></a>什么是自适应网页设计</h1><p>“自适应网页设计”的概念，什么是自适应网页设计，即可以自动识别屏幕宽度、并做出相应调整的网页设计。  </p><h1 id="如何实现自适应网页设计"><a href="#如何实现自适应网页设计" class="headerlink" title="如何实现自适应网页设计"></a>如何实现自适应网页设计</h1><ol>
<li>允许网页宽度自动调整：在网页代码的头部加入一行viewport元标签，宽度为设备宽度，缩放比例为一。 </li>
<li>不使用绝对宽度：可以使用百分比宽度，视窗宽度等，或者width:auto;  </li>
<li>使用相对大小的字体：em、rem  </li>
<li>流动布局：各个区块的位置是浮动的，不是固定不变的 </li>
<li>图片自适应：图片自动缩放 img { max-width: 100%;} </li>
<li>选择加载css：自适应网页设计”的核心，就是CSS3引入的Media Query模块。它的意思就是，自动探测屏幕宽度，然后加载相应的CSS文件。</li>
<li>css中的@media媒体查询规则：同一个CSS文件中，也可以根据不同的屏幕分辨率，选择应用不同的CSS规则。  </li>
</ol><a id="more"></a>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhidao.baidu.com/question/245161275053820324.html?fr=iks&amp;word=%25%2Cvw%2Cwh%2Cvm%B5%A5%CE%BB&amp;ie=gbk" target="_blank" rel="noopener">自适应网页设计</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>px、em、rem、%、vw、wh、vm等单位有什么区别？</title>
    <url>/2019/10/07/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%833/px%E3%80%81em%E3%80%81rem%E3%80%81-%E3%80%81vw%E3%80%81wh%E3%80%81vm%E7%AD%89%E5%8D%95%E4%BD%8D%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<ol>
<li>px：绝对单位，页面按精确像素展示</li>
<li>em：相对单位，基准点为父级元素字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。</li>
<li>rem：相对单位，为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。</li>
<li>%：相对单位，相对于父级元素的百分比宽度</li>
<li>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。<br>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。</li>
<li>vm；css3单位，相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vm<br>举个例子：浏览器高度900px，宽度1200px，取最小的浏览器高度，1 vm = 900px/100 = 9 px。</li>
</ol>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何利用PS切图以及从UI图中获取所需信息？</title>
    <url>/2019/10/07/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%833/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8PS%E5%88%87%E5%9B%BE%E4%BB%A5%E5%8F%8A%E4%BB%8EUI%E5%9B%BE%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%89%80%E9%9C%80%E4%BF%A1%E6%81%AF%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="PS切图"><a href="#PS切图" class="headerlink" title="PS切图"></a>PS切图</h1><h2 id="切片工具"><a href="#切片工具" class="headerlink" title="切片工具"></a>切片工具</h2><p>使用PS中的切片工具进行所需图片的切割，然后点击文件选项卡，选择其中存储为web所用格式即可完成ps切图。</p><h2 id="一键切图"><a href="#一键切图" class="headerlink" title="一键切图"></a>一键切图</h2><p>下载一键切图工具并载入动作，用移动工具选择图层，按F2一键切图。最后选择保存为web所需格式，注意保存为png格式防止出现兼容性问题。  </p><p><strong>下载链接及教程：</strong> <a href="https://www.cnblogs.com/rangzf/p/3279848.html" target="_blank" rel="noopener">前端高效开发之“一键切图”</a></p><a id="more"></a>


<h1 id="获取UI中的信息"><a href="#获取UI中的信息" class="headerlink" title="获取UI中的信息"></a>获取UI中的信息</h1><ol>
<li>各部分之间的距离</li>
<li>文字的字体，字号颜色</li>
<li>背景的颜色（使用取色器）</li>
</ol>
<p><strong>注意事项</strong>：UI图的px和css中的px不是一个单位，一般来说UI图中大小除以2写在css里</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何将代码部署至自己的服务器？</title>
    <url>/2019/10/07/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%832/%E5%A6%82%E4%BD%95%E5%B0%86%E4%BB%A3%E7%A0%81%E9%83%A8%E7%BD%B2%E8%87%B3%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="1-买一个服务器"><a href="#1-买一个服务器" class="headerlink" title="1. 买一个服务器"></a>1. 买一个服务器</h1><h1 id="2-下载filezilla"><a href="#2-下载filezilla" class="headerlink" title="2. 下载filezilla"></a>2. 下载filezilla</h1><h1 id="3-连接自己的服务器，将对应代码上传（全中文页面不再赘述）"><a href="#3-连接自己的服务器，将对应代码上传（全中文页面不再赘述）" class="headerlink" title="3. 连接自己的服务器，将对应代码上传（全中文页面不再赘述）"></a>3. 连接自己的服务器，将对应代码上传（全中文页面不再赘述）</h1>]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何配置nginx，实现在手机上查看页面？</title>
    <url>/2019/10/07/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%832/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEnginx%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%9C%A8%E6%89%8B%E6%9C%BA%E4%B8%8A%E6%9F%A5%E7%9C%8B%E9%A1%B5%E9%9D%A2%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="什么是nginx？"><a href="#什么是nginx？" class="headerlink" title="什么是nginx？"></a>什么是nginx？</h1><p>Nginx（发音同engine x）是异步框架的网页服务器，也可以用作反向代理、负载平衡器和HTTP缓存。该软件由伊戈尔·赛索耶夫创建并于2004年首次公开发布。2011年成立同名公司以提供支持。2019年3月11日，Nginx公司被F5 Networks以6.7亿美元收购。</p><p>Nginx是免费的开源软件，根据类BSD许可证的条款发布。一大部分Web服务器使用Nginx，通常作为负载均衡器。</p><a id="more"></a>

<h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><h2 id="正向代理简介"><a href="#正向代理简介" class="headerlink" title="正向代理简介"></a>正向代理简介</h2><p>一般情况下，如果没有特别说明，代理技术默认说的是正向代理技术。关于正向代理的概念如下：</p>
<p>正向代理(forward)是一个位于客户端【用户A】和原始服务器(origin server)【服务器B】之间的服务器【代理服务器Z】，为了从原始服务器取得内容，用户A向代理服务器Z发送一个请求并指定目标(服务器B)，然后代理服务器Z向服务器B转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。如下图</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hc2sucWNsb3VkaW1nLmNvbS9odHRwLXNhdmUveWVoZS0xMDEwNzkyL3ZyM3B6M292emgucG5n?x-oss-process=image/format,png" alt="img"> </p>
<p>从上面的概念中，我们看出，文中所谓的正向代理就是代理服务器替代访问方【用户A】去访问目标服务器【服务器B】 ，</p>
<p><strong>总结：代理服务器代替了用户A</strong></p>
<h2 id="正向代理的意义"><a href="#正向代理的意义" class="headerlink" title="正向代理的意义"></a>正向代理的意义</h2><p><strong>为什么要用通过代理服务器去访问服务器B，而不是用户直接访问？</strong></p>
<ul>
<li>访问本无法访问的服务器B</li>
<li>加速访问服务器B</li>
<li>Cache（缓存） 作用</li>
<li>客户端访问授权（为什么我们无法直接访问谷歌）</li>
<li>隐藏访问者的行踪（服务器B只知道代理服务器Z访问了它）</li>
</ul>
<h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><h2 id="反向代理简介"><a href="#反向代理简介" class="headerlink" title="反向代理简介"></a>反向代理简介</h2><p>反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。</p>
<p><strong>总结：代理服务器代替了服务器B</strong></p>
<h2 id="反向代理的意义"><a href="#反向代理的意义" class="headerlink" title="反向代理的意义"></a>反向代理的意义</h2><ol>
<li><p>保护和隐藏原始资源服务器<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hc2sucWNsb3VkaW1nLmNvbS9odHRwLXNhdmUveWVoZS0xMDEwNzkyL2xiNmswZzY4ZzUucG5n?x-oss-process=image/format,png" alt="img"> </p>
<p>用户A始终认为它访问的是原始服务器B而不是代理服务器Z，但实用际上反向代理服务器接受用户A的应答，从原始资源服务器B中取得用户A的需求资源，然后发送给用户A。由于防火墙的作用，只允许代理服务器Z访问原始资源服务器B。尽管在这个虚拟的环境下，防火墙和反向代理的共同作用保护了原始资源服务器B，但用户A并不知情。 </p>
</li>
</ol>
<ol start="2">
<li><p>负载均衡<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hc2sucWNsb3VkaW1nLmNvbS9odHRwLXNhdmUveWVoZS0xMDEwNzkyL21kMjFlbzFpenMucG5n?x-oss-process=image/format,png" alt="img"></p>
<p>当反向代理服务器不止一个的时候，我们甚至可以把它们做成集群，当更多的用户访问资源服务器B的时候，让不同的代理服务器Z（x）去应答不同的用户，然后发送不同用户需要的资源。</p>
<p>当然反向代理服务器像正向代理服务器一样拥有CACHE的作用，它可以缓存原始资源服务器B的资源，而不是每次都要向原始资源服务器B请求数据，特别是一些静态的数据，比如图片和文件，如果这些反向代理服务器能够做到和用户X来自同一个网络，那么用户X访问反向代理服务器X，就会得到很高质量的速度。这正是<a href="https://cloud.tencent.com/product/cdn?from=10680" target="_blank" rel="noopener">CDN</a>技术的核心。 </p>
</li>
</ol>
<h1 id="如何配置nginx，实现在手机上查看页面？"><a href="#如何配置nginx，实现在手机上查看页面？" class="headerlink" title="如何配置nginx，实现在手机上查看页面？"></a>如何配置nginx，实现在手机上查看页面？</h1><p>Nginx的配置文件是文件夹中的conf文件下的nginx.conf，其实配置文件默认不修改也是可有用的；</p>
<p>如果你通过浏览器输入localhost出现的页面即为文件夹下HTML文件中的index.html；所以你可以将你想要检测的产品放到HTML文件夹中，并将原本的index.html文件给删了，这个时候打开网页输入localhost，使用ctrl+F5清下浏览器缓存即出现你产品中的index.html(产品的首页都会命名为index.html）页面，然后进行一系列测试看看是否OK；</p>
<p>  如果要使用自己文件夹中的文件测试，需要更改Nginx的配置文件是文件夹中的conf文件下的nginx.conf，修改三处root地址为自己的文件夹所在地址，第一处改为 D:\home\www，第二处改为 /home/www,第三处改为/home/www。</p>
<p><strong>注意事项：</strong>  左斜杠/与右斜杠\的区别不要打错了！</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://cloud.tencent.com/developer/article/1053668" target="_blank" rel="noopener">图解正向代理、反向代理、透明代理</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Nginx#cite_note-8" target="_blank" rel="noopener">维基百科</a></li>
</ul>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何利用github搭建自己的个人网站？</title>
    <url>/2019/10/07/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%832/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="使用github搭建个人网站"><a href="#使用github搭建个人网站" class="headerlink" title="使用github搭建个人网站"></a>使用github搭建个人网站</h1><ol>
<li>在github上搭建网站 即username.github.io（username是你的github用户名）</li>
<li>把自己的域名（如zhangsan.com）绑定到username.github.io上</li>
</ol><p>具体操作：<a href="https://blog.csdn.net/u012075670/article/details/54581015" target="_blank" rel="noopener">如何用github搭建自己的个人网站</a></p><h1 id="用Hexo-Github-搭建个人网站"><a href="#用Hexo-Github-搭建个人网站" class="headerlink" title="用Hexo+Github 搭建个人网站"></a>用Hexo+Github 搭建个人网站</h1><a id="more"></a>

<ol>
<li>搭建环境准备（包括node.js和git环境，gitHub账户的配置）</li>
<li>安装Hexo</li>
<li>配置Hexo</li>
<li>怎样将Hexo与github page 联系起来</li>
<li>怎样发布文章</li>
<li>主题 推荐</li>
<li>主题Net的简单配置</li>
<li>添加sitemap和feed插件</li>
<li>添加404 公益页面</li>
</ol>
<p>具体操作：<a href="https://blog.csdn.net/gdutxiaoxu/article/details/53576018" target="_blank" rel="noopener">手把手教你用Hexo+Github 搭建属于自己的博客</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>svn和git有什么区别?</title>
    <url>/2019/10/07/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%832/svn%E5%92%8Cgit%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="svn与git简介"><a href="#svn与git简介" class="headerlink" title="svn与git简介"></a>svn与git简介</h1><h2 id="SVN-（集中式版本控制系统）"><a href="#SVN-（集中式版本控制系统）" class="headerlink" title="SVN （集中式版本控制系统）"></a><strong>SVN</strong> （集中式版本控制系统）</h2><p>SVN是Subversion的简称，是一个开放源代码的版本控制系统,支持大多数常见的操作系统。作为一个开源的版本控制系统,Subversion管理着随时间改变的数据。这些数据放置在一个中央资料档案库(repository)中。这个档案库很像一个普通的文件服务器,不过它会记住每一次文件的变动。这样你就可以把档案恢复到旧的版本,或是浏览文件的变动历史。Subversion是一个通用的系统,可用来管理任何类型的文件,其中包括了程序源码。</p><a id="more"></a>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><p><a href="http://baike.baidu.com/view/3794518.htm" target="_blank" rel="noopener">集中式管理</a>的工作流程如下图：</p>
<p>   <img src="https://img-blog.csdn.net/20160129151818496" alt="img"></p>
<p>集中式代码管理的核心是<a href="http://baike.baidu.com/view/899.htm" target="_blank" rel="noopener">服务器</a>，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如果脱离了服务器，开发者基本上可以说是无法工作的。下面举例说明：</p>
<p>开始新一天的工作：</p>
<ol>
<li>从服务器下载项目组最新代码。</li>
<li>进入自己的分支，进行工作，每隔一个小时向服务器自己的分支提交一次代码（很多人都有这个习惯。因为有时候自己对代码改来改去，最后又想还原到前一个小时的版本，或者看看前一个小时自己修改了哪些代码，就需要这样做了）。</li>
<li>下班时间快到了，把自己的分支合并到服务器主分支上，一天的工作完成，并反映给服务器。</li>
</ol>
<h3 id="SVN属于集中化的版本控制系统"><a href="#SVN属于集中化的版本控制系统" class="headerlink" title="SVN属于集中化的版本控制系统"></a>SVN属于集中化的版本控制系统</h3><p>​     这种做法带来了许多好处，特别是相较于老式的本地VCS来说。现在，每个人都可以一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限。<br>事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。若是宕机一小时，那么在这一小时内，谁都无法提交更新、还原、对比等，也就无法协同工作。如果中央服务器的磁盘发生故障，并且没做过备份或者备份得不够及时的话，还会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，被客户端提取出来的某些快照数据除外，但这样的话依然是个问题，你不能保证所有的数据都已经有人提取出来。<br>Subversion原理上只关心文件内容的具体差异。每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容。</p>
<h3 id="Subversion的特点"><a href="#Subversion的特点" class="headerlink" title="Subversion的特点"></a>Subversion的特点</h3><ol>
<li>每个版本库有唯一的URL（官方地址），每个用户都从这个地址获取代码和数据；</li>
<li>获取代码的更新，也只能连接到这个唯一的版本库，同步以取得最新数据；</li>
<li>提交必须有网络连接（非本地版本库）；</li>
<li>提交需要授权，如果没有写权限，提交会失败；</li>
<li>提交并非每次都能够成功。如果有其他人先于你提交，会提示“改动基于过时的版本，先更新再提交”… 诸如此类；</li>
<li>冲突解决是一个提交速度的竞赛：手快者，先提交，平安无事；手慢者，后提交，可能遇到麻烦的冲突解决。</li>
</ol>
<h2 id="GIT（分布式版本控制系统）"><a href="#GIT（分布式版本控制系统）" class="headerlink" title="GIT（分布式版本控制系统）"></a>GIT（分布式版本控制系统）</h2><p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目</p>
<p>Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<p>分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库.</p>
<h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><p>下图是经典的git开发过程。</p>
<p><img src="https://img-blog.csdn.net/20160129151822850" alt="img"></p>
<h3 id="Git的功能特性"><a href="#Git的功能特性" class="headerlink" title="Git的功能特性"></a>Git的功能特性</h3><p>从<strong>一般开发者</strong>的角度来看，git有以下功能：</p>
<ol>
<li>从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上。</li>
<li>在自己的机器上根据不同的开发目的，创建分支，修改代码。</li>
<li>在单机上自己创建的分支上提交代码。</li>
<li>在单机上合并分支。</li>
<li>把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。</li>
<li>生成补丁（patch），把补丁发送给主开发者。</li>
<li>看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。</li>
<li>一般开发者之间解决冲突的方法，开发者之间可以使用pull 命令解决冲突，解决完冲突之后再向主开发者提交补丁。</li>
</ol>
<p>从<strong>主开发者</strong>的角度（假设主开发者不用开发代码）看，git有以下功能：</p>
<ol>
<li><p>查看邮件或者通过其它方式查看一般开发者的提交状态。</p>
</li>
<li><p>打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源项目，还要决定哪些补丁有用，哪些不用）。</p>
</li>
<li><p>向公共服务器提交结果，然后通知所有开发人员。 </p>
</li>
</ol>
<h3 id="Git属于分布式的版本控制系统"><a href="#Git属于分布式的版本控制系统" class="headerlink" title="Git属于分布式的版本控制系统"></a>Git属于分布式的版本控制系统</h3><p>​    自2005年诞生于以来，Git日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。它的速度飞快，极其适合管理大项目，它还有着令人难以置信的非线性分支管理系统，可以应付各种复杂的项目开发需求。</p>
<p>   与SVN不同，Git记录版本历史只关心文件数据的整体是否发生变化。Git并不保存文件内容前后变化的差异数据。实际上，Git更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git不会再次保存，而只对上次保存的快照作一连接。</p>
<h3 id="Git特点"><a href="#Git特点" class="headerlink" title="Git特点"></a>Git特点</h3><ol>
<li>Git中每个克隆(clone)的版本库都是平等的。你可以从任何一个版本库的克隆来创建属于你自己的版本库，同时你的版本库也可以作为源提供给他人，只要你愿意。</li>
<li>Git的每一次提取操作，实际上都是一次对代码仓库的完整备份。提交完全在本地完成，无须别人给你授权，你的版本库你作主，并且提交总是会成功。</li>
<li>甚至基于旧版本的改动也可以成功提交，提交会基于旧的版本创建一个新的分支。</li>
<li>Git的提交不会被打断，直到你的工作完全满意了，PUSH给他人或者他人PULL你的版本库，合并会发生在PULL和PUSH过程中，不能自动解决的冲突会提示您手工完成。</li>
<li>冲突解决不再像是SVN一样的提交竞赛，而是在需要的时候才进行合并和冲突解决。</li>
</ol>
<h1 id="svn和git的区别"><a href="#svn和git的区别" class="headerlink" title="svn和git的区别"></a>svn和git的区别</h1><ol>
<li><p>SVN属于集中化的版本控制系统，有个不太精确的比喻:SVN = 版本控制+ 备份服务器SVN使用起来有点像是档案仓库的感觉，支持并行读写文件，支持代码的版本化管理，功能包括取出、导入、更新、分支、改名、还原、合并等。</p>
<p>Git是一个分布式版本控制系统，操作命令包括：clone，pull，push,branch ,merge ,push,rebase，Git擅长的是程序代码的版本化管理。</p>
</li>
<li><p>GIT跟SVN一样有自己的集中式版本库或服务器。但，GIT更倾向于被使用于分布式模式，也就是每个开发人员从中心版本库/服务器上chect out代码后会在自己的机器上克隆一个自己的版本库。</p>
<p>可以这样说，如果你被困在一个不能连接网络的地方时，就像在飞机上，地下室，电梯里等，你仍然能够提交文件，查看历史版本记录，创建项目分支，等。对一些人来说，这好像没多大用处，但当你突然遇到没有网络的环境时，这个将解决你的大麻烦。</p>
</li>
<li><p>GIT把内容按元数据方式存储，而SVN是按文件所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。</p>
<p>如果你把.git目录的体积大小跟.svn比较，你会发现它们差距很大。因为,.git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。</p>
</li>
<li><p>分支在SVN中一点不特别，就是版本库中的另外的一个目录。如果你想知道是否合并了一个分支，你需要手工运行像这样的命令svn propget svn:mergeinfo，来确认代码是否被合并。</p>
<p>然而，处理GIT的分支却是相当的简单和有趣。你可以从同一个工作目录下快速的在几个分支间切换。你很容易发现未被合并的分支，你能简单而快捷的合并这些文件。</p>
</li>
<li><p>GIT没有一个全局的版本号，而SVN有目前为止这是跟SVN相比GIT缺少的最大的一个特征。你也知道，SVN的版本号实际是任何一个相应时间的源代码快照。我认为它是从CVS进化到SVN的最大的一个突破。因为GIT和SVN从概念上就不同，我不知道GIT里是什么特征与之对应。如果你有任何的线索，请在评论里奉献出来与大家共享。</p>
</li>
<li><p>GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 </p>
</li>
</ol>
<h1 id="svn和git的优缺点"><a href="#svn和git的优缺点" class="headerlink" title="svn和git的优缺点"></a>svn和git的优缺点</h1><h2 id="SVN-的优缺点"><a href="#SVN-的优缺点" class="headerlink" title="SVN 的优缺点"></a>SVN 的优缺点</h2><p>​      SVN对中文支持好，操作简单，使用没有难度，美工人员，产品人员，测试人员，实施人员都可轻松上手。使用界面统一，功能完善，操作方便。</p>
<h2 id="Git的优缺点"><a href="#Git的优缺点" class="headerlink" title="Git的优缺点"></a>Git的优缺点</h2><p>​      对程序源代码进行差异化的版本管理，代码库占极少的空间。易于代码的分支化管理。不支持中文，图形界面支持差，使用难度大。不易推广。 </p>
<h1 id="svn和git适用范围的不同"><a href="#svn和git适用范围的不同" class="headerlink" title="svn和git适用范围的不同"></a>svn和git适用范围的不同</h1><ol>
<li><p>适用对象不同。Git适用于参与开源项目的开发者。他们由于水平高，更在乎的是效率而不是易用性。SVN则不同，它适合普通的公司开发团队。使用起来更加容易。</p>
</li>
<li><p>使用的场合不同。Git适用于通过Internet，有多个开发角色的单个项目开发，SVN适合企业内部由项目经理统一协调的多个并行项目的开发。</p>
</li>
<li><p>权限管理策略不同。Git没有严格的权限管理控制，只要有帐号，就可以导出、导入代码，甚至执行回退操作。SVN则有严格的权限管理，可以按组、按个人进行针对某个子目录的权限控制。区分读、写权限。更严格的，不支持回退操作。保证代码永远可以追踪。</p>
</li>
<li><p>分支(branch)的使用范围不一样。Git中，你只能针对整个仓库作branch,而且一旦删除，便无法恢复。而SVN中，branch可以针对任何子目录，它本质上是一个拷贝操作。所以，可以建立非常多、层次性的branch,并且，在不需要时将其删除，而以后需要时只要checkout老的SVN版本就可以了。</p>
</li>
<li><p>基于第三点，Git适用于单纯的软件项目，典型的就是一些开源项目，比如Linux内核、busybox等。相反，SVN擅长多项目管理。比如，你可以在一个SVN仓库中存放一个手机项目的bsp/设计文档/文件系统/应用程序/自动化编译脚本，或者在一个SVN中存放5款手机项目的文件系统。git中必须建立n(项目数)*m（组件数）个仓库。SVN中只需要最多n或者m个就可以了。</p>
</li>
<li><p><strong>Git使用128位ID作为版本号</strong>，而且checkout时要注明是哪个branch,而SVN使用一个递增的序列号作为全局唯一的版本号，更加简明易懂。虽然可以使用gittag来建立一些文字化的别名，但是毕竟那只是针对特殊版本。</p>
</li>
<li>可跟踪性，git的典型开发过程为：建立分支，进行开发，提交到本地master，删除分支。这样做的后果是以前的修改细节会丢失。而在SVN下做同样的事情，不会丢失任何细节。这里是一个有趣的链接，表明了git下典型的工作方式：（以master为核心，不断创建新branch,删除旧branch)</li>
<li>局部更新，局部还原。SVN由于是在每个文件夹建立一个.svn文件夹来实现管理，所以可以很简单实现局部更新或者还原。假如你只希望更新某些部分，则svn可以很好实现。同时代码写错了，同时可以很好实现局部还原，当然git也可以通过历史版本还原，但是无法简单地实现局部还原。</li>
</ol>
<h1 id="SVN-和-Git-哪个更适用于项目管理？"><a href="#SVN-和-Git-哪个更适用于项目管理？" class="headerlink" title="SVN 和 Git 哪个更适用于项目管理？"></a>SVN 和 Git 哪个更适用于项目管理？</h1><p>​      首先说一下，我是一个研发团队的项目经理，SVN和Git我都用过，SVN更适用于项目管理， Git仅适用于代码管理。</p>
<p>​     一个研发队伍的成员正常包括：需求分析、设计、美工、程序员、测试、实施、运维，每个成员在工作中都有产出物，  包括了文档、设计代码、程序代码，这些都需要按项目集中进行管理的。SVN能清楚的按目录进行分类管理， 使项目组的管理处于有序高效的状态。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> <strong>总之，公司的开发团队在进行的项目开发管理时，svn是更好的选择，团队成员共同维护公司的中心版本。</strong></p>
<p><strong>若是开源项目，则git更加适合，每个人都可以维护自己专属的版本，同时有github开源社区支持。</strong></p>
<h1 id="参考和转载"><a href="#参考和转载" class="headerlink" title="参考和转载"></a>参考和转载</h1><p>伯乐在线:<a href="http://blog.jobbole.com/31444/" target="_blank" rel="noopener">http://blog.jobbole.com/31444/</a></p>
<p>百度百科:<a href="http://baike.baidu.com/" target="_blank" rel="noopener">http://baike.baidu.com</a></p>
<p>marko39:<a href="http://jingyan.baidu.com/article/676629976401a154d51b8430.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/676629976401a154d51b8430.html</a></p>
<p>码迷网:<a href="http://www.mamicode.com/info-detail-107111.html" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-107111.htm</a></p>
<p>百度百科:<a href="http://baike.baidu.com/" target="_blank" rel="noopener">http://baike.baidu.com</a></p>
<p>marko39:<a href="http://jingyan.baidu.com/article/676629976401a154d51b8430.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/676629976401a154d51b8430.html</a></p>
<p>码迷网:<a href="http://www.mamicode.com/info-detail-107111.html" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-107111.htm</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何使用git将代码上传至github?</title>
    <url>/2019/10/07/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%832/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8git%E5%B0%86%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E8%87%B3github/</url>
    <content><![CDATA[<blockquote>
<p>代码开发在大多数情况下不是一个人的工作，那么不同人之间如何统一代码共同进行项目开发呢。git 是一款分布式版本控制系统，本文简要介绍了git的基本应用。</p>
</blockquote>
<a id="more"></a>
<h1 id="git是什么？"><a href="#git是什么？" class="headerlink" title="git是什么？"></a>git是什么？</h1><p>Git是一款分布式版本控制系统 </p>
<h1 id="github是什么？"><a href="#github是什么？" class="headerlink" title="github是什么？"></a>github是什么？</h1><p>GitHub是一款免费的远程仓库 </p>
<h1 id="如何使用git将代码上传至github？"><a href="#如何使用git将代码上传至github？" class="headerlink" title="如何使用git将代码上传至github？"></a>如何使用git将代码上传至github？</h1><p>关于如何安装git，如何使用git将代码上传至github，廖雪峰的教程已经相当完善且浅显易懂了，我在此不再赘述。</p>
<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067008724000" target="_blank" rel="noopener">廖雪峰的git教程</a></p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何用TortoiseSVN将项目代码提交到SVN?</title>
    <url>/2019/10/07/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%832/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8svn%E5%B0%86%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E8%87%B3github/</url>
    <content><![CDATA[<blockquote>
<p>代码开发在大多数情况下不是一个人的工作，那么不同人之间如何统一代码共同进行项目开发呢。Subversion 是一种跨平台的开源版本控制系统，本文简要介绍了svn的基本应用。</p>
</blockquote>
<a id="more"></a>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><p>导引</p>
</li>
<li><p>安装Subversionn</p>
</li>
<li><p>安装TortoiseSVN</p>
</li>
<li><p>一步步地操作</p>
<ol>
<li>设置全局忽略文件类型(此步骤为可选)步骤</li>
<li>创建版本库<strong>Repository</strong>数据库</li>
<li>创建工作目录 -  将你的项目与数据库连接起来</li>
<li>添加忽略</li>
</ol>
</li>
<li><p>注意事项</p>
</li>
<li><p>参考资料</p>
</li>
</ul>
<h1 id="导引"><a href="#导引" class="headerlink" title="导引"></a>导引</h1><p> 到目前有很多关于Subversion (SVN) 和 TortoiseSVN的优秀书籍和教程。其中有部分在本文的参考资料区有列出。这篇教程无疑是站在巨人的肩膀上。它只覆盖了subversion (SVN)有限的一部分功能。 然而我希望此文能简化你对SVN的认识。</p>
<p>Subversion 是一种跨平台的开源版本控制系统 (<a href="http://subversion.tigris.org/" target="_blank" rel="noopener">http://subversion.tigris.org/</a>).  它由版本数据库 (FSFS 或 BDB) 和一些命令行工具组成。目前有各种各样的SVN前端工具。</p>
<p>Subversion是为多人参与的项目专门设计的。 但它也可用于管理个人项目。</p>
<p>此文仅限于基于<strong>Windows的本地SVN环境</strong>(未单独配置远程的服务器)。</p>
<h1 id="安装Subversion"><a href="#安装Subversion" class="headerlink" title="安装Subversion"></a>安装Subversion</h1><p>打开Tigris.org网站的下载区，选择 开源代码软件工程工具Subversion (<a href="http://subversion.tigris.org/" target="_blank" rel="noopener">http://subversion.tigris.org/</a>)。 Windows下最新的命令行版Subversion的安装文件和库都能在<a href="http://www.open.collab.net/downloads/subversion/" target="_blank" rel="noopener">http://www.open.collab.net/downloads/subversion/</a>下载到。下载安装包。SVN的默认安装目录为C:\Program Files\Subversion，当然你也可以修改磁盘路径。</p>
<p>现在你就可以开始使用SVN了。 如果你不习惯使用命令行工具，那你有必要安装一个你觉得合适的GUI前端。</p>
<h1 id="安装TortoiseSVN"><a href="#安装TortoiseSVN" class="headerlink" title="安装TortoiseSVN"></a>安装TortoiseSVN</h1><p>TortoiseSVN是一种Subversion客户端, Windows下它是一个命令行扩展, Windows资源管理器的一个插件(<a href="http://tortoisesvn.tigris.org/" target="_blank" rel="noopener">http://tortoisesvn.tigris.org/</a>)。</p>
<p>最新版本可以在这下载到 <a href="http://tortoisesvn.sourceforge.net/downloads" target="_blank" rel="noopener">http://tortoisesvn.sourceforge.net/downloads</a>. 截止到2015.12.18的最新版本为：TortoiseSVN-1.9.2.26806-x64-svn-1.9.2.msi，如果需要切换语言，还可以在官网上下载相应语言包。</p>
<p>如果你电脑安装的Windows是32位的请选择32位的TortoiseSVN安装包，如果你电脑安装的Windows是x64的请选择x64的TortoiseSVN安装包。 下载区域的另一个文件TortoiseSVN-xxx-xxx.md5, 是安装时不需要的。它包含安装包的验证编号checksum，该验证编号能有效验证你是否下载到了合适的安装包 (且它没有损坏)。</p>
<p>你可以下载程序HashFile (<a href="http://www.shokhirev.com/nikolai/programs/progmisc.html" target="_blank" rel="noopener">http://www.shokhirev.com/nikolai/programs/progmisc.html</a>) 来验证下载到的安装包的 MD5 哈希值 (checksum). 该验证编号必须和TortoiseSVN-xxx-xxx.md5文件上的信息完全一致。</p>
<p>这个安装也是直接的，同意默认设置即可。 唯一有趣的是ASP.Net hack. 默认情况下, SVN 使用 .svn 工作目录 (正如Linux下隐藏文件的命名风格)。<br><img src="https://img-blog.csdn.net/20180423144822210" alt="img"><br>这使得 微软 ASP.Net 和 the hack 强制 SVN 去使用  _svn 作为工作目录。 如果你要使用Subversion对ASP.Net项目进行版本控制，请不要安装ASP.Net hack这一项。</p>
<p>注： 安装完TortoiseSVN后，你的Windows 资源管理器的主目录上会出现下图所示的新的按钮：</p>
<p> <img src="https://img-blog.csdn.net/20151218142852404?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"><br>同时这些新增按钮也会添加到 (通过鼠标右键单击激活) 的上下文菜单中。</p>
<h1 id="一步步地操作"><a href="#一步步地操作" class="headerlink" title="一步步地操作"></a>一步步地操作</h1><p>目前有很多Subversion管理方式(参看手册). 现在我们主要考虑如下主要的情形: </p>
<ul>
<li>你有一个现有的项目，你想将它加入版本控制。</li>
<li>这是你本地电脑上的个人项目。</li>
</ul>
<p>在这种情形下你不应该会担心安全性和开启一个subversion服务器。</p>
<p>假设你的项目驻放在 C:\Projects\MyProject 路径下，它包含如下文件，或许还有些子文件夹：</p>
<p><img src="https://img-blog.csdn.net/20151218143815197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img">   </p>
<h2 id="步骤0-可选-设置全局忽略文件类型。"><a href="#步骤0-可选-设置全局忽略文件类型。" class="headerlink" title="步骤0 (可选). 设置全局忽略文件类型。"></a>步骤0 (可选). 设置全局忽略文件类型。</h2><p>你可能不想跟踪临时文件 或  某些其他格式的文件。鼠标右击任意一个文件夹，然后打开TortoiseSVN的Settings：</p>
<p><img src="https://img-blog.csdn.net/20151218142928353?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"><br>当然你也可以鼠标右击文件， 打开Windows资源管理器主目录中的TortoiseSVN/Settings。<br><img src="https://img-blog.csdn.net/20151218142945655?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"><br>“General” -&gt; “Subversion”处，你可以列出各种各样的文件类型，并使用空格隔开 (比如上图中示例的 <code>*.bak *.~*</code>). 注意到这个设置会对所有的工作目录有效。参看手册的5.25可了解更多的设置。</p>
<h2 id="步骤1-创建版本库Repository。"><a href="#步骤1-创建版本库Repository。" class="headerlink" title="步骤1.创建版本库Repository。"></a>步骤1.创建版本库Repository。</h2><p>在你的硬盘上为你的项目创建版本库的目录, 比如 C:\SVN. 在它里面创建一个空的子目录 \MyProject. 鼠标右键点击MyProject，并选择TortoiseSVN -&gt; 在此创建版本库:</p>
<p><img src="https://img-blog.csdn.net/20151218143011950?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"> </p>
<p>选择默认”原生文件系统”(FSFS)选项，并单击OK按钮：</p>
<p><img src="https://img-blog.csdn.net/20151218143024077?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"> </p>
<p>这一步将 C:\SVN\MyProject 转化为含有如下内容的版本库：</p>
<p><img src="https://img-blog.csdn.net/20151218143053878?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"> </p>
<p>到目前为止，它还是一个空的版本库，虽然Subversion已经创建了几个目录和文件 ! 我们需要将我们的项目文件中需要进行版本控制的文件填充进去并将它链接到我们的工作项目的目录。这些操作中可能会有几个和大家的习惯操作不一样、新的操作。</p>
<h2 id="步骤2-导入初始化。"><a href="#步骤2-导入初始化。" class="headerlink" title="步骤2. 导入初始化。"></a>步骤2. 导入初始化。</h2><p> 在你的磁盘的某处 (比如 在 C:\tmp) 创建一个目录 (比如 \new) ，含有如下3个子目录：<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\tmp\new\branches </span><br><span class="line">C:\tmp\new\tags    </span><br><span class="line">C:\tmp\new\trunk</span><br></pre></td></tr></table></figure></p>
<p>相应的文件结构为：</p>
<p><img src="https://img-blog.csdn.net/20151218143332531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"> </p>
<p>为了能用更多高级的项目管理功能，这个结构是必须的, 如果事先创建它也不会带来什么损害。 有些手册首推先导入此结构到版本库，然后向里面添加项目。我推荐使用如下的快捷方式：</p>
<ul>
<li>备份你的项目文件 (比如 C:\Projects\MyProject), 以防万一.</li>
<li>删除所有不在全局忽略文件列表中的不需要进行版本控制的文件。</li>
<li>将 文件夹 \MyProject 中需要进行版本控制的内容 移动 进 trunk 子目录 (C:\tmp\new\trunk). 我们之后无论如何都将会需要一个空的文件夹。</li>
<li>将目录”new”导入Import到版本库 (选择”new”，右键依次单击TortoiseSVN-&gt;Import)：</li>
</ul>
<p>URL 选择 file:///C:/SVN/Myproject (左斜杠”/“ !):</p>
<p><img src="https://img-blog.csdn.net/20151218143348048?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"> </p>
<p>“Import finished” 消息出现时，表明 C:\tmp\new\下的所有文件及子文件夹都已成功导入版本库 :</p>
<p><img src="https://img-blog.csdn.net/20151218143351826?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"> </p>
<p>不需要担心”tmp\new” 消息, 只要验证哪些文件真正地导入到了版本库中即可。 书表右键单击 C:\SVN\MyProject ，然后打开 TortoiseSVN -&gt; Repo-browser(版本库浏览器)：</p>
<p><img src="https://img-blog.csdn.net/20151218143356202?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"> </p>
<p>导航 至 file///C:/SVN/MyProject/trunk:</p>
<p><img src="https://img-blog.csdn.net/20151218143400685?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"><br>注意到全局忽略列表的文件都没被导入。 并且也没有 ‘C:\tmp\new’ 目录的痕迹了， ‘C:\tmp\new’ 目录再没有什么用处了，可以删掉。</p>
<h2 id="步骤3-创建工作目录-将你的项目与数据库连接起来"><a href="#步骤3-创建工作目录-将你的项目与数据库连接起来" class="headerlink" title="步骤3. 创建工作目录 -  将你的项目与数据库连接起来."></a>步骤3. 创建工作目录 -  将你的项目与数据库连接起来.</h2><p>现在你已经成功增加了你对所有需要进行版本控制的文件添加了版本控制，并且当前的空目录 C:\Projects\MyProject (回忆一下, 我们之前已将改目录中的所有文件 移动 到了 目录 C:\tmp\new\trunk 中，对么?). “为了让你的双手移动文件的这个行为获得”赞美”, 完全得到批准, 并且完全导入Subversion目录, 你需要从版本库中对它进行检出Checkout” . 书表右击 C:\Projects\MyProject 文件夹，并选择 “<strong>SVN Checkout”(SVN 检出)</strong>:</p>
<p><img src="https://img-blog.csdn.net/20151218143405371?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"> </p>
<p>设置 URL 为 file:///C:/SVN/MyProject/trunk ，并设置检出目录为： C:\Projects\MyProject</p>
<p><img src="https://img-blog.csdn.net/20151218143409839?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"> </p>
<p>点击OK. 会提示”Checkout (检出) has finished”：</p>
<p><img src="https://img-blog.csdn.net/20151218143413848?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"> </p>
<p>“赞美” 以”对勾Check”小图标的形式反映在你的项目目录和里面所有的文件(和所有的子目录)上。</p>
<h2 id="步骤4-添加忽略的文件"><a href="#步骤4-添加忽略的文件" class="headerlink" title="步骤4.添加忽略的文件"></a><strong>步骤4.添加忽略的文件</strong></h2><p>在资源管理器中，右键一个未加入版本控制文件或目录，并从弹出菜单选择TortoiseSVN →Add to Ignore List，会出现一个子菜单，允许你仅选择该文件或者所有具有相同后缀的文件。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDExMTAvMjUvMF8xMzE5NTI4NjQ2UVN2MS5naWY" alt="img"> </p>
<p>如果你想从忽略列表中移除一个或多个条目，右击这些条目，选择TortoiseSVN →从忽略列表删除。</p>
<h1 id="几点注意事项"><a href="#几点注意事项" class="headerlink" title="几点注意事项"></a>几点注意事项</h1><ul>
<li>提交 (checking in) 你对版本库的变更: 右击鼠标，然后选择 “SVN Commit”(SVN提交)添加文件到版本库。</li>
<li>除了参考书籍 [<a href="http://www.shokhirev.com/nikolai/programs/SVN/svn.html#svnbook" target="_blank" rel="noopener">4</a>] 和 [<a href="http://www.shokhirev.com/nikolai/programs/SVN/svn.html#guide" target="_blank" rel="noopener">5</a>], 我也推荐 Charlie Calvert 的文章 [<a href="http://www.shokhirev.com/nikolai/programs/SVN/svn.html#Charlie" target="_blank" rel="noopener">6</a>].</li>
<li>如果你使用 <a href="http://www.lavasoft.com/news/product/google.shtml" target="_blank" rel="noopener">Lavasoft Ad-Aware</a>, 不要删除可以忽略的对象: 这一步会删除注册表中的图标设置 !</li>
<li>祝开开心心 使用Subversion版本控制 !</li>
<li>这是一个两步的过程:<ol>
<li>先右击选中的文件，然后右键依次选择 “TortoiseSVN”-&gt;”Add”</li>
<li>先右击选中的文件，然后右键依次选择 “TortoiseSVN”-&gt;”SVN Commit”</li>
</ol>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/lzuacm/article/details/50347365" target="_blank" rel="noopener">如何用TortoiseSVN将项目代码提交到SVN</a></p>
<hr>
<blockquote>
<p>原作者: Bravo Yeung<br>公众号: dotNET匠人</p>
</blockquote>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>Adobe Photoshop CC  ps 2019中文版Win/Mac破解教程</title>
    <url>/2019/10/07/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/PS%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B2019/</url>
    <content><![CDATA[<h1 id="使用破解补丁（Win-Mac通用）"><a href="#使用破解补丁（Win-Mac通用）" class="headerlink" title="使用破解补丁（Win/Mac通用）"></a>使用破解补丁（Win/Mac通用）</h1><ol>
<li><p>下载原版软件<br>Adobe Creative Cloud平台下载正版渠道的Photoshop CC 2019（即V20版本）</p>
</li>
<li><p>下载破解软件<br>ZII目前可以破解的软件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Adobe Acrobat DC 19.x (universal amtlib)</span><br><span class="line">Adobe After Effects CC 2019 v16.1 – 16.1.3</span><br><span class="line">Adobe Animate CC 2019 v19.2 – 19.2.1</span><br><span class="line">Adobe Audition CC 2019 v12.1 – 12.1.4</span><br><span class="line">Adobe Bridge CC 2019 v9.0.3 – 9.1</span><br><span class="line">Adobe Character Animator CC 2019 v2.1 – 2.1.1</span><br><span class="line">Adobe Dimension CC v2.3</span><br><span class="line">Adobe Dreamweaver CC 2019 v19.1 – 19.2.1</span><br><span class="line">Adobe Illustrator CC 2019 v23.0.3 – 23.1</span><br><span class="line">Adobe InCopy CC 2019 v14.0.2</span><br><span class="line">Adobe Indesign CC 2019 v14.0.2 – 14.0.3.433</span><br><span class="line">Adobe Lightroom Classic v8.2.1 – 8.4.1</span><br><span class="line">Adobe Media Encoder CC 2019 v13.1 – 13.1.5</span><br><span class="line">Adobe Photoshop CC 2019 v20.0.4 – 20.0.6</span><br><span class="line">Adobe Prelude CC 2019 v8.1 – 8.1.1</span><br><span class="line">Adobe Premiere Pro CC 2019 v13.1 – 13.1.5</span><br><span class="line">Adobe Premiere Rush CC v1.1 – 1.2.5</span><br><span class="line">Adobe XD v21.0.12.11 – 22.5.12.1</span><br></pre></td></tr></table></figure>
</li>
</ol><a id="more"></a>
<p><a href="http://www.gfxcamp.com/zii-2019/" target="_blank" rel="noopener">Adobe CC 2019 Win/Mac通用破解补丁 Zii v4.4.4 + GenP v1.5.6.2</a></p>
<h1 id="直接下载破解版软件（仅win可用）"><a href="#直接下载破解版软件（仅win可用）" class="headerlink" title="直接下载破解版软件（仅win可用）"></a>直接下载破解版软件（仅win可用）</h1><p><a href="http://www.gfxcamp.com/ps-cc-2019/" target="_blank" rel="noopener">Adobe Photoshop CC 2019 v20.0.6 Win/Mac 中文/英文/多语言破解版</a></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title>太吾绘卷大型攻略</title>
    <url>/2019/03/09/%E6%B8%B8%E6%88%8F%E6%94%BB%E7%95%A5/%E5%A4%AA%E5%90%BE%E7%BB%98%E5%8D%B7%E5%A4%A7%E5%9E%8B%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g17bmao6g0j30np09q412.jpg" alt=""></p>
<p><strong>摘要:</strong> 本攻略以太吾绘卷人物创建到人物死亡的顺序介绍了游戏的基本机制与玩法,旨在帮助初次体验太吾绘卷的玩家迅速融入游戏谱写属于自己的江湖绘卷.</p>
<p><strong>关键词:</strong> 太吾绘卷 游戏机制 基本玩法  游戏攻略</p>
<a id="more"></a>
<p>《太吾绘卷》是一款以神话和武侠为题材的独立游戏。玩家将扮演“太吾氏传人”，在以古代中国为背景的架空世界中，通过一代又一代传人的努力和牺牲，最终击败强大的宿敌，决定人世的命运。</p>
<p>游戏采取了类似沙盒游戏的开放世界系统。玩家创建的每一个“太吾世界”，都将是独一无二的随机地图，以及完全随机生成的NPC和敌人，玩家可从15个门派和几乎所有NPC人物中学习武艺和技能。另外，该游戏的NPC之间也有着复杂的关系，玩家可以与他们结成各种各样的关系，甚至直接决定NPC的生死。除传统RPG玩法外《太吾绘卷》还融合了许多不同的玩法，如Roguelike、斗蟋蟀以及建造、经营、管理等。</p>
<p>目前《太吾绘卷》还处于开发阶段,游戏中基本没有对新手的引导以及对玩法机制的解释,导致游戏过于硬核.不便于新手玩家体验游戏,本攻略以太吾绘卷人物创建到人物死亡的顺序介绍了游戏的基本机制与玩法,旨在帮助初次体验太吾绘卷的玩家迅速融入游戏谱写属于自己的江湖绘卷.</p>
<h1 id="一-相枢降世入轮回"><a href="#一-相枢降世入轮回" class="headerlink" title="一.相枢降世入轮回"></a>一.相枢降世入轮回</h1><h2 id="1-人物创建"><a href="#1-人物创建" class="headerlink" title="1 人物创建"></a>1 人物创建</h2><h3 id="1-1处事立场"><a href="#1-1处事立场" class="headerlink" title="1.1处事立场"></a>1.1处事立场</h3><h4 id="1-1-1处事立场概述"><a href="#1-1-1处事立场概述" class="headerlink" title="1.1.1处事立场概述"></a>1.1.1处事立场概述</h4><p><strong>简易总结: 新手建议选择中庸或者仁善,以便获得更好的游戏体验.</strong></p>
<p>处世立场（Attitude）决定角色在世界中待人处事的方式。</p>
<p>每一个角色都拥有一种处世立场。玩家可以在创建自己的角色时选择立场，在人物面板中可以查看其处世立场，立场相差越大的角色越难以相处.</p>
<p>立场并不只有五个孤立的取值，而是连续的数轴，创建角色时可以拖动滑块来自定义更细的倾向；在游戏内选择不符合自身立场的选项时，角色的立场值会随着移动，表现出的立场类型可能改变.</p>
<h4 id="1-1-2处事立场的改变"><a href="#1-1-2处事立场的改变" class="headerlink" title="1.1.2处事立场的改变"></a>1.1.2处事立场的改变</h4><p>与然山派青琅主互动（需好感达到或超过融洽）,可消耗30点地区恩义,改变主角或同道的立场.</p>
<h4 id="1-1-3处事立场的作用"><a href="#1-1-3处事立场的作用" class="headerlink" title="1.1.3处事立场的作用"></a>1.1.3处事立场的作用</h4><p><strong>玩家角色立场作用</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">立场选项</th>
<th style="text-align:center">被索要物品</th>
<th style="text-align:center">清理外道巢穴</th>
<th style="text-align:center">救助入魔人</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">刚正</td>
<td style="text-align:center">大量降低好感；若对方名誉为负，则增加名誉</td>
<td style="text-align:center">地区恩义额外+1、所在地图所有城镇安定+1</td>
<td style="text-align:center">被救助者入魔值清零</td>
</tr>
<tr>
<td style="text-align:center">仁善</td>
<td style="text-align:center">好感无变化，根据对方名誉增减名誉</td>
<td style="text-align:center">所在地图所有城镇文化+1</td>
<td style="text-align:center">加大量好感度</td>
</tr>
<tr>
<td style="text-align:center">中庸</td>
<td style="text-align:center">少量降低好感</td>
<td style="text-align:center">所在地图所有城镇文化+1、安定+1</td>
<td style="text-align:center">被救助者名誉置中（默默无闻）</td>
</tr>
<tr>
<td style="text-align:center">叛逆</td>
<td style="text-align:center">大量降低好感，根据对方名誉反向增减名誉</td>
<td style="text-align:center">获得银钱和威望</td>
<td style="text-align:center">丢下失心人不管，失心人仍在原地</td>
</tr>
<tr>
<td style="text-align:center">唯我</td>
<td style="text-align:center">大量降低好感，根据对方名誉反向增减名誉</td>
<td style="text-align:center">获得新的同道；该同道固定拥有被逼屈从特性，每年好感-60</td>
<td style="text-align:center">杀掉失心人且不会被寻仇</td>
</tr>
</tbody>
</table>
<blockquote>
<p>立场相同对人物与NPC的关系有促进作用，对立立场容易结仇；刚正、仁善立场在对话时不太会与NPC结仇，也容易提升好感度，但是同样也不可以作恶；中庸立场与任何立场的人都不会结仇叛逆、唯我立场，虽然自身利益方面会有收益，但是极为容易与NPC结仇，带来后续关系链的麻烦；</p>
</blockquote>
<p><strong>npc立场影响</strong></p>
<ul>
<li>立场影响闲聊行为的结果：立场相同的角色闲聊时增加大量好感，处世立场不合的角色闲聊时会增加少量好感。 </li>
<li>玩家在门派内寻求支持时，不同立场的角色提出的要求不尽相同 </li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">立场</th>
<th style="text-align:center">对应要求</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">刚正</td>
<td style="text-align:center">接下五招：进行切磋，获胜，或在对方使用第五个攻击功法之后仍然未被击败</td>
</tr>
<tr>
<td style="text-align:center">仁善</td>
<td style="text-align:center">在较艺中获胜</td>
</tr>
<tr>
<td style="text-align:center">中庸</td>
<td style="text-align:center">赠送对银钱(身份越高,所需银钱越多)</td>
</tr>
<tr>
<td style="text-align:center">叛逆</td>
<td style="text-align:center">关系达到喜爱/亲密（视对方身份品级而定）</td>
</tr>
<tr>
<td style="text-align:center">唯我</td>
<td style="text-align:center">在切磋中获胜</td>
</tr>
</tbody>
</table>
<h3 id="1-2-外表相貌"><a href="#1-2-外表相貌" class="headerlink" title="1.2 外表相貌"></a>1.2 外表相貌</h3><h4 id="1-2-1-外表相貌概述"><a href="#1-2-1-外表相貌概述" class="headerlink" title="1.2.1 外表相貌概述"></a>1.2.1 外表相貌概述</h4><p><strong>简易总结: 五官选择后三分之一选项,善用sl,获取龙姿/凤仪以及以上的相貌.</strong></p>
<p>只有第一代太吾可以选择自己的相貌,小孩的五官部件在爸妈的对应器官之间随机。 所以使用修改器的也会按照基本法.</p>
<p>####1.2.2 外表相貌与魅力值的关系</p>
<ol>
<li><p>魅力与长相有关，准确说跟眼睛、鼻子、嘴巴、眉毛、特征5个五官部件有关，跟头发无关。</p>
</li>
<li><p>每种五官的所有选项都被分为三类，丑，中和美。每个器官按照等级有不同评分。按照五官序号的从小到大，前1/3为丑，中间1/3为中等，后1/3为美。如下表:</p>
</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g0wpfm18j3j315e06bweh.jpg" alt="五官评分表"></p>
<ol start="3">
<li>按照评分所在区间，魅力值会在对应的区间内随机产生。最高档范围是500-900。也即[出众]～[天人]。其中(在无额外特质魅力加成情况下)随机到天人的概率为1/400。如下表：</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g0wpe4osgtj315604w745.jpg" alt="魅力等级表"></p>
<blockquote>
<p>本攻略并非原创,NGA-UID:157403-<a href="https://bbs.nga.cn/read.php?&amp;tid=15197500&amp;rand=998" target="_blank" rel="noopener"> 魅力捏脸手册 {09/30 更新：补充少量有关生孩子的机制} </a></p>
</blockquote>
<h4 id="1-2-3外表相貌的作用"><a href="#1-2-3外表相貌的作用" class="headerlink" title="1.2.3外表相貌的作用"></a>1.2.3外表相貌的作用</h4><ul>
<li>外表相貌在太吾绘卷中会影响游戏中的人物对你的初始好感度</li>
<li>外表相貌会影响某些功法的特殊效果<br>eg: 璇女派九品绝技正练-魅力越高,敌方攻速越慢</li>
</ul>
<h3 id="1-3-出生特质"><a href="#1-3-出生特质" class="headerlink" title="1.3 出生特质"></a>1.3 出生特质</h3><ul>
<li><p>角色进入游戏后的属性资质均为一个范围内随机。</p>
</li>
<li><p>角色拥有总共最多10点特质点数可分配在经历、财富、技艺三大分支，帮助角色获得某些方面的优势。 </p>
</li>
</ul>
<p><strong>简易总结: 如果追求资质高突破阅读容易可以主技艺；如果追求经营可以主财富；如果追求属性可以主经历；如果你追求后期完美无缺，那么白蛇和盛世的效果是不能依靠反复投胎刷档和后期努力得到的。</strong></p>
<h3 id="1-4-出生地区"><a href="#1-4-出生地区" class="headerlink" title="1.4 出生地区"></a>1.4 出生地区</h3><p>本选项会影响玩家所在太吾村的地点，并根据出生地区门派特定，会略微影响人物属性。</p>
<p>建议在此处选择你想优先拜入的门派，查看好各个门派的功法及其需求，规划好角色学武路线，好让出身特质和之后的资质对话中让角色获得正确的增益。 </p>
<blockquote>
<p>出身地对人物属性加成的具体影响, <a href="https://tieba.baidu.com/p/5897034537?see_lz=1" target="_blank" rel="noopener">有关创建人物[太吾绘卷吧]_百度贴吧</a></p>
</blockquote>
<h3 id="1-5-出生时节"><a href="#1-5-出生时节" class="headerlink" title="1.5 出生时节"></a>1.5 出生时节</h3><p><strong>简要总结:新手建议选择处暑出生,方便读书.</strong></p>
<p>太吾绘卷,中出生在不同的时节会获得不同的属性天赋,具体加成见下表:</p>
<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g0wqxss1xxj30ky0l2gm5.jpg" alt="出生时节表"></p>
<h2 id="2-人物特性"><a href="#2-人物特性" class="headerlink" title="2 人物特性"></a>2 人物特性</h2><p><strong>简要总结:善用sl,获得天元一气/绝世奇才/良材美玉特性</strong></p>
<h3 id="2-1人物特性概述"><a href="#2-1人物特性概述" class="headerlink" title="2.1人物特性概述"></a>2.1人物特性概述</h3><ul>
<li>人物会随机获得各种特性。</li>
<li>人物特性栏显示的为当前人物的特性，蓝色为正面特性，红色为负面特性，白色为中立特性。每个特性在鼠标放置上方之后会显示详细说明。</li>
<li>特性中剑图标在战斗中会为队友提供攻击方面受益，盾图标会在战斗中提供防御方面收益，圆形图标会在战前提供计略。</li>
</ul>
<blockquote>
<p>某些特性可以遗传,此方面内容将在太吾遗传学中详细说明,此处不再赘述.</p>
</blockquote>
<h3 id="2-2特性的改变"><a href="#2-2特性的改变" class="headerlink" title="2.2特性的改变"></a>2.2特性的改变</h3><ul>
<li>已有特性的等级只能通过璇女派的门派互动更改</li>
<li>角色有时会因为各种事件获得额外的特性。eg: 身怀六甲(通过与配偶春宵一刻),经文祝祷(通过僧人衣服的互动,此特性可遗传)</li>
</ul>
<h3 id="2-3特性的作用"><a href="#2-3特性的作用" class="headerlink" title="2.3特性的作用"></a>2.3特性的作用</h3><ul>
<li>人物的特性影响战斗时机略的使用，并且决定他们的进攻、防守倾向。 在战斗和较艺的准备阶段，玩家可以通过消耗一定的机略点数来采用不同的机略，如喝茶/使用药品，决定开局时敌我双方的距离，影响我方或敌方的同伴的出手频率、守御值、专注上升速度、逃跑概率等。</li>
<li>影响角色的人物属性、七元赋性等数值</li>
</ul>
<h3 id="2-4特性的遗传"><a href="#2-4特性的遗传" class="headerlink" title="2.4特性的遗传"></a>2.4特性的遗传</h3><ul>
<li>父母共同拥有的特性必定会遗传</li>
<li>神锋敛彩,璞玉韬光,经文祝祷只要父母单方面拥有即可遗传</li>
</ul>
<h3 id="2-4人物特性预览"><a href="#2-4人物特性预览" class="headerlink" title="2.4人物特性预览"></a>2.4人物特性预览</h3><p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g0wruaj842j31jhcn0nph.jpg" alt="人物特性大全"></p>
<blockquote>
<p>此图来自百度贴吧-摇光为星-<a href="https://tieba.baidu.com/p/5900568013" target="_blank" rel="noopener">全特性效果总会图</a></p>
</blockquote>
<h2 id="3-人物属性"><a href="#3-人物属性" class="headerlink" title="3 人物属性"></a>3 人物属性</h2><h3 id="3-1年龄与健康"><a href="#3-1年龄与健康" class="headerlink" title="3.1年龄与健康"></a>3.1年龄与健康</h3><h4 id="3-1-1-年龄与健康概述"><a href="#3-1-1-年龄与健康概述" class="headerlink" title="3.1.1 年龄与健康概述"></a>3.1.1 年龄与健康概述</h4><p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g17c8aaiq5j31880osqer.jpg" alt=""></p>
<p>人物半身像下方为年龄、生时、健康度，上图生时下方的数字“55/55”为人物的健康程度，以本人物举例，健康值上限即为剩余寿命55。</p>
<h4 id="3-1-2-年龄与健康的改变"><a href="#3-1-2-年龄与健康的改变" class="headerlink" title="3.1.2 年龄与健康的改变"></a>3.1.2 年龄与健康的改变</h4><ul>
<li><p>在受内外伤/内息/中毒超过可承受上限情况下，当前健康值会减少。如在当前健康值到0之后时节更替，人物死亡。中毒程度每超过上限一倍,时节更替时健康多减一.</p>
</li>
<li><p>战斗失利也会减少健康。</p>
</li>
<li>健康值上限会在每年你过生日的时节根据你的当前健康值-1重新获得上限。一旦健康值上限为0，人物死亡。所以请做好角色的健康管理，包中常备健康药。</li>
<li>游戏存在续命方法，可以提高健康上限,空桑派互动秘药延寿。</li>
<li>游戏中每年你过生日的时节你的年龄就会+1</li>
</ul>
<h4 id="3-1-3-年龄与健康的作用"><a href="#3-1-3-年龄与健康的作用" class="headerlink" title="3.1.3 年龄与健康的作用"></a>3.1.3 年龄与健康的作用</h4><ul>
<li><p>年龄对行动力与主要属性有一定影响.</p>
</li>
<li><p>时节更替后,健康值上限为0时,人物死亡,触发传剑</p>
</li>
</ul>
<h3 id="3-2-七元赋性"><a href="#3-2-七元赋性" class="headerlink" title="3.2 七元赋性"></a>3.2 七元赋性</h3><ul>
<li>主要在奇遇中生效，角色在奇遇岔路口会选择数值大的方向</li>
<li>福缘对物品掉落有一定影响 </li>
<li>坚毅影响读书的耐心 ,npc坚毅越高越不容易意外中毒/受伤(坚毅大于三十)</li>
</ul>
<h3 id="3-3-主要属性"><a href="#3-3-主要属性" class="headerlink" title="3.3 主要属性"></a>3.3 主要属性</h3><p>主要属性分为：膂力、体质、灵敏、根骨、悟性、定力。所有主要属性都会影响需要该属性的功法发挥效率。</p>
<ul>
<li>膂力会增加需要膂力武器的使用效率。超过50的部分会转化为攻击力道。减少装备重量对移动速度的负面影响。</li>
<li>灵敏会增加需要灵敏武器的使用效率。超过50的部分会转化为攻击迅捷。</li>
<li>定力会增加需要定力武器的使用效率。超过50的部分会转化为攻击精妙。</li>
<li>体质会影响角色的外伤上限。</li>
<li>根骨会影响角色的内伤上限。</li>
<li>悟性可以让读书和突破难度变得更简单。</li>
</ul>
<h3 id="3-4-防御属性"><a href="#3-4-防御属性" class="headerlink" title="3.4 防御属性"></a>3.4 防御属性</h3><p>防御属性分为：护体、御气、内息、卸力、拆招、闪避。</p>
<ul>
<li>护体为外功防御，会被敌人的“破体”属性削弱</li>
<li>御气为内功防御，会被敌人的“破气”属性削弱(破体/破气属性为武器属性，后续讲到装备时会详解)</li>
<li>内息为人物对内力的控制能力，可以压制并恢复内力紊乱</li>
<li>卸力、拆招、闪避为人物的防御命中属性。卸力防御力道、拆招防御精妙、闪避防御迅疾。简而言之，如果敌人释放攻击功法时角色的三项防御命中属性均大于敌人的对应攻击命中属性，那么敌人的技能威力为0。平砍时也同样会进行命中属性比较。</li>
</ul>
<h3 id="3-5其他属性"><a href="#3-5其他属性" class="headerlink" title="3.5其他属性"></a>3.5其他属性</h3><h4 id="3-5-1提气架势"><a href="#3-5-1提气架势" class="headerlink" title="3.5.1提气架势"></a>3.5.1提气架势</h4><ul>
<li>提气、架势速度影响人物战斗时这个圈。只有内外两圈都满了才能施放功法，内圈是提气圈，外圈是架势圈。角色一定会完成提气后才架势。</li>
<li>提气架势消耗，顾名思义，改变消耗的提气架势量。</li>
<li>内功发挥，内功发挥初始值为100%，并不是说内功发挥少了你的内功就变弱了，而是比百分百越少，角色的攻击功法外伤比例就越高；比百分百越高，角色攻击功法内伤比例就越高。内外伤比例直接表现为功法所需的提气架势比例</li>
</ul>
<h4 id="3-5-2攻击命中"><a href="#3-5-2攻击命中" class="headerlink" title="3.5.2攻击命中"></a>3.5.2攻击命中</h4><ul>
<li>力道、精妙、迅疾为人物的攻击命中属性。</li>
<li>卸力防御力道、拆招防御精妙、闪避防御迅疾。如果角色的三项命中属性均高于敌人的防御属性且处于正确的范围内，则攻击功法发挥为十成。</li>
<li>xx发挥、造成内/外伤、破气/体强度，建议直接看攻击功法上的数值，那是经过最终计算的结果(不考虑敌人防御属性情况下)</li>
</ul>
<h3 id="3-5-3治疗守御"><a href="#3-5-3治疗守御" class="headerlink" title="3.5.3治疗守御"></a>3.5.3治疗守御</h3><ul>
<li>守御指的是战斗时人物的白条(护体真气)，敌人在击破守御前是几乎不能对角色造成实质伤害的。提高守御效率能提高守御的硬度和速度。</li>
<li>疗伤/驱毒效率，提高疗伤和驱毒的能力</li>
</ul>
<h4 id="3-5-4行动能力"><a href="#3-5-4行动能力" class="headerlink" title="3.5.4行动能力"></a>3.5.4行动能力</h4><ul>
<li>移动速度,移动一次的速度</li>
<li>移动距离,移动一次的距离</li>
<li>攻击速度,施展武器攻击敌方的速度</li>
<li>武器切换,战斗中切换武器的速度</li>
<li>施展速度,影响功法的施展时间</li>
</ul>
<h3 id="3-6-轮回"><a href="#3-6-轮回" class="headerlink" title="3.6 轮回"></a>3.6 轮回</h3><p>轮回栏显示角色的前世</p>
<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g17bnpfphbj30eh0khgpb.jpg" alt="轮回页面"></p>
<ul>
<li>角色会继承前世的10%属性及资质(可建造术数四品建筑轮回台提高这个比例)</li>
</ul>
<h1 id="二-天下风云出我辈"><a href="#二-天下风云出我辈" class="headerlink" title="二 天下风云出我辈"></a>二 天下风云出我辈</h1><h2 id="1-太吾村建设"><a href="#1-太吾村建设" class="headerlink" title="1 太吾村建设"></a>1 太吾村建设</h2><h3 id="1-1建设概述"><a href="#1-1建设概述" class="headerlink" title="1.1建设概述"></a>1.1建设概述</h3><p>当玩家剧情发展到进入太吾村时，就会成为一名光荣的村长，拥有自己的村庄，也就是产业“太吾村”。 玩家可以根据自己的需求在太吾村建造多种建筑，也可对太吾村自然资源进行采集、撤除等等操作。</p>
<p>吾村地区整体规模为13×13的方格，每一个方格均为空地或者已建造的建筑或者自然生成的资源。 当空地有相邻的建筑时，会出现一个小房子图标，表示该空地可以建造建筑。 </p>
<ul>
<li>建筑右上角数字为建筑等级。建筑等级最高为20<br>建筑等级有多种影响：<br>a.当建筑B为建筑A的前置建筑时，建筑A的当前等级为建筑B的建筑等级上限。<br>b.当建筑A为经营建筑时，建筑等级会影响经营质量。如市集，建筑等级越高，收获的金钱越多；如知音阁，建筑等级越高，招募的流民音律资质就越高。<br>c.当建筑B为建筑A的增益建筑时，建筑B的建筑等级影响增益质量。</li>
<li>大多数建筑均有维护费用 ，当玩家拥有银钱无法达到维护建筑的最低要求时，建筑会受损 。当修习类/经营类建筑受损到100%/5%时，该建筑即无法正常使用/增加收获进度；当建筑受损程度达到100%时，该建筑会倒塌，该建筑位置会变为废墟，无法修复；当银钱重新达到建筑的最低要求时，受损建筑会在每个时节自行修复一些，待建筑恢复完好，方可正常使用。</li>
<li>建筑建造或者扩建显示的需要时节为本次建造所需消耗时节数，每当增大投入1人力，消耗时节数减少1，最低消耗1时节。(投入人数有上限) </li>
</ul>
<h3 id="1-2建筑分类"><a href="#1-2建筑分类" class="headerlink" title="1.2建筑分类"></a>1.2建筑分类</h3><h4 id="1-2-1剧情类"><a href="#1-2-1剧情类" class="headerlink" title="1.2.1剧情类"></a>1.2.1剧情类</h4><ul>
<li>太吾村(唯一不可拆除)：太吾村建筑为产业的核心建筑，剧情自带无需自行建造。太吾村的规模等级会影响产业的建筑上限，每提升1级太吾村的规模等级，建筑上限增加2点</li>
<li>仓库：仓库为剧情自带，无需自行建造。可存放装备物品，提升资源储存上限，与全太吾绘卷世界的其他仓库共通。提升仓库等级会提高资源储存上限并增加仓库容量</li>
<li>太吾氏祠堂(唯一不可拆除)：太吾氏祠堂为剧情建筑，建筑图纸剧情自动获得，需玩家自行建造。从主角20岁开始，年龄每增长10年可多一个通过消耗威望来提升同道的资质格子；基于祠堂规模与主角名誉，在每次“立春”时节可以获得一定的威望。</li>
<li>驿站(唯一不可拆除)：驿站为剧情建筑，当完成“墓中仙人”剧情后回到太吾村，会触发信件剧情，对话结束后驿站建筑图纸自动获得，需自行建造。当驿站完成建造后，人物即可通过点击地图界面中查看世界区域按钮 ，进入世界地图，点击目标地区，即可旅行到该地。 如玩家已开通该地区的驿站(即到达过该地域存在驿站的城镇)，可往返与该地区；如若无开通此地区，仍可旅行至此地，但是旅行至该地区后需找到该地区的驿站方可继续旅行至其他地区。(驿站同样是可经营建筑，选择村民经营驿站可以获得银钱和威望)</li>
</ul>
<h4 id="1-2-2基础类建筑"><a href="#1-2-2基础类建筑" class="headerlink" title="1.2.2基础类建筑"></a>1.2.2基础类建筑</h4><p>基础建筑分非修行类与修行类。</p>
<ul>
<li>非修行类包括：居所(每提升两级额外多一点可用人力)、厢房(提供额外好感加成)</li>
<li>修行类包括：人物修炼功法(练功房)或修习十六类技艺(木工房、琴舍等等)处，玩家可在此类建筑中进行修习&amp;突破&amp;研读，某些技艺建筑还可进行制造。</li>
</ul>
<h4 id="1-2-3-扩展类建筑"><a href="#1-2-3-扩展类建筑" class="headerlink" title="1.2.3 扩展类建筑"></a>1.2.3 扩展类建筑</h4><p>扩展类建筑需要紧靠其他建筑建造。扩展类建筑等级不可超过其基础建筑等级。<br>扩展类建筑可分为：</p>
<ol>
<li><p>经营类建筑。经营类建筑一般为修习类建筑的扩展建筑，需建在在对应基础建筑的邻近.</p>
<p>玩家需派遣一村民进入经营类建筑进行长期经营，经营者的技艺能力和心情会影响经营质量收获进度。每个时节会获得收获进度，更换经营者不会清空当前经营进度。经营评价与经营者反馈会影响经营质量。经营进度满了会在收获栏显示收获，需要玩家自己点击收获。招募人才的收获时间是有限制的！记得及时收人！</p>
<p>经营类建筑共分为三类：</p>
<ol>
<li>赚取银钱建筑(镖局、酒楼、市集、赌坊等等)、</li>
<li>获取威望建筑(金铺、知客亭等等)、</li>
<li>招募人才建筑(百家宴、勾栏瓦舍、书院等等)。</li>
</ol>
</li>
<li><p>增益类建筑。增益类建筑一般为修习类建筑的扩展建筑，需建在在对应基础建筑的邻近。</p>
<p>增益类建筑可对对应的基础建筑或直接对人物提供增益效果，增益效果随增益建筑建筑等级提高而提高。</p>
<p>如：绝诣堂(减少修习绝技所需历练)、龟龙山(减少突破诗书所需历练)、龙泉七星井(可制作出高一品的金铁器具)、画影轩(大幅提高初识者的好感度)等等。</p>
</li>
<li><p>采集类建筑。采集类建筑依托自然资源建造，需建在在对应基础资源的邻近。</p>
<p>可收获对应原材料，可提高资源增长概率，建筑等级不能超过资源等级。建筑等级影响采集质量。</p>
<p>如矿井、树农、药农、花农、筒车、泥渠、宝井、火爆堆、冰夷像等等都属于采集类。</p>
</li>
</ol>
<h3 id="1-3-建筑解锁与效果"><a href="#1-3-建筑解锁与效果" class="headerlink" title="1.3 建筑解锁与效果"></a>1.3 建筑解锁与效果</h3><ul>
<li>技艺建筑需要对应技艺书修习到75%以上后可在商人处购买对应建筑图纸。</li>
<li>建筑效果见下表:</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g17bpz6qppj31da0907b9.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g17bq8gypcj31d90aajxw.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g17bqg0ouej31d807agqm.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g17bqolhxaj31d507dtdu.jpg" alt=""></p>
<h2 id="2-武学"><a href="#2-武学" class="headerlink" title="2 武学"></a>2 武学</h2><h3 id="2-1-功法的分类"><a href="#2-1-功法的分类" class="headerlink" title="2.1 功法的分类"></a>2.1 功法的分类</h3><h4 id="2-1-1内功"><a href="#2-1-1内功" class="headerlink" title="2.1.1内功"></a>2.1.1内功</h4><ul>
<li>每种内功均有对应的内力属性<br><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g17br6f6puj307g07gab9.jpg" alt=""></li>
</ul>
<ol>
<li>金刚(金)：生玄阴(水)；被归元(土)生；克紫霞(木)；被纯阳(火)克</li>
<li>紫霞(木)：生纯阳(火)；被玄阴(水)生；克归元(土)；被金刚(金)克</li>
<li>玄阴(水)：生紫霞(木)；被金刚(金)生；克纯阳(火)；被归元(土)克</li>
<li>纯阳(火)：生归元(土)；被紫霞(木)生；克金刚(金)；被玄阴(水)克</li>
<li>归元(土)：生金刚(金)；被纯阳(火)生；克玄阴(水)；被紫霞(木)克</li>
<li>混元为全属性</li>
</ol>
<h4 id="2-1-2身法"><a href="#2-1-2身法" class="headerlink" title="2.1.2身法"></a>2.1.2身法</h4><h4 id="2-1-3绝技"><a href="#2-1-3绝技" class="headerlink" title="2.1.3绝技"></a>2.1.3绝技</h4><h4 id="2-1-4攻击"><a href="#2-1-4攻击" class="headerlink" title="2.1.4攻击"></a>2.1.4攻击</h4><h3 id="2-2-获取功法"><a href="#2-2-获取功法" class="headerlink" title="2.2 获取功法"></a>2.2 获取功法</h3><ul>
<li>拜入门派后请教门下弟子,根据支持率获取功法</li>
<li>请教非门派人士,可获取随机该人物研习程度大于五十的功法</li>
<li>战斗时掉落</li>
</ul>
<h3 id="2-3-研习功法"><a href="#2-3-研习功法" class="headerlink" title="2.3 研习功法"></a>2.3 研习功法</h3><h4 id="2-3-1-功法的修习与突破"><a href="#2-3-1-功法的修习与突破" class="headerlink" title="2.3.1 功法的修习与突破"></a>2.3.1 功法的修习与突破</h4><p>在任意城市/村落/门派点击进入该地区的产业视图，找到练功房/或相应技艺基础建筑 ，点击图标进入可以进入到练功读书界面.</p>
<ul>
<li>点击“修习”按钮 ,点击齿轮状按钮即可选择你所要修习的功法/技艺书。(显示内容为角色学习过的功法/技艺书，修习度100%的功法不在此显示).点击所需修习功法，然后按圆圈确定；或者按x取消。</li>
<li>每当功法修习至玄关(25%/50%/75%)，需进行突破方可继续修习。</li>
</ul>
<h4 id="2-3-2-研读书籍的资质需求"><a href="#2-3-2-研读书籍的资质需求" class="headerlink" title="2.3.2 研读书籍的资质需求"></a>2.3.2 研读书籍的资质需求</h4><p>太吾绘卷中每种品级的武学秘籍、文化典籍都会要求角色的资质，越高级的书要求的资质也会越高，想要读懂书中的内容就要努力提高自身的资质.</p>
<p>书籍50%阅读难度所需的资质+造诣与裸资质需求见下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">书籍品级</th>
<th style="text-align:center">资质+造诣需求</th>
<th style="text-align:center">裸资质需求</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">九品</td>
<td style="text-align:center">19</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">八品</td>
<td style="text-align:center">48</td>
<td style="text-align:center">23</td>
</tr>
<tr>
<td style="text-align:center">七品</td>
<td style="text-align:center">91</td>
<td style="text-align:center">46</td>
</tr>
<tr>
<td style="text-align:center">六品</td>
<td style="text-align:center">148</td>
<td style="text-align:center">58</td>
</tr>
<tr>
<td style="text-align:center">五品</td>
<td style="text-align:center">219</td>
<td style="text-align:center">89</td>
</tr>
<tr>
<td style="text-align:center">四品</td>
<td style="text-align:center">304</td>
<td style="text-align:center">108</td>
</tr>
<tr>
<td style="text-align:center">三品</td>
<td style="text-align:center">404</td>
<td style="text-align:center">149</td>
</tr>
<tr>
<td style="text-align:center">二品</td>
<td style="text-align:center">518</td>
<td style="text-align:center">193</td>
</tr>
<tr>
<td style="text-align:center">一品</td>
<td style="text-align:center">646</td>
<td style="text-align:center">226</td>
</tr>
</tbody>
</table>
<p>从上面可以看出，资质在读书这方面的影响其实就是三段:58，89，108。对应的你能顺顺当当的读书读到6，5，4品书。</p>
<p>建人物时，点了天人造化后配合早熟特性，内功身法绝技三项是比较容易达到108+的资质的，其他的武功和技艺方法很多时候1项都没有 这时候退而求其次，关注89+这个数值就好。最偏重的一门兵器一门技艺89+，其他两三门辅修兵器技艺58+就可以。</p>
<h4 id="2-3-3-功法的正逆练与冲解特效"><a href="#2-3-3-功法的正逆练与冲解特效" class="headerlink" title="2.3.3 功法的正逆练与冲解特效"></a>2.3.3 功法的正逆练与冲解特效</h4><p>正逆练由读书所决定。</p>
<ul>
<li>读真传秘籍获得正练效果1,读手抄秘籍获得逆练效果1</li>
<li>正练效果会提高功法的发挥上限,逆练功法会降低功法的使用需求</li>
<li>正逆练还会有心法正逆特效的区别，正≥5时为正，逆≥5时为逆，正逆都为5时为冲解。</li>
</ul>
<blockquote>
<p>具体特效安装功法显示mod即可,此处不再赘述.</p>
</blockquote>
<h2 id="3-奇遇"><a href="#3-奇遇" class="headerlink" title="3 奇遇"></a>3 奇遇</h2><h3 id="3-1-奇遇概述"><a href="#3-1-奇遇概述" class="headerlink" title="3.1 奇遇概述"></a>3.1 奇遇概述</h3><ul>
<li>奇遇进入之前需要支付“门票”——资源、食物、道具等，以及消耗对应行动力。</li>
<li>难度: 影响奇遇所需技艺等级</li>
<li>区域: 影响七元赋性格的分布。</li>
<li>队伍七元赋性：队伍中所有人的七元赋性的平均值。</li>
<li>队伍技艺值：太吾的技艺资质+太吾的技艺造诣+队伍其他人的技艺资质总和的一半</li>
<li>进入奇遇后以队伍七元赋性决定前进方向，队伍七元哪个大就去哪个分支向，不会走回头路，有箭头显示以奇遇转盘检定队伍技艺值决定行动效果，队伍技艺值大于转盘数值则成功，否则失败。</li>
</ul>
<h3 id="3-2-促织高鸣"><a href="#3-2-促织高鸣" class="headerlink" title="3.2 促织高鸣"></a>3.2 促织高鸣</h3><p><strong>作用</strong>: 可以通过该奇遇捕获促织</p>
<ul>
<li>拥有三只或以上促织后可与任何关系符合条件的成年npc进行促织决斗来获取资源或者增加好感</li>
<li>作为礼物赠送给npc(呆物送掌门)</li>
<li>作为商品换取银钱</li>
<li>把促织放在祠堂,每年特定时节会根据促织胜场获取威望</li>
<li>放置于装备栏改变人物七元赋性</li>
<li>作为奇遇天才地宝的进入条件</li>
</ul>
<p><strong>出现条件</strong>: 每年8、9、10月份出现</p>
<p><strong>需求</strong>: 捕虫网</p>
<p><strong>奇遇转盘检定</strong>：难度对应的杂学</p>
<p>奇遇最后可抓蛐蛐<br>保证你队伍的杂学高于转盘所需情况下，尽量多走福缘提高获得高品质蛐蛐机会 </p>
<ul>
<li>难度也会影响蛐蛐的品质,</li>
<li>蛐蛐分平叫和急叫,急叫时波纹大且急</li>
<li>在蛐蛐从开始急叫到结束的中间捉是最好的捉太快或太慢都不行,一般声音越大的就越好</li>
</ul>
<p>促织决斗的流程见下表:</p>
<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g17bs2q0hhj30us16m0wl.jpg" alt=""></p>
<blockquote>
<p>作者的太吾生涯仅有一只怀胎三年生的天蓝青,它一生从未战斗过,所以本攻略对促织的描述不多,敬请见谅.</p>
</blockquote>
<h3 id="3-3-商贾云集"><a href="#3-3-商贾云集" class="headerlink" title="3.3 商贾云集"></a>3.3 商贾云集</h3><p><strong>作用</strong>: 奇遇内有大量商人</p>
<p><strong>出现条件</strong>: 每年2、3、4月份出现</p>
<p><strong>需求</strong>: 难度对应的威望</p>
<p><strong>奇遇转盘检定</strong>：难度对应的品鉴</p>
<ul>
<li>难度会影响商人售卖的物品</li>
<li>奇遇内福缘判定成功会提升商队好感(暂时)。</li>
<li>和商人进行交易即可提高商号友好度。银钱交易量，友好度越多。</li>
<li>商号好感度会影响购买出售价格、商人出售物品数量、商人出售物品品阶。</li>
</ul>
<h3 id="3-4-外道巢穴"><a href="#3-4-外道巢穴" class="headerlink" title="3.4 外道巢穴"></a>3.4 外道巢穴</h3><p><strong>作用:</strong> </p>
<ul>
<li>每当打通外道巢穴会根据人物立场进行选择，可获得大量地区恩义。根据人物立场的不同会有不同的奖励。</li>
<li>首杀 首次打通某类外道巢穴后，无论哪个地图格上的同类外道巢穴所属外道都会遇到太吾就逃跑。</li>
<li>要在本地区打掉现有最高等级的外道巢穴，才会刷下一级。</li>
</ul>
<p><strong>出现条件</strong>: 未知</p>
<p><strong>需求</strong>: 任意食物</p>
<p><strong>奇遇转盘检定</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">所需技艺</th>
<th style="text-align:center">技艺等级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">恶丐窝</td>
<td style="text-align:center">毒术 杂学</td>
<td style="text-align:center">10-50</td>
</tr>
<tr>
<td style="text-align:center">贼人营寨</td>
<td style="text-align:center">巧匠 杂学</td>
<td style="text-align:center">10-50</td>
</tr>
<tr>
<td style="text-align:center">悍匪砦</td>
<td style="text-align:center">杂学 锻造</td>
<td style="text-align:center">20-100</td>
</tr>
<tr>
<td style="text-align:center">叛徒结伙</td>
<td style="text-align:center">制木 杂学</td>
<td style="text-align:center">30-150</td>
</tr>
<tr>
<td style="text-align:center">恶人谷</td>
<td style="text-align:center">术数 杂学</td>
<td style="text-align:center">40-200</td>
</tr>
<tr>
<td style="text-align:center">迷香阵</td>
<td style="text-align:center">织锦 音律</td>
<td style="text-align:center">40-200</td>
</tr>
<tr>
<td style="text-align:center">乱葬岗</td>
<td style="text-align:center">医术 毒术</td>
<td style="text-align:center">50-250</td>
</tr>
<tr>
<td style="text-align:center">异士居</td>
<td style="text-align:center">绘画 品鉴 诗书</td>
<td style="text-align:center">60-300</td>
</tr>
<tr>
<td style="text-align:center">修罗场</td>
<td style="text-align:center">医术 杂学</td>
<td style="text-align:center">70-350</td>
</tr>
<tr>
<td style="text-align:center">邪人死地</td>
<td style="text-align:center">道法</td>
<td style="text-align:center">70-350</td>
</tr>
</tbody>
</table>
<h3 id="3-5-剑冢"><a href="#3-5-剑冢" class="headerlink" title="3.5 剑冢"></a>3.5 剑冢</h3><p><strong>作用:</strong></p>
<ul>
<li>挑战剑冢boss时会根据对剑冢boss百分比给予太吾精纯点数，一个boss最多3点</li>
<li>打通某一剑冢后会解锁下一个10%阶段的门派支持上限/地区恩义上限/地区威胁上限/商人好感上限同时也会解锁下一品阶的npc可以被相枢化魔和成为太吾同道。剩余的剑冢会提高难度</li>
</ul>
<blockquote>
<p>此攻略图片来自百度贴吧-<strong>戳眼神教教主</strong>-<a href="https://tieba.baidu.com/p/6036237065" target="_blank" rel="noopener">各个剑冢boss的强度和应对方法</a></p>
</blockquote>
<h4 id="3-5-1-大玄凝"><a href="#3-5-1-大玄凝" class="headerlink" title="3.5.1 大玄凝"></a>3.5.1 大玄凝</h4><p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g17c8r1xx6j312x0o2h3k.jpg" alt="大玄凝"></p>
<h4 id="3-5-2-焚神练"><a href="#3-5-2-焚神练" class="headerlink" title="3.5.2 焚神练"></a>3.5.2 焚神练</h4><p><img src="http://imgsrc.baidu.com/forum/pic/item/7b367d47f21fbe09950f32df66600c338544ada3.jpg" alt="焚神练"></p>
<h4 id="3-5-3-溶尘隐"><a href="#3-5-3-溶尘隐" class="headerlink" title="3.5.3 溶尘隐"></a>3.5.3 溶尘隐</h4><p><img src="http://imgsrc.baidu.com/forum/pic/item/b2ece412b07eca807a9dc92c9c2397dda344835b.jpg" alt="溶尘隐"></p>
<h4 id="3-5-4-鬼神霞"><a href="#3-5-4-鬼神霞" class="headerlink" title="3.5.4 鬼神霞"></a>3.5.4 鬼神霞</h4><p><img src="http://imgsrc.baidu.com/forum/pic/item/53be8cf3b2119313ade30f7b68380cd793238d53.jpg" alt="鬼神霞"></p>
<h4 id="3-5-5-莫女衣"><a href="#3-5-5-莫女衣" class="headerlink" title="3.5.5 莫女衣"></a>3.5.5 莫女衣</h4><p><img src="http://imgsrc.baidu.com/forum/pic/item/5b48beeb15ce36d3c49873fb37f33a87eb50b15f.jpg" alt="莫女衣"></p>
<h4 id="3-5-6-伏铁邪"><a href="#3-5-6-伏铁邪" class="headerlink" title="3.5.6 伏铁邪"></a>3.5.6 伏铁邪</h4><p><img src="http://imgsrc.baidu.com/forum/pic/item/3a7a9e51352ac65c061e94b8f6f2b21191138ae4.jpg" alt="伏铁邪"></p>
<h4 id="3-5-7-囚魔木"><a href="#3-5-7-囚魔木" class="headerlink" title="3.5.7 囚魔木"></a>3.5.7 囚魔木</h4><p><img src="http://imgsrc.baidu.com/forum/pic/item/afac84dfb48f8c54dc8b38e437292df5e2fe7f9b.jpg" alt="囚魔木"></p>
<h4 id="3-5-8-解龙魄"><a href="#3-5-8-解龙魄" class="headerlink" title="3.5.8 解龙魄"></a>3.5.8 解龙魄</h4><p><img src="http://imgsrc.baidu.com/forum/pic/item/b864de004c086e06c9f8c2800f087bf408d1cbac.jpg" alt="解龙魄"></p>
<h4 id="3-5-9-凤凰茧"><a href="#3-5-9-凤凰茧" class="headerlink" title="3.5.9  凤凰茧"></a>3.5.9  凤凰茧</h4><p><img src="http://imgsrc.baidu.com/forum/pic/item/43eb1a234f4a20a4a8e8c00c9d529822700ed002.jpg" alt="凤凰茧"></p>
<h4 id="3-5-10-剑冢挑战顺序"><a href="#3-5-10-剑冢挑战顺序" class="headerlink" title="3.5.10 剑冢挑战顺序"></a>3.5.10 剑冢挑战顺序</h4><p><img src="http://imgsrc.baidu.com/forum/pic/item/46de7ef69052982295a2d808daca7bcb0846d463.jpg" alt="剑冢挑战顺序"></p>
<h3 id="3-6-天书宝典"><a href="#3-6-天书宝典" class="headerlink" title="3.6 天书宝典"></a>3.6 天书宝典</h3><p><strong>宝典作用:</strong></p>
<ul>
<li>每本宝典能加100对应武学资质，可以拯救一位太吾的人生,资质只要到六七十再带上相应的宝典，神一品的功法突破起来也是轻轻松松。</li>
<li>赠与NPC,向其请教功法</li>
</ul>
<p><strong>取得宝典的方法：</strong></p>
<ul>
<li><p>亲自上手绑架走扒下来</p>
</li>
<li><p>天书宝典奇遇</p>
<p> 界青门安排，等到站了进奇遇拿。(不知道是不是设定，宝典奇遇的勇壮和福缘判定特别多)</p>
<p> 刚正立场并且名誉符合要求，追着惩戒打到死，等奇遇抢。</p>
<p> 如果你到奇遇终点的路线完美避开了所有勇壮格子，到达终点时会直接取得宝典。</p>
<p> 如果途中有过战斗则在终点要和某人打一架来决定宝典归属。 </p>
</li>
</ul>
<p><strong>奇遇轮盘互动:</strong></p>
<p>奇遇当中，遇敌时根据敌人的立场会有不同的互动结果：</p>
<ul>
<li>刚正：恶战，败者退出争夺。可以避战。</li>
<li>仁善：切磋，可以避战。</li>
<li>中庸： 暂时停战</li>
<li>叛逆：选择是否助其虚张声势：是：对方看起来会比实际更强，出现在终点处与你争夺的可能性变大 否：打一架。</li>
<li>唯我：遇到唯我的敌人必定在对方的偷袭中受伤(不触发战斗，发生在对话当中的既定事实)，然后可选择避战或刚到底。此时避战必定成功</li>
</ul>
<p><strong>奇遇的轮盘对应资质:</strong></p>
<p>奇遇的轮盘只有对应宝典的武学造诣</p>
<h2 id="4-战斗"><a href="#4-战斗" class="headerlink" title="4 战斗"></a>4 战斗</h2><h3 id="4-1-战斗准备"><a href="#4-1-战斗准备" class="headerlink" title="4.1 战斗准备"></a>4.1 战斗准备</h3><p>在与敌人相遇时会触发战斗，玩家可以点击角色半身像来使用道具、更改装备和功法，也可点击敌人半身像查看敌人的装备物品人物属性。知己知彼，百战不殆。</p>
<h4 id="4-1-1-机略来源"><a href="#4-1-1-机略来源" class="headerlink" title="4.1.1 机略来源"></a>4.1.1 机略来源</h4><ul>
<li>机略等级和类型由整个队伍决定。人物特性的里圆圈的会具体表现为战斗、较艺准备中的机略。</li>
<li>不同颜色(红vs蓝)的机略等级会相互抵消每个角色的白色机略会加在红蓝机略等级高的那一方。如该角色无红蓝色机略或红蓝等级一致，无论白色机略等级高低都视为无。</li>
<li>机略等级公式：主角的机略等级X(6-队伍总人数(包括主角在内))+队友的机略等级</li>
</ul>
<h4 id="4-1-2-机略作用"><a href="#4-1-2-机略作用" class="headerlink" title="4.1.2 机略作用"></a>4.1.2 机略作用</h4><ol>
<li><p><strong>使用战前道具</strong></p>
<p>喝酒/喝茶/用药/使用剑冢碎片改变人物属性，需要消耗机略等级。</p>
</li>
<li><p><strong>决定先后手</strong></p>
<ul>
<li>敌我双方剩余机略等级高者为先，低者为后。如果一致，则随机先后。</li>
<li>先手在战斗时初始拥有90%提气架势圈与3点移动力；后手在战斗时初始拥有60%的提气架势圈与2点移动力。</li>
</ul>
</li>
<li><p><strong>战斗策略</strong></p>
<ul>
<li>策略盘。消耗机略等级使用战斗机略，单选。机略消耗量由敌方机略数值影响。</li>
<li>策略盘根据队伍红蓝机略等级的不同分为两种：</li>
<li>当人物及队伍中的队员合计蓝色机略数&gt;红色机略数时，人物会采取近战策略</li>
<li>当人物及队伍中的队员合计蓝色机略数&lt;红色机略数时，人物会采取远程策略 </li>
</ul>
</li>
</ol>
<h3 id="4-2-伤害"><a href="#4-2-伤害" class="headerlink" title="4.2 伤害"></a>4.2 伤害</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">伤害 = 击中部位基础伤害(比如胸背1级伤口60，3级伤口180)*武功或者武器伤害百分比*对应的(破x-御x)/100*(1+内外功伤害加成)*暴击倍率</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此伤害公式仅供参考</p>
</blockquote>
<h3 id="4-3-伤势"><a href="#4-3-伤势" class="headerlink" title="4.3 伤势"></a>4.3 伤势</h3><p>在《太吾绘卷》中，玩家们对敌人所用的武功、武器不同，对敌人造成伤口破绽也会不同。我们对其伤口多次进行伤害后，后续的伤害会越来越高.</p>
<h4 id="4-3-1-功法造成的伤势"><a href="#4-3-1-功法造成的伤势" class="headerlink" title="4.3.1 功法造成的伤势"></a>4.3.1 功法造成的伤势</h4><p>所有攻击功法出招都是四次。</p>
<p>计算顺序为迅疾、精妙、力道。</p>
<p><img src="http://image.9game.cn/2018/10/15/25207027.jpg" alt="巨阙"></p>
<p>上图是巨阙的。</p>
<p>在功法属性一栏看到，读格子数目，迅疾，精妙，力道的比例分别为1：1：8。</p>
<p>那么前三招的发挥比例分别为10%，10%，80%。</p>
<p>假如你命中三维全压对面，最后一击的发挥比例就是<strong>10%+10%+80%=100%</strong></p>
<p>假如你的迅疾太低，己方迅疾低于敌方闪避,第一招被闪避了，那么最后一击的发挥比例就是<strong>10%+80%=90%</strong></p>
<p>此外，这几个颜色的格子还影响发挥比率。</p>
<p>计算方法为</p>
<p><strong>发挥比例100%【包括】以上，造成的伤势程度为致命伤;倍率为3倍。</strong></p>
<p><strong>发挥比例50%【包括】以上，造成的伤势程度为重伤;倍率为2倍。</strong></p>
<p>还拿巨阙做例子，第一击迅疾属性10%，轻伤，第二击精妙属性10%，轻伤，第三击力道属性80%，重伤。</p>
<p>最后一击100%，致命伤。</p>
<p>如果前两段都被格挡，只有第三段和第四段的话，就是80%+80%，两段都是重伤伤势，倍率为两倍，虽然被削弱但影响不是致命的。</p>
<h4 id="4-3-2-普攻造成的伤势"><a href="#4-3-2-普攻造成的伤势" class="headerlink" title="4.3.2 普攻造成的伤势"></a>4.3.2 普攻造成的伤势</h4><p>己方攻击命中属性略大于敌方防御防御属性,造成轻伤.</p>
<table>
<thead>
<tr>
<th style="text-align:center">使用武器</th>
<th style="text-align:center">招式</th>
<th style="text-align:center">攻击命中属性</th>
<th style="text-align:center">己方力道</th>
<th style="text-align:center">敌方卸力</th>
<th style="text-align:center">造成伤势</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">刀</td>
<td style="text-align:center">劈</td>
<td style="text-align:center">力道</td>
<td style="text-align:center">100</td>
<td style="text-align:center">99</td>
<td style="text-align:center">轻伤</td>
</tr>
</tbody>
</table>
<p>己方攻击命中属性大于敌方防御防御属性的两倍,造成重伤.</p>
<table>
<thead>
<tr>
<th style="text-align:center">使用武器</th>
<th style="text-align:center">招式</th>
<th style="text-align:center">攻击命中属性</th>
<th style="text-align:center">己方力道</th>
<th style="text-align:center">敌方卸力</th>
<th style="text-align:center">造成伤势</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">刀</td>
<td style="text-align:center">劈</td>
<td style="text-align:center">力道</td>
<td style="text-align:center">100</td>
<td style="text-align:center">50</td>
<td style="text-align:center">重伤</td>
</tr>
</tbody>
</table>
<p>技巧: 根据上述结论,可以适当堆砌己方命中属性使用正练空桑绝技剖腹切割法或正练百花谷绝技对敌方进行控制和提高己方伤害.</p>
<h3 id="4-4-破绽与闭穴"><a href="#4-4-破绽与闭穴" class="headerlink" title="4.4 破绽与闭穴"></a>4.4 破绽与闭穴</h3><h4 id="4-4-1-破绽"><a href="#4-4-1-破绽" class="headerlink" title="4.4.1 破绽"></a>4.4.1 破绽</h4><p><strong>破绽产生:</strong>  功法特效</p>
<p><strong>破绽作用:</strong>  对破绽部位造成伤害，会提高伤害，同时无视守御值</p>
<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g17btdqh26j30kq08qdkf.jpg" alt=""></p>
<h4 id="4-4-1-闭穴"><a href="#4-4-1-闭穴" class="headerlink" title="4.4.1 闭穴"></a>4.4.1 闭穴</h4><p><strong>闭穴产生:</strong>  功法特效</p>
<p><strong>闭穴作用:</strong>  闭穴会对闭穴的部位造成闭穴效果,不同的部位有不同的效果.</p>
<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g17btmteb4j30hu08k0wx.jpg" alt=""></p>
<h2 id="5-地区恩义的作用"><a href="#5-地区恩义的作用" class="headerlink" title="5 地区恩义的作用"></a>5 地区恩义的作用</h2><ul>
<li><strong>五仙教</strong> 五圣秘浴 消耗30%地区恩义 祛除所有毒素</li>
<li><strong>百花谷</strong> 起死回生 消耗30%地区恩义 治愈所有伤势</li>
<li><strong>狮相门</strong> 散播威名 消耗30%地区恩义 获得大量威望（约1000）</li>
<li><strong>铸剑山庄</strong> 欧冶古具 消耗50%地区恩义 自选获得三品锻造、制木、织锦、巧匠工具之一（仅余一次使用机会）</li>
<li><strong>璇女派</strong> 玉镜沉思 消耗50%地区恩义 看仙人弹琴改善某负面特性，看仙人舞剑增强某正面特性</li>
<li><strong>峨眉派</strong> 天府规略 消耗50%地区恩义 使太吾村中各资源点的规模提升</li>
<li><strong>无量金刚宗</strong> 搜集贡品 消耗20%地区恩义 获得大量金钱（一万多）</li>
<li><strong>武当派</strong> 七星调元 消耗30%地区恩义 使人物内息紊乱恢复</li>
<li><strong>界青门</strong> 委托暗杀 消耗30%地区恩义 需记住名字</li>
<li><strong>伏龙坛</strong> 龙岛忠仆 消耗30%地区恩义 获得好感每年加60的同道一名</li>
<li><strong>血犼教</strong> 血池秘法 消耗30%地区恩义 使人物进入（活回到）入邪的状态</li>
<li><strong>然山派</strong> 王禅典籍 消耗30%地区恩义 改变人物立场（约一格）</li>
<li><strong>少林派</strong> 念经忏悔 消耗20%地区恩义 减少人物恶名</li>
<li><strong>元山派</strong> 石牢静坐 消耗30%地区恩义 减少人物入邪程度</li>
<li><strong>空桑派</strong> 秘药延寿 消耗50%地区恩义 续命六年但同时将身中剧毒</li>
<li><strong>各地区大当家等红色人物</strong> 推恩施义 消耗20%地区恩义 增加地区安定、文化、资源</li>
<li><strong>各地区豪富等黄色人物</strong> 商会赞誉 消耗50%地区恩义 增加所选商会好感</li>
<li><strong>各地区二当家权贵等橙色人物</strong> 笼络人心 花一万买地区恩义</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g17bu8r7x1j30g40ecqi6.jpg" alt=""></p>
<h1 id="三-一入江湖岁月催"><a href="#三-一入江湖岁月催" class="headerlink" title="三 一入江湖岁月催"></a>三 一入江湖岁月催</h1><h2 id="1-喜结良缘"><a href="#1-喜结良缘" class="headerlink" title="1 喜结良缘"></a>1 喜结良缘</h2><p>结婚条件: </p>
<ol>
<li><p>双方年龄必须满16岁</p>
</li>
<li><p>倾诉爱意成功</p>
</li>
</ol>
<blockquote>
<p>双方不是三代以内的直系血亲(德国骨科警告)</p>
</blockquote>
<h2 id="2-传宗接代"><a href="#2-传宗接代" class="headerlink" title="2 传宗接代"></a>2 传宗接代</h2><h3 id="2-1-触发生育的必要条件"><a href="#2-1-触发生育的必要条件" class="headerlink" title="2.1 触发生育的必要条件"></a>2.1 触发生育的必要条件</h3><p>1.双方为一男一女</p>
<p>2.双方关系为两情相悦/结发夫妻</p>
<p>3.双方在同一个格子</p>
<h3 id="2-2-影响生育几率的因素"><a href="#2-2-影响生育几率的因素" class="headerlink" title="2.2 影响生育几率的因素"></a>2.2 影响生育几率的因素</h3><ul>
<li><strong>年龄:</strong> 30岁之后生育几率大幅下降</li>
<li><strong>特性:</strong> 父母双方某些不良特性会降低生育几率.eg: 石芯玉女,无根之人</li>
<li><strong>立场:</strong>  立场为刚正的NPC在与玩家成为结发夫妻之前基本不会与玩家进行生育互动;立场为叛逆的NPC可在与玩家成为结发夫妻之前和玩家进行生育互动.</li>
</ul>
<blockquote>
<p>此立场因素并不影响NPC之间的生育互动</p>
</blockquote>
<h3 id="2-3-子女的继承项目"><a href="#2-3-子女的继承项目" class="headerlink" title="2.3 子女的继承项目"></a>2.3 子女的继承项目</h3><h4 id="2-3-1-相貌"><a href="#2-3-1-相貌" class="headerlink" title="2.3.1 相貌"></a>2.3.1 相貌</h4><p>子女的五官部件在爸妈的对应器官之间随机</p>
<h4 id="2-3-2-特性"><a href="#2-3-2-特性" class="headerlink" title="2.3.2 特性"></a>2.3.2 特性</h4><ul>
<li>父母共同拥有的特性必定会遗传</li>
<li>神锋敛彩,璞玉韬光,经文祝祷只要父母单方面拥有即可遗传</li>
</ul>
<p>其他的特性遗传个数与等级见下表:</p>
<p><img src="http://ww1.sinaimg.cn/large/006mfK1qly1g17bv4b3zxj309g0l5wfr.jpg" alt=""></p>
<p>如果人物遗传的特性达到三个，随机产生新特性的机会将减半，特性越多产生随机特性的机会越小，遗传特性达到七个后将不再有随机新特性.</p>
<blockquote>
<p>参考资料: 百度贴吧-吉祥的客栈-<a href="https://tieba.baidu.com/p/5917642695" target="_blank" rel="noopener">太吾遗传学</a></p>
</blockquote>
<h4 id="2-3-2-属性和资质"><a href="#2-3-2-属性和资质" class="headerlink" title="2.3.2 属性和资质"></a>2.3.2 属性和资质</h4><p><strong>子女某项属性和资质的数值</strong> = 父母对应属性之和的平均值+随机数</p>
<p><strong>属性和资质的提升:</strong></p>
<ul>
<li>如果玩家为女太吾,可在身怀六甲期间触发胎教事件提升子女的属性和资质.<ol>
<li>轻轻抚慰：加主要属性（人物的根骨等主要属性）</li>
<li>哼唱小曲：加技艺资质（随机技艺天赋或是全体提升）</li>
<li>调匀气息：加武学资质（随机武学天赋或是全部提升）</li>
</ol>
</li>
<li>将子女拉入同道,可在祠堂消耗威望对其传功提升其武学资质或者技艺资质</li>
</ul>
<h2 id="3-传剑"><a href="#3-传剑" class="headerlink" title="3 传剑"></a>3 传剑</h2><p>当玩家的健康值在时节更替后归零时/人物入魔,触发传剑.玩家可选择同道中的一人进行传剑;如果没有同道且没有开启随机继承人选项,游戏结束.</p>
<h3 id="3-1-传剑对被传剑人的影响"><a href="#3-1-传剑对被传剑人的影响" class="headerlink" title="3.1 传剑对被传剑人的影响"></a>3.1 传剑对被传剑人的影响</h3><ul>
<li>被传剑人会丧失自己原本的所有已习得功法,获得上一代太吾所有已习得功法</li>
<li>被传剑人会获得上一代太吾几乎所有资产,不能继承的资产包括:上一代太吾的衣服,上一代太吾获得的奇书宝典(除此之外均可继承)</li>
<li>被传剑人的身份会变为太吾传人</li>
</ul>
<h3 id="3-2-生平遗惠"><a href="#3-2-生平遗惠" class="headerlink" title="3.2 生平遗惠"></a>3.2 生平遗惠</h3><p>在选择传剑人之后,可根据上一代太吾的生平遗惠选择几项对下一代太吾有增益的增益效果.</p>
<h3 id="3-3-游戏选项变更"><a href="#3-3-游戏选项变更" class="headerlink" title="3.3 游戏选项变更"></a>3.3 游戏选项变更</h3><p>在传剑时,玩家可对游戏选项进行变更</p>
<p>eg: 游戏难度,侵袭速度,外道数量等</p>
<h1 id="四-不及人生一场醉"><a href="#四-不及人生一场醉" class="headerlink" title="四 不及人生一场醉"></a>四 不及人生一场醉</h1><p><strong>太吾历一年八月</strong></p>
<p>太吾降世,名为沈万三.沈万三自知天资愚钝,幸好他在梦中曾见过盛世光景,对建设颇有心得.于是他一心一意的建设着太吾村,除了参与每年的新春集会,几乎没有出过太吾村.</p>
<p><strong>太吾历十五年</strong></p>
<p>沈万三惊闻剑冢异动,惶惶不可终日,忙忙带上家乡美酒出门学艺. 听闻铸剑山庄广收门徒,有教无类,遂拜入山庄门下.习得十二路鱼肠刺剑.</p>
<p><strong>太吾历十六年</strong></p>
<p> 宁琴对沈万三倾心爱慕,追随其至逐剑山庄,沈万三感动不已便与宁琴成为结发夫妻,共度余生.</p>
<p><strong>太吾历十七年</strong></p>
<p>宁琴生子,取名沈灵虚.</p>
<p><strong>太吾历十七年</strong></p>
<p>宁琴生女,取名沈逍遥.</p>
<p><strong>太吾历二十年</strong></p>
<p>以十二路鱼肠刺剑平息剑冢异动.</p>
<p><strong>太吾历二十一年</strong></p>
<p>剑冢异动又起,沈万三心生愤慨,决心破除剑冢,以绝后患.</p>
<p><strong>太吾历二十二年</strong></p>
<p>沈万三大破剑冢溶尘隐,而后安心回到太吾村发展建设.</p>
<p><strong>太吾历二十三年</strong></p>
<p> 剑冢异动再起,沈万三心叹:不知这如履薄冰的日子还要持续多久,这便是太吾的宿命吗? 随后便再次踏入学艺之路.</p>
<p><strong>太吾历四十一年</strong></p>
<p>沈万三已将巨阙剑修得大成,锻造之术亦至宗师之境.但是因资质过低,修炼内功走火入魔,大限已至,传剑其女沈逍遥.沈逍遥乃是绝世奇才,战力惊人,刚刚接过剑柄便提刀杀向剑冢,三刀劈碎大玄凝.</p>
<p>沈逍遥觉剑冢之祸非一世之功,必须的给自己留下一个传承之人,便开始游历天下,寻一个资质上佳之人与之成婚诞下希望之火.</p>
<p><strong>太吾历四十二年</strong></p>
<p>寻寻觅觅,花费数年时间,终遇一文人,良材美玉资质上佳,与其共结连理,诞下一女,取名沈君鄂.</p>
<p><strong>太吾历五十九年</strong></p>
<p>沈逍遥以巨阙刀法连破五个剑冢,提刀而立,为之四顾,为之踌躇满志,一头杀入凤凰茧,不料身死道消.匆匆传剑其女沈君鄂.</p>
<p>沈逍遥: 只要让我在劈一刀,你必死无葬身之地! 奈何我伤势过重,已无力出招,我恨啊!我还没有做好准备,还没有给我的儿女传功啊!</p>
<p><strong>太吾历六十年</strong></p>
<p>沈君鄂接过剑柄,心道凤凰茧之败并非母亲功法不够凌厉,而是招架不足还为出招便已身死.我只需寻得一保命绝技便可攻破凤凰茧.</p>
<p>沈君鄂遍历天下,寻得一神功天蛇换骨,匆匆研习了几章得其效果便直奔剑冢而去.</p>
<p>沈君鄂将伏虞剑柄嵌入剑冢墓门,只听轰隆一声,大门应声而开,一个人影随之从剑冢中凑出.</p>
<p>金凰儿嬉笑着说:”我问你啊,方今之世，可有圣人吗?我等不到圣人,唯有出来寻找,且让我试试你可有圣人之才如何?’’不料话音未落,金凰儿便拔刀向沈君鄂劈来.</p>
<p>一番苦战,沈君鄂击败了金凰儿!</p>
<p>金凰儿虽身负重伤,却仍嘻嘻而笑: “不错,便是你啦!”</p>
<p>她说着,盛了一碗金黄的美酒递来给沈君鄂.</p>
<p><img src="http://i1.hdslb.com/bfs/archive/438663aa63d80aa07fb354ed38150e9a42f40ab1.jpg" alt="金凰儿"></p>
<p>沈君鄂不由自主的想要去接:”相枢降世入轮回,天下风云出我辈.一入江湖岁月催,不及人生一场醉.如此美酒,理应大醉一场!”</p>
<p>哪知一眨眼,眼前便什么也没有了.</p>
<h1 id="五-致谢词"><a href="#五-致谢词" class="headerlink" title="五 致谢词"></a>五 致谢词</h1><p>在我初次游玩《太吾绘卷》时,我遇到了许多艰难与困阻,我查询了众多攻略,一点一点拼凑出我的江湖.美好的假期结束了,我也应该去工作来维持生计.但是我希望当有新玩家来体验属于他们的江湖和感动时能少一些阻碍,基于此我编写了本篇攻略.</p>
<p>因为本篇攻略参考众多,没有一一列出,敬请见谅.</p>
<p>感谢《太吾绘卷》带给我的感动,是它让我谱写则属于自己的江湖,感谢《太吾绘卷》全体制作人员.感谢为《太吾绘卷》无私奉献的攻略作者们，在此，我再一次真诚地向帮助过我的攻略作者表示感谢!</p>
<h1 id="六-参考资料"><a href="#六-参考资料" class="headerlink" title="六 参考资料"></a>六 参考资料</h1><ol>
<li>灰机wiki-太吾绘卷-<a href="https://taiwu.huijiwiki.com/wiki/%E9%A6%96%E9%A1%B5" target="_blank" rel="noopener">灰机Wiki</a></li>
<li>NGA-UID:5758723-<a href="https://bbs.nga.cn/read.php?tid=15119057&amp;rand=963" target="_blank" rel="noopener">太吾百晓册</a></li>
<li>NGA-UID:157403-<a href="https://bbs.nga.cn/read.php?&amp;tid=15197500&amp;rand=998" target="_blank" rel="noopener"> 魅力捏脸手册 {09/30 更新：补充少量有关生孩子的机制} </a></li>
<li>百度贴吧-摇光为星-<a href="https://tieba.baidu.com/p/5900568013" target="_blank" rel="noopener">全特性效果总会图</a></li>
<li>百度贴吧-戳眼神教教主-<a href="https://tieba.baidu.com/p/6036237065" target="_blank" rel="noopener">各个剑冢boss的强度和应对方法</a></li>
</ol>
]]></content>
      <categories>
        <category>游戏攻略</category>
      </categories>
  </entry>
  <entry>
    <title>常见的inline元素、block元素、inline-block元素有哪些？它们之间有什么区别？</title>
    <url>/2018/10/03/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%831/%E5%B8%B8%E8%A7%81%E7%9A%84inline%E5%85%83%E7%B4%A0%E3%80%81block%E5%85%83%E7%B4%A0%E3%80%81inline-block%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<blockquote>
<p>每个html标签元素都有其默认的元素类型，主要包括两大类:inline内联元素、block块元素。除默认为以上两种，还有部分标签元素叫可变元素，会根据上下文语境决定该元素为inline元素或是block元素。在css里，有一个display的属性，他规定元素应该生成的框的类型。可能的值有很多，inline、block、inline-block,其中inline-block是在css2.1里新增的值。具有这个值的元素，我们可以把它叫做inline-block元素。</p>
</blockquote>
<a id="more"></a>
<h1 id="一-inline元素、block元素、inline-block元素的具体解释"><a href="#一-inline元素、block元素、inline-block元素的具体解释" class="headerlink" title="一.inline元素、block元素、inline-block元素的具体解释"></a>一.inline元素、block元素、inline-block元素的具体解释</h1><h2 id="inline元素"><a href="#inline元素" class="headerlink" title="inline元素"></a>inline元素</h2><p>inline元素全称Inline Elements，英文原意:An inline element does not start on a new line and only takes up as much width as necessary.一个内联元素不会开始新的一行，并且只占有必要的宽度。</p>
<p><strong>特点:</strong></p>
<ul>
<li>和其他元素都在一行上；</li>
<li>元素的高度、宽度、行高及顶部和底部边距不可设置；</li>
<li>元素的宽度就是它包含的文字或图片的宽度，不可改变。</li>
</ul>
<h2 id="block元素"><a href="#block元素" class="headerlink" title="block元素"></a>block元素</h2><p>block元素全称Block-level Elements，英文原意:A block-level element always starts on a new line and takes up the full width available (stretches out to the left and right as far as it can).一个块级元素总是开始新的一行，并且占据可获得的全部宽度(左右都会尽可能的延伸到它能延伸的最远)</p>
<p><strong>特点:</strong></p>
<ul>
<li>每个块级元素都从新的一行开始，并且其后的元素也另起一行。（一个块级元素独占一行）;</li>
<li>元素的高度、宽度、行高以及顶和底边距都可设置;</li>
<li>元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。</li>
</ul>
<h2 id="inline-block元素"><a href="#inline-block元素" class="headerlink" title="inline-block元素"></a>inline-block元素</h2><p>inline-block元素，英文释义:inline-block elements are like inline elements but they can have a width and a height.它像内联元素，但具有宽度和高度。</p>
<p><strong>特点:</strong></p>
<ul>
<li>和其他元素都在一行上；</li>
<li>元素的高度、宽度、行高以及顶和底边距都可设置</li>
</ul>
<h1 id="二-常见的inline元素、block元素、inline-block元素"><a href="#二-常见的inline元素、block元素、inline-block元素" class="headerlink" title="二.常见的inline元素、block元素、inline-block元素"></a>二.常见的inline元素、block元素、inline-block元素</h1><h2 id="常见的inline内联元素："><a href="#常见的inline内联元素：" class="headerlink" title="常见的inline内联元素："></a>常见的inline内联元素：</h2><p>span、img、a、lable、input、abbr（缩写）、em（强调）、big、cite（引用）、i（斜体）、q（短引用）、textarea、select、small、sub、sup，strong、u（下划线）、button（默认display：inline-block））</p>
<h2 id="常见的block块级元素："><a href="#常见的block块级元素：" class="headerlink" title="常见的block块级元素："></a>常见的block块级元素：</h2><p>div、p、h1…h6、ol、ul、dl、table、address、blockquote、form</p>
<h2 id="常见的inline-block内联块元素："><a href="#常见的inline-block内联块元素：" class="headerlink" title="常见的inline-block内联块元素："></a>常见的inline-block内联块元素：</h2><p>img、input</p>
<h1 id="三-的inline元素、block元素、inline-block元素的区别"><a href="#三-的inline元素、block元素、inline-block元素的区别" class="headerlink" title="三.的inline元素、block元素、inline-block元素的区别"></a>三.的inline元素、block元素、inline-block元素的区别</h1><ul>
<li><p>块级元素会独占一行，而内联元素和内联块元素则会在一行内显示。</p>
</li>
<li><p>块级元素和内联块元素可以设置 width、height 属性，而内联元素设置无效。</p>
</li>
<li><p>块级元素的 width 默认为 100%，而内联元素则是根据其自身的内容或子元素来决定其宽度。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>如何理解盒模型及其content、padding、border、margin？</title>
    <url>/2018/10/03/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%831/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%85%B6content%E3%80%81padding%E3%80%81border%E3%80%81margin%EF%BC%9F/</url>
    <content><![CDATA[<p>如何理解盒模型及其content、padding、border、margin？</p>
<blockquote>
<p>当对一个文档进行布局(laying out)的时候，浏览器渲染引擎会根据CSS-Box模型（CSS Basic Box model）将所有元素表示为一个矩形盒子（box)。CSS决定这些盒子的大小，位置以及属性（颜色，背景，边框尺寸…).</p>
</blockquote>
<a id="more"></a>
<h1 id="一-CSS标准盒子模型"><a href="#一-CSS标准盒子模型" class="headerlink" title="一.CSS标准盒子模型"></a>一.CSS标准盒子模型</h1><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5ydW5vb2IuY29tL2ltYWdlcy9ib3gtbW9kZWwuZ2lm" alt="标准盒子模型">。</p>
<h2 id="1-内容区域content"><a href="#1-内容区域content" class="headerlink" title="1. 内容区域content"></a>1. 内容区域content</h2><p>内容区域content area 是包含元素真实内容的区域。它通常包含背景、颜色或者图片等，位于内容边界的内部，它的大小为内容宽度 或 content-box宽及内容高度或content-box高。</p>
<p>如果 box-sizing 为默认值， width, min-width, max-width, height, min-height 与 max-height 控制内容大小。</p>
<h2 id="2-内边距区域padding"><a href="#2-内边距区域padding" class="headerlink" title="2. 内边距区域padding"></a>2. 内边距区域padding</h2><p>内边距区域padding area 延伸到包围padding的边框。如果内容区域content area设置了背景、颜色或者图片，这些样式将会延伸到padding上(而不仅仅是作用于内容区域)。它位于内边距边界内部, 它的大小为 padding-box 宽与 padding-box 高。</p>
<p>内边距与内容边界之间的空间可以由 padding-top, padding-right, padding-bottom, padding-left 和简写属性 padding 控制。</p>
<h2 id="3-边框区域border"><a href="#3-边框区域border" class="headerlink" title="3. 边框区域border"></a>3. 边框区域border</h2><p>边框区域border area 是包含边框的区域，扩展了内边距区域。它位于边框边界内部，大小为 border-box 宽和 border-box 高。由 border-width 及简写属性 border控制。</p>
<h2 id="4-外边距区域margin"><a href="#4-外边距区域margin" class="headerlink" title="4.  外边距区域margin"></a>4.  外边距区域margin</h2><p>外边距区域margin area用空白区域扩展边框区域，以分开相邻的元素。它的大小为 margin-box 的高宽。</p>
<p>外边距区域大小由 margin-top, margin-right, margin-bottom, margin-left 及简写属性 margin 控制。</p>
<p><strong>注意</strong>:</p>
<ul>
<li><p>在外边距合并 的情况下，由于盒之间共享外边距，外边距不容易弄清楚。</p>
</li>
<li><p>对于非替换的行内元素来说，尽管内容周围存在内边距与边框，但其占用空间（行高）由 line-height 属性决定。</p>
</li>
</ul>
<h1 id="二-浏览器兼容"><a href="#二-浏览器兼容" class="headerlink" title="二. 浏览器兼容"></a>二. 浏览器兼容</h1><p>一旦为页面设置了恰当的 DTD，大多数浏览器都会按照上面的图示来呈现内容。然而 IE 5 和 6 的呈现却是不正确的。根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。</p>
<p>虽然有方法解决这个问题。但是目前最好的解决方案是回避这个问题。也就是，不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素和子元素。</p>
<p>IE8 及更早IE版本不支持设置填充的宽度和边框的宽度属性。</p>
<p>解决IE8及更早版本不兼容问题可以在HTML页面声明<code>&lt;!DOCTYPE html&gt;</code>即可。</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>webstorm默认配置下的常用快捷键</title>
    <url>/2018/10/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/webstorm%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p>mac book 下文的 ctrl 替换成 command 键。</p><h1 id="查找-代替"><a href="#查找-代替" class="headerlink" title="查找/代替"></a>查找/代替</h1><table>
<thead>
<tr>
<th><strong>快捷键</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ctrl+shift+N</strong></td>
<td>通过文件名快速查找工程内的文件（必记）</td>
</tr>
<tr>
<td><strong>ctrl+shift+alt+N</strong></td>
<td>通过一个字符快速查找位置（必记）</td>
</tr>
<tr>
<td><strong>ctrl+F</strong></td>
<td>在文件内快速查找代码</td>
</tr>
<tr>
<td><strong>F3</strong></td>
<td>查找下一个</td>
</tr>
<tr>
<td><strong>shift+F3</strong></td>
<td>查找上一个</td>
</tr>
<tr>
<td><strong>ctrl+R</strong></td>
<td>文件内代码替换</td>
</tr>
<tr>
<td><strong>ctrl+shift+R</strong></td>
<td>指定目录内代码批量替换</td>
</tr>
<tr>
<td><strong>ctrl+shift+F</strong></td>
<td>指定目录内代码批量查找</td>
</tr>
<tr>
<td><strong>ctrl+R</strong></td>
<td>文件内代码替换</td>
</tr>
</tbody>
</table><a id="more"></a>

<h1 id="界面操作"><a href="#界面操作" class="headerlink" title="界面操作"></a>界面操作</h1><table>
<thead>
<tr>
<th><strong>快捷键</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ctrl+shift+A</strong></td>
<td>快速查找并使用编辑器所有功能（必记）</td>
</tr>
<tr>
<td><strong>alt+[0-9]</strong></td>
<td>快速拆合功能界面模块</td>
</tr>
<tr>
<td><strong>ctrl+shift+F12</strong></td>
<td>最大区域显示代码（会隐藏其他的功能界面模块）</td>
</tr>
<tr>
<td><strong>alt+shift+F</strong></td>
<td>将当前文件加入收藏夹</td>
</tr>
<tr>
<td><strong>ctrl+alt+s</strong></td>
<td>打开配置窗口</td>
</tr>
<tr>
<td><strong>ctrl+tab</strong></td>
<td>切换代码选项卡（还要进行此选择，效率差些）</td>
</tr>
<tr>
<td><strong>alt+&lt;-或-&gt;</strong></td>
<td>切换代码选项卡</td>
</tr>
</tbody>
</table>
<h1 id="代码编辑-必记"><a href="#代码编辑-必记" class="headerlink" title="代码编辑(必记)"></a>代码编辑(必记)</h1><table>
<thead>
<tr>
<th><strong>快捷键</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ctrl+D</strong></td>
<td>复制当前行</td>
</tr>
<tr>
<td><strong>ctrl+W</strong></td>
<td>选中单词</td>
</tr>
<tr>
<td><strong>ctrl+&lt;-或-&gt;</strong></td>
<td>以单词作为边界跳光标位置</td>
</tr>
<tr>
<td><strong>alt+Insert</strong></td>
<td>新建一个文件或其他</td>
</tr>
<tr>
<td><strong>ctrl+alt+L</strong></td>
<td>格式化代码</td>
</tr>
<tr>
<td><strong>shift+tab/tab</strong></td>
<td>减少/扩大缩进（可以在代码中减少行缩进）</td>
</tr>
<tr>
<td><strong>ctrl+Y</strong></td>
<td>删除一行</td>
</tr>
<tr>
<td><strong>shift+enter</strong></td>
<td>重新开始一行（无论光标在哪个位置）</td>
</tr>
</tbody>
</table>
<h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><table>
<thead>
<tr>
<th><strong>快捷键</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>esc</strong></td>
<td>进入代码编辑区域</td>
</tr>
<tr>
<td><strong>alt+F1</strong></td>
<td>查找代码在其他界面模块的位置，颇为有用</td>
</tr>
<tr>
<td><strong>ctrl+G</strong></td>
<td>到指定行的代码</td>
</tr>
<tr>
<td><strong>ctrl+]/[</strong></td>
<td>光标到代码块的前面或后面</td>
</tr>
<tr>
<td><strong>alt+up/down</strong></td>
<td>上一个/下一个方法</td>
</tr>
</tbody>
</table>
<h1 id="建议配置版本控制快捷键"><a href="#建议配置版本控制快捷键" class="headerlink" title="建议配置版本控制快捷键"></a>建议配置版本控制快捷键</h1><table>
<thead>
<tr>
<th><strong>快捷键</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ctrl+C</strong></td>
<td>提交代码</td>
</tr>
<tr>
<td><strong>ctrl+p</strong></td>
<td>向远程版本库推送更新</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title>加和不加meta的viewport有什么区别？</title>
    <url>/2018/10/03/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%831/%E5%8A%A0%E5%92%8C%E4%B8%8D%E5%8A%A0meta%E7%9A%84viewport%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<blockquote>
<p>在使用视窗宽度vw时，需要加入一个<code>&lt;meta&gt;</code>标签，这个标签究竟起什么作用，如果不加对网页有何影响呢？</p>
</blockquote>
<a id="more"></a>
<h1 id="什么是viewport？"><a href="#什么是viewport？" class="headerlink" title="什么是viewport？"></a>什么是viewport？</h1><p><strong>vieport</strong>是用户在网页上的可见区域。 </p>
<h1 id="什么是meta？"><a href="#什么是meta？" class="headerlink" title="什么是meta？"></a>什么是meta？</h1><p>w<br><code>&lt;meta&gt;</code>是HTML5中引入的一种使设计人员标记控制<strong>vieport</strong>的标签。</p>
<h1 id="为什么要加入-lt-meta-gt-，不加会有什么影响？"><a href="#为什么要加入-lt-meta-gt-，不加会有什么影响？" class="headerlink" title="为什么要加入&lt;meta&gt;，不加会有什么影响？"></a>为什么要加入<code>&lt;meta&gt;</code>，不加会有什么影响？</h1><p><strong>vieport</strong>随设备而异，并且在移动电话上会比在计算机屏幕上小。</p>
<p>在平板电脑和手机之前，网页仅设计用于计算机屏幕，并且网页具有静态设计和固定大小是很常见的。</p>
<p>然后，当我们开始使用平板电脑和手机上网时，固定大小的网页太大，无法容纳视口。要解决此问题，这些设备上的浏览器会<strong>按比例缩小整个网页以适合屏幕大小</strong>。这样用户的观看体验会比较差！这不是完美的！</p>
<h2 id="如何使用-lt-meta-gt-？"><a href="#如何使用-lt-meta-gt-？" class="headerlink" title="如何使用 &lt;meta&gt;？"></a>如何使用 <code>&lt;meta&gt;</code>？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;meta&gt;</code>标签是如何控制网页的尺寸和缩放浏览器的说明。</p>
<p><strong>width=device-width</strong>部分将页面的宽度设置为跟随设备的屏幕宽度（视设备而定）。</p>
<p><strong>initial-scale=1.0</strong>部分设置浏览器首次加载页面时的初始缩放级别。</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>IDE是什么？它和文本编辑器相比有什么优缺点？</title>
    <url>/2018/10/03/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%831/IDE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E5%92%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F/</url>
    <content><![CDATA[<blockquote>
<p>在我们学习it的时候，不可避免的会遇到一个问题，那就是我们使用什么来编写代码呢？</p>
</blockquote>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h2><p>文本编辑器是计算机软件中的一种。主要用于用来编写和查看文本文件。</p>
<h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>IDE是带有软件开发功能的“集成开发环境”。  </p>
<p>集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。</p>
<h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>节省时间和精力。IDE的目的就是要让开发更加快捷方便，通过提供工具和各种性能来帮助开发者组织资源，减少失误，提供捷径。</li>
<li>建立统一标准。当一组程序员使用同一个开发环境时，就建立了统一的工作标准，当IDE提供预设的模板，或者不同团队分享代码库时，这一效果就更加明显了。</li>
<li>管理开发工作。首先，IDE提供文档工具，可以自动输入开发者评论，或者迫使开发者在不同区域编写评论。其次，IDE可以展示资源，更便于发现应用所处位置，无需在文件系统里面艰难的搜索。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>学习曲线问题。IDE基本上是比较复杂的工具，为了更好的熟练使用，需要一定的时间和耐心。</li>
<li>初学者的困难。对初学者来说，使用IDE来学习开发有相当的难度，不适合学习一种新语言时使用。</li>
<li>无法修复坏代码或设计。开发者不能完全依赖工具的便捷，还是必须保持专业水准和熟练度，开发的成果好坏主要还是看开发员的技术。</li>
</ul>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title>九宫格的布局你还能想到哪些办法实现？它们各自的优势劣势是什么？</title>
    <url>/2018/10/03/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%831/%E4%B9%9D%E5%AE%AB%E6%A0%BC%E7%9A%84%E5%B8%83%E5%B1%80%E4%BD%A0%E8%BF%98%E8%83%BD%E6%83%B3%E5%88%B0%E5%93%AA%E4%BA%9B%E5%8A%9E%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%E5%AE%83%E4%BB%AC%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E5%8A%BF%E5%8A%A3%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<blockquote>
<p>九宫格布局是我们在网页开发中常用的布局之一，那么如何使用代码完成它呢？</p>
</blockquote>
<a id="more"></a>
<h1 id="设置垂直方向的padding撑开容器"><a href="#设置垂直方向的padding撑开容器" class="headerlink" title="设置垂直方向的padding撑开容器"></a>设置垂直方向的padding撑开容器</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div.box &#123;</span><br><span class="line">    width: 30%;</span><br><span class="line">    padding-bottom: 30%;</span><br><span class="line">    margin: 1%;</span><br><span class="line">    background-color: orange;</span><br><span class="line">    float: left;</span><br><span class="line">    border-radius: 5%;</span><br><span class="line">&#125;</span><br><span class="line">div &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">   padding-bottom: 30%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 CSS 盒模型中，一个比较容易被忽略的就是 margin, padding 的百分比数值计算。按照规定，margin, padding 的百分比数值是相对 父元素宽度 的宽度计算的。由此可以发现只需将元素垂直方向的一个 padding 值设定为与 width 相同的百分比就可以制作出自适应正方形了：</p>
<p>优点：简洁明了，且兼容性好</p>
<p>缺点：填充内容后会出现问题</p>
<h1 id="viewport-使用vw单位"><a href="#viewport-使用vw单位" class="headerlink" title="viewport 使用vw单位"></a>viewport 使用vw单位</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div.box &#123;</span><br><span class="line">    width: 30vw;</span><br><span class="line">    height: 30vw;</span><br><span class="line">    margin: 1vw;</span><br><span class="line">    background-color: orange;</span><br><span class="line">    float: left;</span><br><span class="line">    border-radius: 5%;</span><br><span class="line">&#125;</span><br><span class="line">div &#123;</span><br><span class="line">    width: 100vw;</span><br><span class="line">    height: 100vw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：简洁方便</p>
<p>缺点：浏览器兼容不好</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML文件里开头的!Doctype有什么作用？</title>
    <url>/2018/10/03/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%831/HTML%E6%96%87%E4%BB%B6%E9%87%8C%E5%BC%80%E5%A4%B4%E7%9A%84-Doctype%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<blockquote>
<p>每个 HTML 文件里开头都有个很重要的东西<code>&lt;!DOCTYPE html&gt;</code>,DOCTYPE是document type的简写，它并不是 HTML 标签，也没有结束标签，它是一种标记语言的文档类型声明，即告诉浏览器当前 HTML 是用什么版本编写的。</p>
</blockquote>
<a id="more"></a>
<h1 id="一-背景介绍"><a href="#一-背景介绍" class="headerlink" title="一. 背景介绍"></a>一. 背景介绍</h1><h2 id="什么是DOCTYPE"><a href="#什么是DOCTYPE" class="headerlink" title="什么是DOCTYPE?"></a>什么是DOCTYPE?</h2><p>DOCTYPE是document type的简写，它并不是 HTML 标签，也没有结束标签，它是一种标记语言的文档类型声明，即告诉浏览器当前 HTML 是用什么版本编写的。</p>
<p><strong>注意</strong>: DOCTYPE的声明必须是 HTML 文档的第一行，位于html标签之前。大多数Web文档的顶部都有doctype声明，它是在新建一个文档时，由Web创作软件草率处理的众多细节之一。很少人会去注意 doctype ，但在遵循标准的任何Web文档中，它都是一项必需的元素。doctype会影响代码验证，并决定了浏览器最终如何显示你的 Web文档。</p>
<h1 id="二-知识剖析"><a href="#二-知识剖析" class="headerlink" title="二. 知识剖析"></a>二. 知识剖析</h1><h2 id="DOCTYPE的作用"><a href="#DOCTYPE的作用" class="headerlink" title="DOCTYPE的作用?"></a>DOCTYPE的作用?</h2><p>DOCTYPE是document type(文档类型)的简写，在web设计中用来声明文档类型。<br>在所有 HTML 文档中规定 DOCTYPE 是非常重要的，这样浏览器就能了解预期的文档类型， 告诉浏览器要通过哪一种规范（DTD）解析文档（比如HTML或XHTML规范）。<br>DOCTYPE会影响代码验证，并决定了浏览器最终如何显示你的Web文档。</p>
<h2 id="HTML-4-01-和-HTML5-中-DOCTYPE的区别"><a href="#HTML-4-01-和-HTML5-中-DOCTYPE的区别" class="headerlink" title="HTML 4.01 和 HTML5 中 DOCTYPE的区别"></a>HTML 4.01 和 HTML5 中 DOCTYPE的区别</h2><ul>
<li>HTML 4.01 中的 doctype 需要对 DTD 进行引用，因为 HTML 4.01 基于 SGML。</li>
<li>HTML 5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为（html 5简化了这种声明，意在告诉浏览器使用统一的标准即可）。</li>
</ul>
<h1 id="三-代码实战"><a href="#三-代码实战" class="headerlink" title="三.  代码实战"></a>三.  代码实战</h1><h2 id="如何使用DOCTYPE"><a href="#如何使用DOCTYPE" class="headerlink" title="如何使用DOCTYPE?"></a>如何使用DOCTYPE?</h2><p>HTML 文档的第一行，位于html标签之前  ,引入DOCTYPE声明。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意事项:</strong>DOCTYPE的声明必须是 HTML 文档的第一行，位于html标签之前。在DOCTYPE声明前面出现了这些内容：普通文本、HTML 标签、HTML 注释、XML 声明、IE条件注释,会导致HTML 进入怪异模式.</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用浏览器的F12调试页面</title>
    <url>/2018/10/03/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/CSS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%831/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84F12%E8%B0%83%E8%AF%95%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<blockquote>
<p>一个程序员按照要求编写一个网页，不可能一次编写就完全达到目的，一般要对自己的的代码修改调试几次后才能到达要求，浏览器的F12开发人员工具就可以很方便的帮助程序员调试自己的代码。</p>
</blockquote>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>F12 开发人员工具是一套按需采用的工具，网站开发人员可以随时在任何网页上使用 F12 工具，从而快速调试 JavaScript、HTML 和级联样式表 (CSS)，还可以跟踪并查明网页或网络的性能问题。</p>
<h1 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h1><p>项目： </p>
<p> element（元素）标签页：可以查看代码  </p>
<p>sources（软件源）标签页：可以选取css文件、html文件并进行修改  </p>
<p>快捷键：  </p>
<p>ctrl+shift+c 选取元素进行查看  </p>
<p>ctrl+shift+m 模拟移动端进行查看 </p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
        <category>深度思考</category>
      </categories>
      <tags>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo快速入门</title>
    <url>/2018/09/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/hexo%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="创建一篇新文章"><a href="#创建一篇新文章" class="headerlink" title="创建一篇新文章"></a>创建一篇新文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>详细信息: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="启用本地预览服务"><a href="#启用本地预览服务" class="headerlink" title="启用本地预览服务"></a>启用本地预览服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>详细信息: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>详细信息: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>详细信息: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
  </entry>
  <entry>
    <title>js取出事件对象中对应的值显示未定义</title>
    <url>/2018/08/30/JS/js%E5%8F%96%E5%87%BA%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%AF%B9%E5%BA%94%E7%9A%84%E5%80%BC%E6%98%BE%E7%A4%BA%E6%9C%AA%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<blockquote>
<p>问题描述:微信小程序使用<code>data-*</code>向事件内存储对象,js中取出对应值时显示未定义.</p>
</blockquote>
<a id="more"></a>
<p>wxml<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;text class=&quot;authorName db&quot; catchtap=&quot;toListDetail&quot; data-videoId=&quot;&#123;&#123;item.id&#125;&#125;&quot;&gt;&#123;&#123;item.teacher&#125;&#125;&lt;/text&gt;</span><br></pre></td></tr></table></figure></p>
<p>js<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toListDetail:function (event) &#123;</span><br><span class="line">       let videoId = event.target.dataset.videoId;</span><br><span class="line">       console.log(videoId);//undefined</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>#问题出现原因:<br><code>data-*</code>书写方式： 以data-开头，多个单词由连字符-链接，连字符转成驼峰,不能有大写,大写会自动转成小写;</p>
<ul>
<li>如data-element-type，最终在 event.currentTarget.dataset 中会将连字符转成驼峰elementType。</li>
<li>如data-videoId，最终在 event.currentTarget.dataset 中大写会自动转成小写  videoid。<br>| wxml  |  event.currentTarget.dataset |<br>| ———— | ———— |<br>|  data-element-type |  elementType |<br>| data-videoId  |  videoid |</li>
</ul>
<h1 id="问题解决办法"><a href="#问题解决办法" class="headerlink" title="问题解决办法:"></a>问题解决办法:</h1><ul>
<li>在组件中使用<code>data-*</code>定义数据，注意字母大小写.</li>
<li>需要使用驼峰命名的时候,以连字符拼接.</li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
        <category>遇到的问题</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序setData中键名key中使用变量</title>
    <url>/2018/08/30/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FsetData%E4%B8%AD%E9%94%AE%E5%90%8Dkey%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<blockquote>
<p>setData 函数用于将数据从逻辑层发送到视图层（异步）,同时改变对应的 this.data 的值（同步）.setData中可以传入的参数Object 以 key: value 的形式表示,将 this.data 中的 key 对应的值改变成 value。其中 key 可以以数据路径的形式给出，支持改变数组中的某一项或对象的某个属性,有时我们需要在使用变量表示key,这时应该如何操作呢.</p>
</blockquote>
<a id="more"></a>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述:"></a>问题描述:</h1><p><strong>例一:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binddata: function (e) &#123;</span><br><span class="line">      var idNum = e.target.id;</span><br><span class="line">      this.setData(&#123; idNum: e.detail.value &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>idNum传过去，直接是data中多了一个’idNum’的数据，不是动态的id数值.</p>
<p><strong>例二:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">changeIntro:function (event) &#123;</span><br><span class="line">     let videoArrayIndex = event.target.dataset.index;</span><br><span class="line">     this.setData(&#123;</span><br><span class="line">         &apos;videoArray[videoArrayIndex].introState&apos; : true</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>无法改变introState的值,因为videoArrayIndex没有被解析为序列号.</p>
<p>#解决办法:</p>
<p>##一. 用一个空对象暂存<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var data = &#123;&#125;</span><br><span class="line">data[key] = value // key 可以是任何字符串</span><br><span class="line">this.setData(data)</span><br></pre></td></tr></table></figure></p>
<p>使用一个中间对象暂存解决上述例二<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">changeIntro:function (event) &#123;</span><br><span class="line">        let videoArrayIndex = event.target.dataset.index;</span><br><span class="line">        let dataIntro = &#123;&#125;;</span><br><span class="line">        let keyIntro = &apos;videoArray[&apos;+videoArrayIndex+&apos;].introState&apos;;</span><br><span class="line">        dataIntro[keyIntro] = true; // key 可以是任何字符串</span><br><span class="line">        this.setData(dataIntro)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二-使用es6新特性"><a href="#二-使用es6新特性" class="headerlink" title="二. 使用es6新特性"></a>二. 使用es6新特性</h2><p>ES6 允许声明在对象字面量时使用简写语法，来初始化属性变量和函数的定义方法，并且允许在对象属性中进行计算操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.setData(&#123;</span><br><span class="line">           [key]: value</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure></p>
<p>使用es6新特性解决上述例二<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">changeIntro:function (event) &#123;</span><br><span class="line">      let videoArrayIndex = event.target.dataset.index;</span><br><span class="line">      this.setData(&#123;</span><br><span class="line">          [&apos;videoArray[&apos;+videoArrayIndex+&apos;].introState&apos;] : true</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序实现视图向js传递参数</title>
    <url>/2018/08/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E8%A7%86%E5%9B%BE%E5%90%91js%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>有时候我们需要从小程序的视图页面向js文件传递参数,通过阅读官方文档发现可以通过向事件触发时绑定的事件对象存储数据达到效果.</p>
</blockquote>
<a id="more"></a>
<p>#实现原理<br>如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。<br><strong>微信小程序中的事件对象</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">type</td>
<td style="text-align:center">String</td>
<td style="text-align:center">事件类型</td>
</tr>
<tr>
<td style="text-align:center">timeStamp</td>
<td style="text-align:center">Integer</td>
<td style="text-align:center">事件生成时的时间戳</td>
</tr>
<tr>
<td style="text-align:center">target</td>
<td style="text-align:center">Object</td>
<td style="text-align:center">触发事件的组件的一些属性值集合</td>
</tr>
<tr>
<td style="text-align:center">currentTarget</td>
<td style="text-align:center">Object</td>
<td style="text-align:center">当前组件的一些属性值集合</td>
</tr>
</tbody>
</table>
<p>视图层上可以通过设置<code>data-*</code>向事件对象中存储数据,js中可以获取该事件对象<code>event</code>并取出其中存储的数据,从而达到视图页面向js文件传递参数的效果.<br><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html" target="_blank" rel="noopener">事件对象详解</a></p>
<h1 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h1><p><strong>wxml</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;view&gt;</span><br><span class="line">   &lt;button bindtap=&quot;showMoreText&quot; data-index=&quot;向js传递索引号&quot;&gt;</span><br><span class="line">    更多</span><br><span class="line">   &lt;/button&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>js</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    showMoreText:function (event) &#123;</span><br><span class="line">        console.log(event);</span><br><span class="line">        console.log(event.target.dataset.index)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown中使用html标签</title>
    <url>/2018/08/28/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Markdown%E4%B8%AD%E4%BD%BF%E7%94%A8html%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<blockquote>
<p>有时候,我们会在笔记中使用一些HTML标签,但是Markdown中直接使用html标签会被解析为格式.该怎么书写，可以直接显示为html的标签呢.</p>
</blockquote>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;这是一个标题&lt;/h1&gt;</span><br><span class="line">//其中的&lt;h1&gt;这是一个标题&lt;/h1&gt;总是会被解析为成html标签，而不是直接显示为html标签。</span><br></pre></td></tr></table></figure>
<h2 id="问题出现原因："><a href="#问题出现原因：" class="headerlink" title="问题出现原因："></a>问题出现原因：</h2><p>Markdown支持html语法，所以会对相应的标签进行解析。</p>
<h2 id="问题解决办法："><a href="#问题解决办法：" class="headerlink" title="问题解决办法："></a>问题解决办法：</h2><ol>
<li>使用引号把标签包起来<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`&lt;h1&gt;这是一个标题&lt;/h1&gt;`</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>&lt;h1&gt;这是一个标题&lt;/h1&gt;</code></p>
<ol start="2">
<li>使用转义字符来表示相应的标签<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;lt;h1&amp;gt;这是一个标题&amp;lt;/h1&amp;gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&lt;h1&gt;这是一个标题&lt;/h1&gt;</p>
<hr>
<blockquote>
<p>相关工具： <a href="http://www.css88.com/tool/html-escape/" target="_blank" rel="noopener">HTML在线转义工具</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工具使用</category>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序页面跳转</title>
    <url>/2018/08/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<blockquote>
<p>路由：路由在项目开发中一直是个核心点，在这里其实微信对路由的介绍很少，可见微信在路由方面经过很好的封装，也提供三个跳转方法。</p>
</blockquote>
<a id="more"></a>
<h1 id="三个跳转方法"><a href="#三个跳转方法" class="headerlink" title="三个跳转方法"></a>三个跳转方法</h1><ul>
<li>wx.navigateTo(OBJECT)：保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。</li>
<li>wx.redirectTo(OBJECT)：关闭当前页面，跳转到应用内的某个页面。</li>
<li>wx.navigateBack()：关闭当前页面，回退前一页面。<br>这三个基本上使用足够，在路由方面微信封装的很好，开发者根本不用去配置路由，往往很多框架在路由方面配置很繁琐。</li>
</ul>
<h1 id="问题描述：路由跳转失败"><a href="#问题描述：路由跳转失败" class="headerlink" title="问题描述：路由跳转失败"></a>问题描述：路由跳转失败</h1><p><strong>出现原因</strong>：没有仔细看说明文档，需要在app。json中配置路由跳转的地址<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;pages&quot;:[</span><br><span class="line">    &quot;pages/personChoice/personChoice&quot;,</span><br><span class="line">    &quot;pages/result/result&quot;,</span><br><span class="line">    &quot;pages/index/index&quot;,</span><br><span class="line">    &quot;pages/logs/logs&quot;</span><br><span class="line">    </span><br><span class="line">  ],</span><br><span class="line">  &quot;window&quot;:&#123;</span><br><span class="line">    &quot;backgroundTextStyle&quot;:&quot;light&quot;,</span><br><span class="line">    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,</span><br><span class="line">    &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;,</span><br><span class="line">    &quot;navigationBarTextStyle&quot;:&quot;black&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解决办法：仔细看说明文档<br><strong>注意</strong>:微信小程序的跳转有个坑。只能保留10个页面。历史记录有十个页面之后，跳转会失效。所以要适当的清除历史记录。</p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序上拉加载和下拉刷新</title>
    <url>/2018/08/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/</url>
    <content><![CDATA[<blockquote>
<p><strong>说明</strong>：要触发下拉刷新上拉加载事件，需要能够监听到事件才行 ,在需要实现下拉刷新上拉加载的页面配置对应页面xxx.json文件或者更改全局的app.json文件.</p>
</blockquote>
<a id="more"></a>
<h1 id="更改页面配置xxx-json文件"><a href="#更改页面配置xxx-json文件" class="headerlink" title="更改页面配置xxx.json文件"></a>更改页面配置xxx.json文件</h1><p>页面配置xxx.json文件中添加以下字段<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;enablePullDownRefresh&quot;:true,//是否开启下拉刷新</span><br><span class="line">    &quot;backgroundTextStyle&quot;:&quot;dark&quot;,//下拉背景字体、loading 图的样式，仅支持 dark/light，默认light不可见</span><br><span class="line">    &quot;onReachBottomDistance&quot;: 50//页面上拉触底事件触发时距页面底部距离，单位为px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="自定义上拉记载触发的函数"><a href="#自定义上拉记载触发的函数" class="headerlink" title="自定义上拉记载触发的函数"></a>自定义上拉记载触发的函数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line"> onReachBottom: function() &#123;</span><br><span class="line">        wx.showToast(&#123;</span><br><span class="line">            title: &apos;上拉触底&apos;,</span><br><span class="line">            icon: &apos;success&apos;,</span><br><span class="line">            duration: 2000</span><br><span class="line">        &#125;);</span><br><span class="line">        console.log(&apos;--------上拉触底-------&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序将时间戳转化为几天前</title>
    <url>/2018/08/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B0%86%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%87%A0%E5%A4%A9%E5%89%8D/</url>
    <content><![CDATA[<blockquote>
<p><strong>需求描述: </strong>文件创建时间与当前时间小于24小时,显示小时数,大于24小时,显示天数,时间戳转化为几天前，几小时前，几分钟前</p>
</blockquote>
<a id="more"></a>
<h1 id="代码演示wxs"><a href="#代码演示wxs" class="headerlink" title="代码演示wxs:"></a>代码演示wxs:</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getDateDiff = function (dateTimeStamp) &#123;</span><br><span class="line">    var minute = 1000 * 60;</span><br><span class="line">    var hour = minute * 60;</span><br><span class="line">    var day = hour * 24;</span><br><span class="line">    var halfamonth = day * 15;</span><br><span class="line">    var month = day * 30;</span><br><span class="line">    var now = getDate();//有些特殊 不能使用 new Date()</span><br><span class="line">    var diffValue = now - dateTimeStamp;</span><br><span class="line">    if(diffValue &lt; 0)&#123;return;&#125;</span><br><span class="line">    var monthC =diffValue/month;</span><br><span class="line">    var weekC =diffValue/(7*day);</span><br><span class="line">    var dayC =diffValue/day;</span><br><span class="line">    var hourC =diffValue/hour;</span><br><span class="line">    var minC =diffValue/minute;</span><br><span class="line">    if(monthC&gt;=1)&#123;</span><br><span class="line">        result=&quot;&quot; + parseInt(monthC) + &quot;月前&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(weekC&gt;=1)&#123;</span><br><span class="line">        result=&quot;&quot; + parseInt(weekC) + &quot;周前&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(dayC&gt;=1)&#123;</span><br><span class="line">        result=&quot;&quot;+ parseInt(dayC) +&quot;天前&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(hourC&gt;=1)&#123;</span><br><span class="line">        result=&quot;&quot;+ parseInt(hourC) +&quot;小时前&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(minC&gt;=1)&#123;</span><br><span class="line">        result=&quot;&quot;+ parseInt(minC) +&quot;分钟前&quot;;</span><br><span class="line">    &#125;else</span><br><span class="line">        result=&quot;刚刚&quot;;</span><br><span class="line">    return result;</span><br><span class="line">&#125;;//时间戳转化为几天前，几小时前，几分钟前</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>wxs</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序视图层处理增强之WXS</title>
    <url>/2018/08/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%A7%86%E5%9B%BE%E5%B1%82%E5%A4%84%E7%90%86%E5%A2%9E%E5%BC%BA%E4%B9%8BWXS/</url>
    <content><![CDATA[<blockquote>
<p>WXS是专供WXML调用的有独立作用域的JS模块（不是全功能的JS，感觉有所限制）,可以在在视图层对数据进行格式化处理,起到过滤器的作用。</p>
</blockquote>
<a id="more"></a>
<p>熟悉微信小程序开发框架的开发者，肯定会对其视图层WXML中缺失的一个功能耿耿于怀，那就是没有办法在视图层对数据进行格式化处理。比如我们从后端获取到一个包含了时间戳数据的数组，然后需要在界面上把这些日期都格式化显示为2017-01-01这种格式的日期形式，在Vue, Angular之类的前端Web框架中，一般在视图层都提供了如filter之类相应比较好用的方案。<br>而在现有的微信小程序代码中？你能怎么做？估计我们的做法要么是在Page代码中遍历一次数组，做一下格式化；要么，只能让后端返回已经格式化好的数据了。</p>
<p>举个例子，在这之前，我们是没有办法在WXML的数据绑定括号<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>中调用JS函数的，所以在WXML层面就缺少了进一步做数据处理的能力。<br>下列代码是不工作的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- wxml文件 --&gt;</span><br><span class="line">&lt;view&gt;&#123;&#123;testFunc(name)&#125;&#125;&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">// some-page.js</span><br><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: &quot;一斤代码&quot;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    testFunc: function (name) &#123;</span><br><span class="line">          return &quot;Hello,&quot; + name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>而有了WXS之后，我们就可以实现我们预期的功能了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- wxml文件 --&gt;</span><br><span class="line">&lt;view&gt;&#123;&#123;myModule.testFunc(name)&#125;&#125;&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;wxs module=&quot;myModule&quot;&gt;</span><br><span class="line">    function testFunc(name) &#123;</span><br><span class="line">        return &quot;Hello,&quot; + name</span><br><span class="line">    &#125;</span><br><span class="line">    module.exports.testFunc = testFunc</span><br><span class="line">&lt;/wxs&gt;</span><br><span class="line"></span><br><span class="line">// some-page.js</span><br><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: &quot;一斤代码&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>WXS可以直接定义在wxml文件的<wxs>标签体中，也可以写在独立的.wxs后缀名的文件中，然后在wxml文件中通过<wxs src="...">的形式引入。<br>如要要在WXS代码中去引用其他独立.wxs文件，可以通过 require()函数来引入，基本上都是我们熟悉的方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var formatUtil = require(&quot;./format-util.wxs&quot;);</span><br><span class="line">var now = getDate()</span><br><span class="line"></span><br><span class="line">formatUtil.formatDate(now)</span><br></pre></td></tr></table></figure></wxs></wxs></p>
<p>所以，WXS在功能方面，并没有什么复杂的东西，唯一需要特别注意一些的，就是它的作用域了：</p>
<ul>
<li><wxs> 模块只能在定义模块的 WXML 文件中被访问到。使用 <include> 或 <import> 时，<wxs> 模块不会被引入到对应的 WXML 文件中。</wxs></import></include></wxs></li>
<li><template> 标签中，只能使用定义该 <template> 的 WXML 文件中定义的 <wxs> 模块。</wxs></template></template></li>
</ul>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>wxs</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序设置过滤器将时间戳转化为日期字符串</title>
    <url>/2018/08/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B0%86%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%97%A5%E6%9C%9F%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<blockquote>
<p>在微信开发小程序时，后台传入的日期数据可能是<strong>时间戳 </strong>而不是日期, 或者需要把日期转换成时间戳来做出相应的处理时,我们将用到时间戳和日期的相互转换.</p>
</blockquote>
<a id="more"></a>
<p>WXS是专供WXML调用的有独立作用域的JS模块（不是全功能的JS，感觉有所限制）,可以在在视图层对数据进行格式化处理,起到过滤器的作用。</p>
<h1 id="js文件"><a href="#js文件" class="headerlink" title="js文件"></a>js文件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    timestamp: 1522117395730</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="wxml文件"><a href="#wxml文件" class="headerlink" title="wxml文件"></a>wxml文件</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;wxs module=&quot;m1&quot;&gt;</span><br><span class="line">  function format(ts) &#123;</span><br><span class="line">    var d = getDate(ts)</span><br><span class="line">    return [d.getFullYear(), d.getMonth()+1, d.getDate()].join(&apos;-&apos;)</span><br><span class="line">      + &apos; &apos;</span><br><span class="line">      + [d.getHours(), d.getMinutes(), d.getSeconds()].join(&apos;:&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  module.exports.format = format</span><br><span class="line">&lt;/wxs&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt;&#123;&#123; timestamp &#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;view&gt;&#123;&#123; m1.format(timestamp) &#125;&#125;&lt;/view&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong>wxs 获取当前日期不可以使用 new Date()，而需要使用 getDate() 代替。</p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>wxs</tag>
      </tags>
  </entry>
  <entry>
    <title>简述JavaScript中this的指向</title>
    <url>/2018/08/27/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%834/%E7%AE%80%E8%BF%B0JavaScript%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<blockquote>
<p><strong>this的指向</strong>：本文重点介绍this作为对象方法调用，作为函数调用，作为构造函数调用，和使用apply 或 call 调用这几种，其他的情况了解即可，<br>请牢记一点，<strong>this永远指向的是最后调用它的对象</strong>，也就是看它执行的时候是谁调用的。</p>
</blockquote>
<a id="more"></a>
<h1 id="一-背景介绍"><a href="#一-背景介绍" class="headerlink" title="一.背景介绍"></a>一.背景介绍</h1><p>   在面向对象的语言中（例如Java,C#等)，this含义是明确且具体的，即指向当前对象。一般在编译期绑定。而在javascript中，this是动态绑定的，它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式，并且在严格模式下也有不同，这就导致了this具备了多重含义，可以使得javascript更灵活的使用。但是，带来了灵活性的同时也会给我们初学者带来不少困惑。即使是细微的语法变化，都有可能意外改变this的值。</p>
<h1 id="二-知识剖析"><a href="#二-知识剖析" class="headerlink" title="二.知识剖析"></a>二.知识剖析</h1><p>JavaScript中函数的调用常用的有以下几种方式：</p>
<ul>
<li>作为对象方法调用</li>
<li>作为函数调用</li>
<li>作为构造函数调用</li>
<li>使用apply 或 call 调用</li>
</ul>
<p>下面我们将按照调用方式的不同，分别讨论this 的含义</p>
<p>1.纯粹的作为函数调用：全局函数中，this指向window</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>
<p>2.作为对象方法的调用：当函数被作为某个对象的方法调用时，this就是那个对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name = &apos;火影&apos;;</span><br><span class="line">var person2 = &#123;</span><br><span class="line">    name: &apos;水影&apos;,</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var sayNameWin = person2.sayName;</span><br><span class="line">person2.sayName(); //水影</span><br><span class="line">sayNameWin(); //火影 作为 window 的方法被调用的</span><br></pre></td></tr></table></figure>
<p>3.作为构造函数调用：this指向新对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person3(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">var person3 = new Person3(&apos;张飒&apos;);</span><br><span class="line">console.log(person3.name); //张飒</span><br></pre></td></tr></table></figure>
<p>4.apply、call调用：this指向改变后的调用这个函数的对象<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person4 = &#123;</span><br><span class="line">    name: &apos;人才&apos;</span><br><span class="line">&#125;;</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(this); //Object &#123;name: &quot;人才&quot;&#125;</span><br><span class="line">    console.log(this.name); //人才</span><br><span class="line">&#125;</span><br><span class="line">fn.apply(person4);</span><br></pre></td></tr></table></figure></p>
<h1 id="三-拓展思考"><a href="#三-拓展思考" class="headerlink" title="三.拓展思考"></a>三.拓展思考</h1><p>如何能加深记忆？<br>this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的。</p>
<h1 id="四-参考文献"><a href="#四-参考文献" class="headerlink" title="四.参考文献"></a>四.参考文献</h1><p><a href="https://www.ibm.com/developerworks/cn/web/1207_wangqf_jsthis/" target="_blank" rel="noopener">深入浅出 JavaScript 中的 this</a><br><a href="http://caibaojian.com/toutiao/6859" target="_blank" rel="noopener">JavaScript中的this用法与指向</a><br><a href="https://www.zhihu.com/question/19636194" target="_blank" rel="noopener">如何理解 JavaScript 中的 this 关键字？</a></p>
<h1 id="五-更多讨论"><a href="#五-更多讨论" class="headerlink" title="五.更多讨论"></a>五.更多讨论</h1><h2 id="1-如果想让一个this指向函数内部，但是它指向了全局，有什么办法让它指向函数内部？"><a href="#1-如果想让一个this指向函数内部，但是它指向了全局，有什么办法让它指向函数内部？" class="headerlink" title="1. 如果想让一个this指向函数内部，但是它指向了全局，有什么办法让它指向函数内部？"></a>1. 如果想让一个this指向函数内部，但是它指向了全局，有什么办法让它指向函数内部？</h2><p>使用call方法或者apply方法给它指定this，或者把他作为对象的方法调用</p>
<h2 id="2-setTimeout、setInterval中的this是指向哪里？"><a href="#2-setTimeout、setInterval中的this是指向哪里？" class="headerlink" title="2. setTimeout、setInterval中的this是指向哪里？"></a>2. setTimeout、setInterval中的this是指向哪里？</h2><p>《 javascript 高级程序设计》中写到：“超时调用的代码都是在全局执行域中执行的”。setTimeout/setInterval 执行的时候，this 默认指向 window 对象，除非手动改变 this 的指向。</p>
<h2 id="3-简单说一下this-到底有几种指向？"><a href="#3-简单说一下this-到底有几种指向？" class="headerlink" title="3. 简单说一下this 到底有几种指向？"></a>3. 简单说一下this 到底有几种指向？</h2><p>我们重点掌握作为对象方法调用，作为函数调用，作为构造函数调用，和使用apply 或 call 调用这几种，其他的情况了解即可，</p>
]]></content>
      <categories>
        <category>js</category>
        <category>深度思考</category>
      </categories>
  </entry>
  <entry>
    <title> 异步请求之设置请求头Content-Type</title>
    <url>/2018/08/25/JS/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E4%B9%8B%E8%AE%BE%E7%BD%AEContent-Type/</url>
    <content><![CDATA[<blockquote>
<p><strong>什么是AJAX</strong>: 先给出结论——我们每日用到的AJAX，是通过javascript的XMLHttpRequest对象，使用HTTP请求，来直接与服务器通信。而angular的$http服务，其内部代码也是使用XMLHttpRequest对象来连接服务器。</p>
</blockquote>
<a id="more"></a>
<p>#问题：<br>为什么这个post请求不能成功，服务器返回码虽然是200，但它值总是不对？？？</p>
<p>#答案：<br>除开请求参数，请求地址等基本错误外，还有可能有一个非常重要的原因就是请求头中的Content-Type不对。</p>
<p>#基础知识：<br>HTTP，是一套网络通信规则，让我们可以通过浏览器等客户端请求和发送数据到服务器。</p>
<p>#每次HTTP通信需要完成7个步骤：<br>1.建立TCP连接<br>2.浏览器向服务器发送请求命令<br>3.浏览器发送请求头信息<br>4.服务器应答<br>5.服务器发送应答头信息<br>6.服务器向浏览器发送数据<br>7.关闭TCP连接</p>
<p>进一步诠释HTTP（可以不看的部分）：</p>
<h2 id="请求头声明有关浏览器和正文的一些相关信息"><a href="#请求头声明有关浏览器和正文的一些相关信息" class="headerlink" title="请求头声明有关浏览器和正文的一些相关信息"></a>请求头声明有关浏览器和正文的一些相关信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Encoding:gzip</span><br><span class="line">Content-Language:zh-CN</span><br><span class="line">Content-Type:text/html; charset=utf-8</span><br><span class="line">Date:Wed, 11 Jan 2017 01:48:38 GMT</span><br><span class="line">Pragma:no-cache</span><br><span class="line">Server:nginx/1.4.6 (Ubuntu)</span><br><span class="line">Transfer-Encoding:chunked</span><br></pre></td></tr></table></figure>
<h2 id="应答码"><a href="#应答码" class="headerlink" title="应答码"></a>应答码</h2><p>  1XX 收到请求，正在处理</p>
<p>  2XX 成功类</p>
<p>  3XX 重定向类</p>
<p>  4XX 客户端错误类（著名的404，表示请求的页面不存在）</p>
<p>  5XX 服务器错误类</p>
<h2 id="响应头也包含很多服务信息"><a href="#响应头也包含很多服务信息" class="headerlink" title="响应头也包含很多服务信息"></a>响应头也包含很多服务信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Accept:application/json, text/plain, */*</span><br><span class="line"> </span><br><span class="line"> Accept-Encoding:gzip, deflate, sdch</span><br><span class="line"> </span><br><span class="line"> Accept-Language:zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4</span><br><span class="line"> </span><br><span class="line"> Connection:keep-alive</span><br><span class="line"> </span><br><span class="line"> Cookie:JSESSIONID=aaa6A1XXqQ-QbbwfPOZGv</span><br><span class="line"> </span><br><span class="line"> Host:59.110.159.108</span><br><span class="line"> </span><br><span class="line"> Referer:http://59.110.159.108/luoboduo/html/index.html</span><br><span class="line"> </span><br><span class="line"> User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36</span><br></pre></td></tr></table></figure>
<h2 id="6-服务器返回的数据（JSON-XML-…-）"><a href="#6-服务器返回的数据（JSON-XML-…-）" class="headerlink" title="6.服务器返回的数据（JSON/XML/….）"></a>6.服务器返回的数据（JSON/XML/….）</h2><p><code>{&quot;code&quot;:0,&quot;message&quot;:&quot;success&quot;,&quot;onlineUserCount&quot;:&quot;&quot;,&quot;classCount&quot;:308,&quot;userCount&quot;:8507}</code></p>
<h1 id="详细讲讲Content-Type"><a href="#详细讲讲Content-Type" class="headerlink" title="详细讲讲Content-Type"></a>详细讲讲Content-Type</h1><p>因为POST请求的协议并没有规定数据必须使用什么编码方式，而数据发送出去，还要服务器解析成功才行。服务器则通常根据请求头里的Content-Type字段来获知消息是以什么方式编码，再以对应方式解析。而有的接口服务器则不能解析某些编码方式的数据。因此需要对Content-Type进行设置。</p>
<p>最常见的Content-Type列出如下：</p>
<p>##1. application/x-www-form-urlencoded</p>
<ul>
<li><p>最常见的POST提交格式，使用这个编码格式post的数据会以这种方式提交：key1=value1&amp;key2=value2。而我们的任务中所用到的大多数接口都只支持这种编码格式。</p>
</li>
<li><p>注意：jquery的POST默认就是application/x-www-form-urlencoded；而angular默认是application/json，而且若是提交的数据格式为json则需要序列化$.param(json)</p>
</li>
</ul>
<p>##2. multipart/form-data</p>
<ul>
<li><p>通常上传图片等文件会使用这种编码格式提交。</p>
</li>
<li><p>使用方法：</p>
<p> <code>var fd = new FormData(); fd.append(key, value);</code></p>
</li>
<li><p>注意：若使用jquery，Content-Type设置为false；若使用angular，Content-Type设置为undefind</p>
</li>
</ul>
<h2 id="3-application-json"><a href="#3-application-json" class="headerlink" title="3. application/json"></a>3. application/json</h2><ul>
<li><p>提交JSON格式的数据</p>
</li>
<li><p>注意：若使用jquery，json数据需要字符串化JSON.stringify()；若使用angular，直接使用json即可</p>
</li>
</ul>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>xhr</tag>
      </tags>
  </entry>
  <entry>
    <title>如何验证程序是否完成，测试以及deBug?</title>
    <url>/2018/08/24/JS/JS%E6%B7%B1%E5%BA%A6%E6%80%9D%E8%80%834/%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%90%A6%E5%AE%8C%E6%88%90%EF%BC%8C%E6%B5%8B%E8%AF%95%E4%BB%A5%E5%8F%8A%E4%BF%AE%E6%AD%A3Bug/</url>
    <content><![CDATA[<blockquote>
<p>在日常中，我们码代码都是按照需求来的，为了验证我们的工作成果是否符合项目的需求，那么验证程序是否完成、测试以及修复bug就成了我们工作中非常重要的流程。</p>
</blockquote>
<a id="more"></a>
<h1 id="一-背景介绍"><a href="#一-背景介绍" class="headerlink" title="一.背景介绍"></a>一.背景介绍</h1><p>在日常中，我们码代码都是按照需求来的，为了验证我们的工作成果是否符合项目的需求，那么验证程序是否完成、测试以及修复bug就成了我们工作中非常重要的流程。</p>
<h1 id="二-知识剖析"><a href="#二-知识剖析" class="headerlink" title="二.知识剖析"></a>二.知识剖析</h1><h2 id="什么样的程序是完成的程序"><a href="#什么样的程序是完成的程序" class="headerlink" title="什么样的程序是完成的程序"></a>什么样的程序是完成的程序</h2><ul>
<li><p>从需求的角度看：满足用户的全部需求</p>
</li>
<li><p>从程序的角度看：代码不存在明显bug，结构明晰，逻辑通顺，有一定的优化</p>
</li>
<li><p>从UI图的角度看：较为完美的还原了UI图的设计</p>
</li>
<li><p>从后期版本维护迭代的角度看：注释完备，稳定性好，不加班的代码就是好代码</p>
</li>
</ul>
<h2 id="软件测试的方法"><a href="#软件测试的方法" class="headerlink" title="软件测试的方法"></a>软件测试的方法</h2><p>测试：测试是使用人工操作或者软件自动运行的方式来检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别的过程。</p>
<ul>
<li><p>按照测试范围，可以分为模块测试和整体联调</p>
</li>
<li><p>按照测试条件，可以分为正常操作情况测试和异常情况测试</p>
</li>
<li><p>按照测试的输入范围，可以分为全覆盖测试和抽样测试</p>
</li>
<li><p>按照测试方式</p>
<p>  模块测试：针对设计中的一个一个模块来进行测试的，目的是保证每个模块作为一个单元能正确运行，所以模块测试通常又被称为单元测试。在这个测试步骤中所发现的往往是编码和详细设计的错误。</p>
<p>  整体联调：测试模块间接口的正确性、各模块间的数据流和控制流是否按照设计实现其功能、以及集成后整体功能的正确性。</p>
<p>  正常操作情况测试：根据正确的操作流程对单独的模块或整体进行测试，确定被测对象可以良好运行</p>
<p>  异常情况测试：异常情况，可能会包括数据库异常，系统异常，用户异常操作等情况</p>
</li>
</ul>
<h2 id="一些测试的概念"><a href="#一些测试的概念" class="headerlink" title="一些测试的概念"></a>一些测试的概念</h2><p>成熟性：软件产品要避免由软件中错误而导致失效的能力</p>
<p>容错性：在软件失效或者违反规定的接口的情况下，软件产品维持规定的性能级别的能力</p>
<p>易恢复性：在发生故障的情况下，软件重建规定的性能级别并恢复受直接影响的数据的能力</p>
<p>可靠性依从性：软件产品依附于同可靠性相关的标准、约定或规定的能力</p>
<p>全覆盖测试：对于被测对象全面，整体，多维度的测试，受限于时间和人力成本，除非被测对象级别很高，不然不会采用这种测试方式</p>
<p>抽样测试：针对功能及模块随机抽取被测对象</p>
<h1 id="三-常见问题"><a href="#三-常见问题" class="headerlink" title="三.常见问题"></a>三.常见问题</h1><p>如何debug？</p>
<h1 id="四-解决方案"><a href="#四-解决方案" class="headerlink" title="四.解决方案"></a>四.解决方案</h1><p>老大在知乎上的回答：</p>
<ol>
<li><p>确认Bug是否在本地可以重现。</p>
</li>
<li><p>确认Bug在哪一段代码中。</p>
</li>
<li><p>去除掉所有无关代码，只去调试和Bug相关的代码。</p>
</li>
<li><p>和之前正常运行的版本对比，尝试恢复到之前可以正常运行的代码。</p>
</li>
<li><p>重新写一个小Demo，确认是否可以正常运行，可以的话，移动代码到原有的代码中。</p>
</li>
<li><p>如果本地无法重现，打日志，观察线上行为。</p>
</li>
<li><p>重启服务，重启IDE，重启笔记本，重启服务器。</p>
</li>
<li><p>跟产品经理说这个Bug解决不了，花费的代价很大，不值得。</p>
</li>
</ol>
<p>张明云在知乎上的回答：</p>
<p>解决问题的流程：了解问题→定位问题→分析问题→解决问题→验证问题</p>
<p>解决问题的方法(排名分先后)</p>
<ol>
<li><p>借助搜索引擎：遇到有明显的异常信息，且自己并不熟悉为什么异常时，最高效的解决方法是借助搜索引擎，这里的搜索引擎一定是谷歌，不是百度；借助搜索引擎能解决工作中的大部分bug，你要相信，全世界这么多开发人员，你遇到过的大多数问题其他人也遇到过；</p>
</li>
<li><p>打印调试法：这是最笨但最有效的办法，人会说谎、断点调试可能会说谎，但日志一定不会说谎；</p>
</li>
<li><p>二分排除法：当你遇到随机问题、帮助他人解bug或者遇到自己不熟悉的代码时，通过屏蔽一部分代码，运行观察问题仍然存在，如果存在则进一步分析屏蔽一部分代码，直到定位到有问题的具体位置为止，这种方法能解决工作中的很大一部分疑难杂症；</p>
</li>
<li><p>小黄鸭调试法：当你向某个对象陈述你的思路时，往往会有意想不到的结果，哪怕对方并不是一个生物；</p>
</li>
<li><p>断点调试法：受限于效率不高以及在多线程环境下断点调试并不灵，有必要时才考虑用这种方法；通常可以使用打印调试法来代替；</p>
</li>
<li><p>线上求助：包括论坛提问、RTX和微信群提问等；不到万不得已不要用这种办法，在有限的圈子里面，你遇到的一个具体技术问题很有可能其他人并没有遇到过，多数时候问了也是白问，但有时候也可能是一种有效的方法。</p>
</li>
</ol>
<h1 id="五-编码实战"><a href="#五-编码实战" class="headerlink" title="五.编码实战"></a>五.编码实战</h1><p>#六.拓展思考</p>
<h2 id="什么是小黄鸭调试法"><a href="#什么是小黄鸭调试法" class="headerlink" title="什么是小黄鸭调试法?"></a>什么是小黄鸭调试法?</h2><p>小黄鸭调试法，又称橡皮鸭调试法、黄鸭除虫法（Rubber Duck Debugging）是可在软件工程中使用的一种调试代码的方法。方法就是在程序的调试、除错或测试过程中，操作人耐心地向小黄鸭解释每一行程序的作用，以此来激发灵感与发现矛盾。</p>
<p>此概念是参照于一个故事。故事中程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码。许多程序员都有向别人提问及解释编程问题的经历，而目标甚至可能是完全不懂编程的人。而就在解释的过程中，程序员可能就发觉了问题的解决方案。一边阐述代码的意图，一边观察它实际上的意图并做调试，两者间的任何不协调都会变得更明显，使人更容易发现错误所在。如果没有玩具小鸭，操作人也可以向其他任何东西倾诉，比如桌上的盆栽、键盘/鼠标等。</p>
<h1 id="七-参考资料"><a href="#七-参考资料" class="headerlink" title="七.参考资料"></a>七.参考资料</h1><p>软件开发流程</p>
<p>如何提高测试覆盖率</p>
<p>测试分析中对异常情况考虑</p>
<p>软件异常测试</p>
<p>断点调试</p>
<p>老程序员解bug有那些通用套路？</p>
<h1 id="八-更多讨论"><a href="#八-更多讨论" class="headerlink" title="八.更多讨论"></a>八.更多讨论</h1><h2 id="bug的优先级有哪几种？"><a href="#bug的优先级有哪几种？" class="headerlink" title="bug的优先级有哪几种？"></a>bug的优先级有哪几种？</h2><ul>
<li><p>critical(危险的)：是说项目中某一块功能因为这个bug而导致测试无法进行下去，此critical级别，该等级问题出现在不影响其他功能测试的情况下可以继续该版本试block是说项目中有闪退情况，崩溃情况。此为block级别，出现这种级别的问题此本停止测试</p>
</li>
<li><p>major(重要的)：是说一些功能没有实现，但是不影响使用，功能菜单缺失，但不会影响系统稳定。此为major，这种问题应该合理安排时间进行修改</p>
</li>
<li><p>normal(普通的)：是说界面等UI问题显示错误，比如字体大小，颜色，间距等问题。此类问题在测试初期较多，优先程度较低；在测试后期出现较少，应及时处理）</p>
</li>
<li><p>minor(次要的)：是说界面、性能缺陷，建议类问题，不影响操作功能的执行，可以优化性能的方案等。</p>
</li>
</ul>
<h2 id="日志和断点的优劣？"><a href="#日志和断点的优劣？" class="headerlink" title="日志和断点的优劣？"></a>日志和断点的优劣？</h2><p>对于少量数据的检测，断点操作比较麻烦，日志很直接。但是对于比较复杂的代码，打断点能更好的理清逻辑和检查数据。</p>
<h2 id="如何避免写出bug？"><a href="#如何避免写出bug？" class="headerlink" title="如何避免写出bug？"></a>如何避免写出bug？</h2><p>改动代码时要考虑到对其他模块的影响；思考问题要全面，考虑到可能发生的各种情况；从其他地方找到的代码要弄清楚原理，了解这个知识点，再用到自己的项目中。</p>
<hr>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
  </entry>
  <entry>
    <title>ES6 新特性简要总结</title>
    <url>/2018/08/15/JS/ES6/ES6-%E6%96%B0%E7%89%B9%E6%80%A7%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
</blockquote>
<a id="more"></a>
<h1 id="一、-let、const-和-块级作用域"><a href="#一、-let、const-和-块级作用域" class="headerlink" title="一、 let、const 和 块级作用域"></a>一、 let、const 和 块级作用域</h1><p>let 允许创建块级作用域，ES6 推荐在函数中使用 let 定义变量，而非 var：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 2;</span><br><span class="line">&#123;</span><br><span class="line">  let a = 3;</span><br><span class="line">  console.log(a); // 3</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); // 2</span><br></pre></td></tr></table></figure></p>
<p>同样在块级作用域有效的另一个变量声明方式是 const，它可以声明一个常量。ES6 中，const 声明的常量类似于指针，它指向某个引用，也就是说这个「常量」并非一成不变的，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const ARR = [5,6];</span><br><span class="line">  ARR.push(7);</span><br><span class="line">  console.log(ARR); // [5,6,7]</span><br><span class="line">  ARR = 10; // TypeError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>有几个点需要注意：</strong></p>
<ul>
<li>let 关键词声明的变量不具备变量提升（hoisting）特性</li>
<li>let 和 const 声明只在最靠近的一个块中（花括号内）有效</li>
<li>当使用常量 const 声明时，请使用大写变量，如：CAPITAL_CASING</li>
<li>const 在声明时必须被赋值</li>
</ul>
<h1 id="二、箭头函数"><a href="#二、箭头函数" class="headerlink" title="二、箭头函数"></a>二、箭头函数</h1><p>ES6 中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =&gt;，紧接着是函数体：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var getPrice = function() &#123;</span><br><span class="line">  return 4.55;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// Implementation with Arrow Function</span><br><span class="line">var getPrice = () =&gt; 4.55;</span><br></pre></td></tr></table></figure></p>
<h1 id="三、-函数参数默认值"><a href="#三、-函数参数默认值" class="headerlink" title="三、 函数参数默认值"></a>三、 函数参数默认值</h1><p>ES6 中允许你对函数参数设置默认值：(当没有传递该参数的具体值的时候，使用默认值)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let getFinalPrice = (price, tax=0.7) =&gt; price + price * tax;</span><br><span class="line">getFinalPrice(500); // 850</span><br></pre></td></tr></table></figure></p>
<h1 id="四、Spread-Rest-操作符"><a href="#四、Spread-Rest-操作符" class="headerlink" title="四、Spread / Rest 操作符"></a>四、Spread / Rest 操作符</h1><p>Spread / Rest 操作符指的是 …，具体是 Spread 还是 Rest 需要看上下文语境。</p>
<p>当被用于迭代器中时，它是一个 Spread 操作符：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(x,y,z) &#123;</span><br><span class="line">  console.log(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let arr = [1,2,3];</span><br><span class="line">foo(...arr); // 1 2 3</span><br></pre></td></tr></table></figure></p>
<p>当被用于函数传参时，是一个 Rest 操作符：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(...args) &#123;</span><br><span class="line">  console.log(args);</span><br><span class="line">&#125;</span><br><span class="line">foo( 1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></p>
<h1 id="五、对象词法扩展"><a href="#五、对象词法扩展" class="headerlink" title="五、对象词法扩展"></a>五、对象词法扩展</h1><p>ES6 允许声明在对象字面量时使用简写语法，来初始化属性变量和函数的定义方法，并且允许在对象属性中进行计算操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getCar(make, model, value) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    // 简写变量</span><br><span class="line">    make, // 等同于 make: make</span><br><span class="line">    model, // 等同于 model: model</span><br><span class="line">    value, // 等同于 value: value</span><br><span class="line"> </span><br><span class="line">    // 属性可以使用表达式计算值</span><br><span class="line">    [&apos;make&apos; + make]: true,</span><br><span class="line"> </span><br><span class="line">    // 忽略 `function` 关键词简写对象函数</span><br><span class="line">    depreciate() &#123;</span><br><span class="line">      this.value -= 2500;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let car = getCar(&apos;Barret&apos;, &apos;Lee&apos;, 40000);</span><br><span class="line"> //car: &#123;</span><br><span class="line">// make: &apos;Barret&apos;,</span><br><span class="line">// model:&apos;Lee&apos;,</span><br><span class="line">// value: 40000,</span><br><span class="line">// makeBarret: true,</span><br><span class="line">// depreciate: function()</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="六、二进制和八进制字面量"><a href="#六、二进制和八进制字面量" class="headerlink" title="六、二进制和八进制字面量"></a>六、二进制和八进制字面量</h1><p>ES6 支持二进制和八进制的字面量，通过在数字前面添加 0o 或者0O 即可将其转换为八进制值：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let oValue = 0o10;</span><br><span class="line">console.log(oValue); // 8</span><br><span class="line"> </span><br><span class="line">let bValue = 0b10; // 二进制使用 `0b` 或者 `0B`</span><br><span class="line">console.log(bValue); // 2</span><br></pre></td></tr></table></figure></p>
<h1 id="七、对象和数组解构"><a href="#七、对象和数组解构" class="headerlink" title="七、对象和数组解构"></a>七、对象和数组解构</h1><p>解构可以避免在对象赋值时产生中间变量：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  return [1,2,3];</span><br><span class="line">&#125;</span><br><span class="line">let arr = foo(); // [1,2,3]</span><br><span class="line"> </span><br><span class="line">let [a, b, c] = foo();</span><br><span class="line">console.log(a, b, c); // 1 2 3</span><br><span class="line"> </span><br><span class="line">function bar() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    x: 4,</span><br><span class="line">    y: 5,</span><br><span class="line">    z: 6</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let &#123;x: x, y: y, z: z&#125; = bar();</span><br><span class="line">console.log(x, y, z); // 4 5 6</span><br></pre></td></tr></table></figure></p>
<h1 id="八、对象超类"><a href="#八、对象超类" class="headerlink" title="八、对象超类"></a>八、对象超类</h1><p>ES6 允许在对象中使用 super 方法（用于继承父级的方法）：</p>
<ul>
<li>使用super后，必须使用Object.setPrototypeOf方法指定父级<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var parent = &#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    console.log(&quot;Hello from the Parent&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var child = &#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    super.foo();</span><br><span class="line">    console.log(&quot;Hello from the Child&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Object.setPrototypeOf(child, parent);</span><br><span class="line">child.foo(); // Hello from the Parent</span><br><span class="line">             // Hello from the Child</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="九、模板语法和分隔符"><a href="#九、模板语法和分隔符" class="headerlink" title="九、模板语法和分隔符"></a>九、模板语法和分隔符</h1><p>ES6 中有一种十分简洁的方法组装一堆字符串和变量。</p>
<ul>
<li>${ … } 用来渲染一个变量</li>
<li>` 作为分隔符<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let user = &apos;Barret&apos;;</span><br><span class="line">console.log(`Hi $&#123;user&#125;!`); // Hi Barret!</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="十、-for…of-VS-for…in"><a href="#十、-for…of-VS-for…in" class="headerlink" title="十、 for…of VS for…in"></a>十、 for…of VS for…in</h1><p>for…of 用于遍历一个迭代器，如数组：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let nicknames = [&apos;di&apos;, &apos;boo&apos;, &apos;punkeye&apos;];</span><br><span class="line">nicknames.size = 3;</span><br><span class="line">for (let nickname of nicknames) &#123;</span><br><span class="line">  console.log(nickname);</span><br><span class="line">&#125;</span><br><span class="line">// 结果: di, boo, punkeye</span><br></pre></td></tr></table></figure></p>
<p>for…in 用来遍历对象中的属性：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let nicknames = [&apos;di&apos;, &apos;boo&apos;, &apos;punkeye&apos;];</span><br><span class="line">nicknames.size = 3;</span><br><span class="line">for (let nickname in nicknames) &#123;</span><br><span class="line">  console.log(nickname);</span><br><span class="line">&#125;</span><br><span class="line">Result: 0, 1, 2, size</span><br></pre></td></tr></table></figure></p>
<h1 id="十一、Map-和-WeakMap"><a href="#十一、Map-和-WeakMap" class="headerlink" title="十一、Map 和 WeakMap"></a>十一、Map 和 WeakMap</h1><p>ES6 中两种新的数据结构集：Map 和 WeakMap。事实上每个对象都可以看作是一个 Map。</p>
<p><strong>Map</strong>: 键值对的键名、键值都可以为任意数据结构的对象；</p>
<p>一个对象由多个 key-val 对构成，在 Map 中，任何类型都可以作为对象的 key，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myMap = new Map();</span><br><span class="line"> </span><br><span class="line">var keyString = &quot;a string&quot;,</span><br><span class="line">    keyObj = &#123;&#125;,</span><br><span class="line">    keyFunc = function () &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">// 设置值</span><br><span class="line">myMap.set(keyString, &quot;value 与 &apos;a string&apos; 关联&quot;);</span><br><span class="line">myMap.set(keyObj, &quot;value 与 keyObj 关联&quot;);</span><br><span class="line">myMap.set(keyFunc, &quot;value 与 keyFunc 关联&quot;);</span><br><span class="line"> </span><br><span class="line">myMap.size; // 3</span><br><span class="line"> </span><br><span class="line">// 获取值</span><br><span class="line">myMap.get(keyString); // &quot;value 与 &apos;a string&apos; 关联&quot;</span><br><span class="line">myMap.get(keyObj); // &quot;value 与 keyObj 关联&quot;</span><br><span class="line">myMap.get(keyFunc); // &quot;value 与 keyFunc 关联&quot;</span><br></pre></td></tr></table></figure></p>
<p>属性：Map.size返回Map实例成员的总数；<br>方法：操作方法(5种)+遍历方法(4种)  </p>
<p>操作方法</p>
<ol>
<li>Map.set(key,value)：设置key值对应的值，如果key存在，则覆盖原有值；</li>
<li>Map.get(key)：获取键名为key的键值；</li>
<li>Map.has(key)：检查键名key是否存在Map实例中，返回boolean值，若存在返回true,不存在返回false;</li>
<li>Map.delete(key)：删除键名为key的属性，返回boolean值，若删除成功返回true,失败返回false;</li>
<li>Map.clear()：清除Map实例的所有成员，无返回值  </li>
</ol>
<p>遍历方法  </p>
<ol>
<li>Map.keys()：返回键名的遍历器</li>
<li>Map.values()：返回键值的遍历器</li>
<li>Map.entries()：返回所有成员的遍历器</li>
<li>Map.forEach((value,key,map)=&gt;{},thisObj)：遍历Map的所有成员</li>
</ol>
<p><strong>WeakMap</strong> : 键名只能为对象的Map，弱引用</p>
<p>WeakMap 就是一个 Map，只不过它的所有 key 都是弱引用，意思就是 WeakMap 中的东西垃圾回收时不考虑，使用它不用担心内存泄漏问题。</p>
<p>另一个需要注意的点是，WeakMap 的所有 key 必须是对象。它只有四个方法 delete(key),has(key),get(key) 和set(key, val)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let w = new WeakMap();</span><br><span class="line">w.set(&apos;a&apos;, &apos;b&apos;); </span><br><span class="line">// Uncaught TypeError: Invalid value used as weak map key</span><br><span class="line"> </span><br><span class="line">var o1 = &#123;&#125;,</span><br><span class="line">    o2 = function()&#123;&#125;,</span><br><span class="line">    o3 = window;</span><br><span class="line"> </span><br><span class="line">w.set(o1, 37);</span><br><span class="line">w.set(o2, &quot;azerty&quot;);</span><br><span class="line">w.set(o3, undefined);</span><br><span class="line"> </span><br><span class="line">w.get(o3); // undefined, because that is the set value</span><br><span class="line"> </span><br><span class="line">w.has(o1); // true</span><br><span class="line">w.delete(o1);</span><br><span class="line">w.has(o1); // false</span><br></pre></td></tr></table></figure></p>
<h1 id="十二、Set-和-WeakSet"><a href="#十二、Set-和-WeakSet" class="headerlink" title="十二、Set 和 WeakSet"></a>十二、Set 和 WeakSet</h1><p>Set 对象是一组不重复的值，重复的值将被忽略，值类型可以是原始类型和引用类型：<br><strong>Set —没有重复成员元素的数组</strong></p>
<ul>
<li>本质：Set本身是一个构造函数；接收一个具有iterable接口数据结构的参数，用来生成一个没有重复元素的数组；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let nums=new Set([1,2,3,4,3,2]);//[1,2,3,4]</span><br><span class="line">nums.add(2);//[1,2,3,4]</span><br><span class="line">nums.add(&apos;2&apos;);//[1,2,3,4,&apos;2&apos;]</span><br><span class="line">nums.add(&#123;&#125;);//[1,2,3,4,&apos;2&apos;,&#123;&#125;] Set添加元素时不会发生类型转换，</span><br><span class="line">nums.add(&#123;&#125;);//[1,2,3,4,&apos;2&apos;,&#123;&#125;,&#123;&#125;] Set添加的对象总不相等</span><br></pre></td></tr></table></figure>
<ul>
<li>两类8个方法：操作方法(4种）+遍历方法(4种)<br>操作方法</li>
</ul>
<ol>
<li>Set.add(value)：向Set实例添加值value，返回Set结构本身 ;</li>
<li>Set.delete(value)：向Set实例删除值value，返回boolean, 成功为true，失败返回false;</li>
<li>Set.has(value)：检查Set实例是否含有值value，返回boolean，包含返回true，不包含返回false</li>
<li>Set.clear()：清楚Set实例的所有成员，无返回值；</li>
</ol>
<p>遍历方法</p>
<ol>
<li>Set.keys()：返回键名的遍历器；</li>
<li>Set.values()：返回键值的遍历器；</li>
<li>Set.entries()：返回键值对的遍历器；</li>
<li>Set.forEach((value,key)=&gt;{},thisObj)：使用回调函数遍历每个成员</li>
</ol>
<ul>
<li>使用场景 使用场景：数组去重、求数组的交集、并集、差集<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ①数组去重</span><br><span class="line">let arr=[1,2,3,4,3,2,1];</span><br><span class="line">let b=[...arr];//[1, 2, 3, 4, 3, 2, 1]</span><br><span class="line">let a=Array.from(new Set(arr));//[1,2,3,4]</span><br><span class="line">let c = [...new Set(arr)];//[1,2,3,4]</span><br><span class="line">// ②数组运算</span><br><span class="line"></span><br><span class="line">let arr1=new Set([1,2,3,4]);</span><br><span class="line">let arr2=new Set([3,4,5,6]);</span><br><span class="line">let union=new Set([...arr1,...arr2]);//[1,2,3,4,5,6]</span><br><span class="line">let intersect=new Set([...arr1].filter(value=&gt;b.has(value)));//[3,4]</span><br><span class="line">let diffrence=new Set([...arr1].filter(value=&gt;!b.has(value)));//[1,2]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>WeakSet—成员只能是对象的Set</strong><br>+　WeakSet的成员只能是对象不能是其他类型值；<br>+　WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用；</p>
<p>弱引用，即当一个WeakSet实例的成员引用对象A时，当其他对象不在引用对象A，JS的垃圾回收机制便会自动回收该对象占用的内存，不考虑WeakSet实例是否还在引用；弱引用的对象随时可能消失，无法保证成员的存在，因此WeakSet相比较Set数据结构，没有clear(）方法、没有size属性、也没有遍历方法;</p>
<h1 id="十三、类"><a href="#十三、类" class="headerlink" title="十三、类"></a>十三、类</h1><p>ES6 中有 class 语法。值得注意是，这里的 class 不是新的对象继承模型，它只是原型链的语法糖表现形式。</p>
<p>函数中使用 <strong>static</strong> 关键词定义构造函数的的方法和属性：<br>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Task &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    console.log(&quot;task instantiated!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  showId() &#123;</span><br><span class="line">    console.log(23);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  static loadAll() &#123;</span><br><span class="line">    console.log(&quot;Loading all tasks..&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">console.log(typeof Task); // function</span><br><span class="line">let task = new Task(); // &quot;task instantiated!&quot;</span><br><span class="line">task.showId(); // 23</span><br><span class="line">task.loadAll(); //loadAll不是一个函数</span><br><span class="line">Task.loadAll(); // &quot;Loading all tasks..&quot;</span><br></pre></td></tr></table></figure>
<p><strong>类中的继承和超集：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    console.log(&quot;Creating a new car&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Porsche extends Car &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(&quot;Creating Porsche&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">let c = new Porsche();</span><br><span class="line">// Creating a new car</span><br><span class="line">// Creating Porsche</span><br></pre></td></tr></table></figure>
<p>extends 允许一个子类继承父类，需要注意的是，子类的constructor 函数中需要执行 super() 函数。</p>
<p>当然，你也可以在子类方法中调用父类的方法，如super.parentMethodName()。</p>
<p>有几点值得<strong>注意</strong>的是：</p>
<ul>
<li>类的声明不会提升（hoisting)，如果你要使用某个 Class，那你必须在使用之前定义它，否则会抛出一个 ReferenceError 的错误</li>
<li>在类中定义函数不需要使用 function 关键词</li>
</ul>
<h1 id="十四、Symbol"><a href="#十四、Symbol" class="headerlink" title="十四、Symbol"></a>十四、Symbol</h1><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sym = Symbol( &quot;some optional description&quot; );</span><br><span class="line">console.log(typeof sym); // symbol</span><br></pre></td></tr></table></figure>
<p>注意，这里 Symbol 前面不能使用 new 操作符。<br>如果它被用作一个对象的属性，那么这个属性会是不可枚举的.</p>
<h1 id="十五、-Promises"><a href="#十五、-Promises" class="headerlink" title="十五、 Promises"></a>十五、 Promises</h1><p>ES6 对 Promise 有了原生的支持，一个 Promise 是一个等待被异步执行的对象，当它执行完成后，其状态会变成 resolved 或者rejected。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p = new Promise(function(resolve, reject) &#123;  </span><br><span class="line">  if (/* condition */) &#123;</span><br><span class="line">    // fulfilled successfully</span><br><span class="line">    resolve(/* value */);  </span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // error, rejected</span><br><span class="line">    reject(/* reason */);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>每一个 Promise 都有一个 .then 方法，这个方法接受两个参数，第一个是处理 resolved 状态的回调，一个是处理 rejected 状态的回调：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p.then((val) =&gt; console.log(&quot;Promise Resolved&quot;, val),</span><br><span class="line">       (err) =&gt; console.log(&quot;Promise Rejected&quot;, err));</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>取消浏览器对页面滚动条位置的记录</title>
    <url>/2018/08/11/JS/%E5%8F%96%E6%B6%88%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%E6%9D%A1%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>浏览器在导航跳转和通过 History API 创建历史记录时，都会记录当前的垂直滚动距离，在重新访问时恢复这个距离。如何取消记录当前的垂直滚动距离,使其刷新时可以回到顶部呢?</p>
</blockquote>
<a id="more"></a>
<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>项目提出bug，当正在浏览页面的时候点击返回首页此时页面停留在页面顶部，然后立即刷新，页面会回到刚才浏览的部分。<br><strong>期望</strong>：当浏览时刷新可以保存滑动条的位置但是当点击首页的时候不需要保存</p>
<h2 id="问题出现原因："><a href="#问题出现原因：" class="headerlink" title="问题出现原因："></a>问题出现原因：</h2><p>浏览器在导航跳转和通过 History API 创建历史记录时，都会记录当前的垂直滚动距离，在重新访问时恢复这个距离。</p>
<h2 id="问题解决办法："><a href="#问题解决办法：" class="headerlink" title="问题解决办法："></a>问题解决办法：</h2><p>1、初级版<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;.toIndex&quot;).click(function()&#123;</span><br><span class="line">    if (&apos;scrollRestoration&apos; in history) &#123;</span><br><span class="line">        history.scrollRestoration = &apos;manual&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);//去除默认的滚动恢复行为</span><br><span class="line">var recoverAuto = function () &#123;</span><br><span class="line">    if (&apos;scrollRestoration&apos; in history) &#123;</span><br><span class="line">        history.scrollRestoration = &apos;auto&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">setTimeout(recoverAuto,1800);//回复默认的滚动恢复行为</span><br></pre></td></tr></table></figure></p>
<p>给返回首页添加点击事件，关闭记录当前的垂直滚动距离浏览器行为。但是这样会导致之后也无法保存滚动条的位置，所以后面加了一个定时器，在1.8s之后恢复浏览器的记录行为。<br><strong>缺点</strong>：如果用户在1.8s之内浏览页面并刷新，不会回到浏览位置。</p>
<p>2、 终极方案（从根本上解决问题，无bug）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;.toIndex&quot;).click(function()&#123;</span><br><span class="line">    $(&apos;body,html&apos;).scrollTop(0);</span><br><span class="line">&#125;);//返回首页的同时将滑动条置顶</span><br></pre></td></tr></table></figure></p>
<p>给返回首页添加点击事件，返回首页的同时将滑动条置顶，让浏览器记录一个在顶部的历史记录。</p>
<hr>
<blockquote>
<p>相关知识</p>
</blockquote>
<p>平常使用浏览器的后退功能时，常常会发现返回的页面滚动到了之前的位置，而不是简单的回到顶部。这是由于浏览器在导航跳转和通过 History API 创建历史记录时，都会记录当前的垂直滚动距离，在重新访问时恢复这个距离。值得一提的是，在 HTML History Spec中并没有强制要求浏览器记录与恢复滚动距离。</p>
<p>引入新的 API<br>为了让开发者能够通过编程方式关闭这一浏览器行为，《浏览器恢复滚动提案》引入了新的 API：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (&apos;scrollRestoration&apos; in history) &#123;</span><br><span class="line">    // 默认值为&apos;auto&apos;</span><br><span class="line">    history.scrollRestoration = &apos;manual&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown 配置七牛云作为图床</title>
    <url>/2018/07/31/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Markdown-%E9%85%8D%E7%BD%AE%E4%B8%83%E7%89%9B%E4%BA%91%E4%BD%9C%E4%B8%BA%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<blockquote>
<p>Hexo在使用Markdown编辑发布博客时，经常要上传本地图片，渲染加载图片的效果很不理想。推荐使用云平台作为图床，提高编辑效率和图片效果。</p>
</blockquote>
<a id="more"></a>
<h1 id="一-注册七牛云账号"><a href="#一-注册七牛云账号" class="headerlink" title="一. 注册七牛云账号"></a>一. 注册七牛云账号</h1><ol>
<li><a href="https://portal.qiniu.com/signup?code=3lefotin55poy" target="_blank" rel="noopener">七牛云注册地址</a></li>
<li>新增存储空间。注册完成之后，在<strong>资源主页</strong>中的<strong>对象存储</strong>里添加对象，如添加<strong>image</strong><br><img src="http://oqiflua2i.bkt.clouddn.com/%E8%B5%84%E6%BA%90%E4%B8%BB%E9%A1%B5.png" alt="新增增存储空间"><br><img src="http://oqiflua2i.bkt.clouddn.com/%E6%B7%BB%E5%8A%A0%E5%AF%B9%E8%B1%A1.png" alt="新增增存储空间"></li>
<li>简单的上传图片，复制外链<br><img src="http://oqiflua2i.bkt.clouddn.com/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6.gif" alt="上传图片"></li>
</ol>
<h1 id="二-使用插件（Mpic）"><a href="#二-使用插件（Mpic）" class="headerlink" title="二. 使用插件（Mpic）"></a>二. 使用插件（Mpic）</h1><p><a href="http://mpic.lzhaofu.cn/" target="_blank" rel="noopener">Mpic下载</a></p>
<p>之前我在没有发现Mpic这款软件的时候，将图片上传到七牛云存储总共分四步：</p>
<ol>
<li>登录打开七牛云网页个人存储空间</li>
<li>上传图片</li>
<li>复制外链</li>
<li>粘贴到 Markdown</li>
</ol>
<p>一张图片的上传整整用了四步，特别麻烦。直到LZ最近发现了Mpic之后，才发现，上传图片原来也能这么简单。<br>使用Mpic，只需要将七牛云存储的账号信息配置一次(参考：如何设置七牛云存储账号？)，就可以将以上这四个步骤合为一个。<br>同时，MPic提供了点击上传、拖曳上传、截图上传、复制上传四种上传图片的方法，更是让人感叹好的软件极大的提高了效率啊。</p>
<p>配置Mpic插件，获取密匙<br>进入七牛云个人中心的密钥管理，获取AccessKey和SecretKey<br><img src="http://oqiflua2i.bkt.clouddn.com/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86.png" alt="获取密匙"></p>
<h1 id="三-使用极简图床"><a href="#三-使用极简图床" class="headerlink" title="三. 使用极简图床"></a>三. 使用极简图床</h1><p>使用极简图床,关联七牛云账号</p>
]]></content>
      <categories>
        <category>工具使用</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>使用js或css实现瀑布流（Pinterest）布局教程</title>
    <url>/2018/07/30/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/%E4%BD%BF%E7%94%A8js%E6%88%96css%E5%AE%9E%E7%8E%B0%E7%80%91%E5%B8%83%E6%B5%81%EF%BC%88Pinterest%EF%BC%89%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>瀑布流，又称瀑布流式布局。这种布局适合于小数据块，每个数据块内容相近且没有侧重。通常，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。</p>
</blockquote>
<a id="more"></a>
<h1 id="瀑布流布局实例"><a href="#瀑布流布局实例" class="headerlink" title="瀑布流布局实例"></a><a href="https://www.zhangxinxu.com/study/201203/waterfall-layout.html" target="_blank" rel="noopener">瀑布流布局实例</a></h1><h2 id="一、JS实现"><a href="#一、JS实现" class="headerlink" title="一、JS实现"></a>一、JS实现</h2><ul>
<li>代码：<a href="https://github.com/jirengu-inc/jrg-renwu10/blob/master/homework/%E5%AD%99%E7%BA%A2%E7%85%A7/mission30/demo.html" target="_blank" rel="noopener">js实现瀑布流布局代码</a></li>
<li>demo：<a href="http://book.jirengu.com/jirengu-inc/jrg-renwu10/homework/%E5%AD%99%E7%BA%A2%E7%85%A7/mission30/demo.html" target="_blank" rel="noopener">js实现瀑布流布局demo</a></li>
</ul>
<h2 id="二、CSS实现"><a href="#二、CSS实现" class="headerlink" title="二、CSS实现"></a>二、CSS实现</h2><ol>
<li><a href="https://www.w3cplus.com/css/pure-css-create-masonry-layout.html" target="_blank" rel="noopener">Multi-columns</a></li>
<li><a href="https://www.w3cplus.com/css/pure-css-create-masonry-layout.html" target="_blank" rel="noopener">Flexbox</a></li>
<li><a href="https://www.w3cplus.com/css/pure-css-create-masonry-layout.html" target="_blank" rel="noopener">Grid</a></li>
</ol>
<p>总结：这篇文章主要介绍了如何实现瀑布流的布局。文章简单介绍了css三种实现方案：Multi-columns、Flexbox和Grid。从上面的示例或者实现手段而言，较为友好的是Flexbox的方案。当然，随着CSS Grid特性的完善，使用Grid实现瀑布流布局将会变得更为简单和友好。以及一种相对简单的js实现方案。</p>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>敏捷开发流程</title>
    <url>/2018/07/30/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>敏捷软件开发，又称敏捷开发，是一种从1990年代开始逐渐引起广泛关注的一些新型软件开发方法，是一种应对快速变化的需求的一种软件开发能力。它们的具体名称、理念、过程、术语都不尽相同，相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发过程中人的作用。</p>
</blockquote>
<a id="more"></a>
<h1 id="一、story讲解"><a href="#一、story讲解" class="headerlink" title="一、story讲解"></a>一、story讲解</h1><ol>
<li>制作竞品分析PPT，UE全组参与。（用时：根据产品复杂度，0.5-2小时之内）</li>
<li>制作产品原型，交由客户看，客户没有异议之后禅道录入story</li>
<li>产品在禅道拆分好story，并且定义出优先级，关联需求，后续开发根据优先级进行开发</li>
<li>由产品讲解story，前端和后端都参与。（用时：根据产品的复杂度，1-3小时之内）</li>
</ol>
<h1 id="二、人员划分"><a href="#二、人员划分" class="headerlink" title="二、人员划分"></a>二、人员划分</h1><ol>
<li>新建wiki项目主页，把PPT和产品原型（HTML文件）上传到wiki</li>
<li>根据产品原型，按照模块划分相关负责人，前端和后端都是，并放到wiki。（由项目负责人新建）</li>
</ol>
<h1 id="三、定义接口文档（2-3天）"><a href="#三、定义接口文档（2-3天）" class="headerlink" title="三、定义接口文档（2-3天）"></a>三、定义接口文档（2-3天）</h1><ol>
<li>前端后端相关人员一起，对照原型，根据模块及页面大概定义出接口<ul>
<li>一个页面中有几个接口，每个接口入参与出参是什么</li>
</ul>
</li>
<li>后端每个模块的负责人，根据开会讨论的结果，在wiki上生成标准的接口文档</li>
<li>将后端做好的接口文档发给前端模块负责人过目，有问题继续修改；没问题开始后续的步骤 。</li>
</ol>
<h1 id="四、方案设计（1小时-1天左右，根据模块大小定义时间）"><a href="#四、方案设计（1小时-1天左右，根据模块大小定义时间）" class="headerlink" title="四、方案设计（1小时-1天左右，根据模块大小定义时间）"></a>四、方案设计（1小时-1天左右，根据模块大小定义时间）</h1><ol>
<li>后端开发人员，根据原型以及定义的接口，做好方案设计</li>
<li>对有难度或者有疑点的接口，做出方案，尽量给出多个合理方案</li>
<li>每个方案写清楚优点缺点</li>
</ol>
<h1 id="五、方案评审（2-3小时）"><a href="#五、方案评审（2-3小时）" class="headerlink" title="五、方案评审（2-3小时）"></a>五、方案评审（2-3小时）</h1><ol>
<li>对做出的方案设计，做方案评审，建议全体人员参与（无论做不做该项目）</li>
</ol>
<h1 id="六、禅道拆分（1-2小时）"><a href="#六、禅道拆分（1-2小时）" class="headerlink" title="六、禅道拆分（1-2小时）"></a>六、禅道拆分（1-2小时）</h1><ol>
<li><p>相关负责人按照优先级顺序，在禅道拆分自己的任务，单个任务最多不要超过4小时，即拆分要详细</p>
<ul>
<li>拆分一个task时，以具体写的代码为一个task，并在任务名称中写出该类/方法的名称在任务描述中写出该task的代码块具体有的功能</li>
<li>当拆完task后，这几个task所完成功能的代码已经过了一遍</li>
<li>如果有不了解的功能，在方案评审前先写出一个demo，以方便拆分task的估时</li>
<li>一个task用时应在0.5-2之间，最大最大4个小时</li>
</ul>
</li>
<li><p>以文件上传功能为例，分成3个task</p>
<ul>
<li>task1.任务名称：公共模块-文件上传-上传文件controller的方法fileUpload<br>任务描述：通过网页获取文件，文件判空，判断文件的归属类型（用户/教材/课时/步骤/咨询）<br>工时：1              </li>
<li>task2.任务名称：公共模块-文件上传-添加文件FileUtil 和FileUtilOssImpl<br>任务描述：util处理上传的文件，判断文件类型，大小，设置文件上传的路径，返回的url<br>工时：1.5</li>
<li>task3.任务名称：公共模块-文件上传-文件接口spring-fileOss.xml 配置文件<br>任务描述：oss的文件上传， 调用的spring.xml配置文件（密匙，ID,bucket等）<br>工时：1.5</li>
</ul>
</li>
</ol>
<h1 id="七、开发"><a href="#七、开发" class="headerlink" title="七、开发"></a>七、开发</h1><ol>
<li>搭建开发服务器</li>
<li>开发人员根据禅道上的任务，按时完成自己的开发工作，具体体现到日报上</li>
<li>每天上午开10分钟左右进度会议，如果有延迟现象出现，拿出解决方案，保证项目按照禅道上的时间点完成</li>
<li>数据库索引(两种索引):<ol>
<li>经常查询的，数据散列度比较高的，做一般索引，不需要建联合索引。</li>
<li>数据必须保持唯一的，建唯一索引。(要有文档，文档表明哪些字段要建索引。发邮件。)</li>
</ol>
</li>
</ol>
<h1 id="八、阶段测试"><a href="#八、阶段测试" class="headerlink" title="八、阶段测试"></a>八、阶段测试</h1><ol>
<li>每天至少发布一次代码到开发环境，并且保证发布完之后程序没问题(与开发并行)</li>
</ol>
<h1 id="九、性能测试和coderevivew（1天）"><a href="#九、性能测试和coderevivew（1天）" class="headerlink" title="九、性能测试和coderevivew（1天）"></a>九、性能测试和coderevivew（1天）</h1><ol>
<li>对每个接口做好性能测试<ul>
<li>每个接口的响应时间不超过200ms，如果有超过的，做优化，尽量缩小到200ms内</li>
</ul>
</li>
<li>完成codereview，根据codereview结论完成修改</li>
</ol>
<h1 id="十、压力测试"><a href="#十、压力测试" class="headerlink" title="十、压力测试"></a>十、压力测试</h1><ol>
<li>做好压测报告</li>
</ol>
<h1 id="十一、-Demo"><a href="#十一、-Demo" class="headerlink" title="十一、 Demo"></a>十一、 Demo</h1><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><ol>
<li>发demo申请邮件，收件人包括产品、测试同学、前后端相关开发人员<ol>
<li>主题：XX项目demo通知</li>
<li>内容：时间 地点  参会人员</li>
</ol>
</li>
<li>开demo会议：主讲人：某个开发人员<ul>
<li>会议途中产品和测试提出问题</li>
</ul>
</li>
<li>发demo结果通知邮件(由产品同学发)<ol>
<li>demo结果</li>
<li>如果不通过，有哪些问题</li>
</ol>
</li>
<li><p>如果不通过，召集第二次Demo会议，知道通过为止。第二次会议只需演示之前不通过的部分</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2></li>
<li>demo通过之后<ol>
<li>开发人员对代码打tag（参考文档：<a href="http://new.wiki.jnshu.com/pages/viewpage.action?pageId=1183585" target="_blank" rel="noopener"> 如何打tag </a>。）</li>
<li>开发人员部署测试环境，部署完成之后发邮件，写明域名；</li>
<li>交给测试人员进行测试，测试人员发送全体测试周期邮件</li>
</ol>
</li>
<li>测试期间，如果有测试发现bug，会在禅道上面提出bug，禅道会发送邮件到各自开发人员的邮箱，开发人员要关注BUG邮件 ，及时确认BUG，及时修改  </li>
<li>修改BUG之后，开发环境前端代码由前端同学自己部署，后端代码由后端同学自己部署  </li>
<li>测试完成之后，测试或产品发送上线通知<br>具体参看：<a href="http://my.wiki.ptteng.com/pages/createpage.action?spaceKey=art&amp;title=%E6%B5%8B%E8%AF%95Bug%E5%88%92%E5%88%86%E5%8F%8A%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B&amp;linkCreation=true&amp;fromPageId=8257825" target="_blank" rel="noopener"> 测试Bug划分及处理流程 </a>。<br>测试和线上环境发布流程：<a href="http://new.wiki.jnshu.com/pages/viewpage.action?pageId=1182458" target="_blank" rel="noopener"> 测试及线上环境发布流程 </a>。 </li>
</ol>
<h1 id="十二、-发布测试环境、集成测试（2-3天）"><a href="#十二、-发布测试环境、集成测试（2-3天）" class="headerlink" title="十二、 发布测试环境、集成测试（2-3天）"></a>十二、 发布测试环境、集成测试（2-3天）</h1><ol>
<li>禅道上建立bug，测试出bug，指派给相关人员修改</li>
</ol>
<h1 id="十三、发布线上环境，同时停止开发环境和测试环境"><a href="#十三、发布线上环境，同时停止开发环境和测试环境" class="headerlink" title="十三、发布线上环境，同时停止开发环境和测试环境"></a>十三、发布线上环境，同时停止开发环境和测试环境</h1><h1 id="十四、线上监控"><a href="#十四、线上监控" class="headerlink" title="十四、线上监控"></a>十四、线上监控</h1><ol>
<li>错误报告</li>
</ol>
]]></content>
      <categories>
        <category>项目开发</category>
      </categories>
  </entry>
  <entry>
    <title>css常用命名规范</title>
    <url>/2018/07/29/CSS%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8/css%E5%B8%B8%E7%94%A8%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<blockquote>
<p>作为一个对代码负责的人，每次看见别人代码里混乱的命名，总是不禁心里一顿暗骂。问及写代码的人，他们的回答总是：我英文不好，不知道如何取名，都想破了脑袋。而一些QQ群里提问题的朋友截图代码，命名也是非常混乱。网上有很多人发表CSS常用命名的文章，也都挺好的，我只是一个收集者，和把自己的常用命名加上去，分享给有需要的人，希望大家以后写的代码自己看着舒服，别人维护着也舒服。<br><a id="more"></a></p>
</blockquote>
<h1 id="class的命名"><a href="#class的命名" class="headerlink" title="class的命名"></a>class的命名</h1><ul>
<li>头：header</li>
<li>内容：content/container</li>
<li>尾：footer</li>
<li>导航：nav   navigation n.航行；航海</li>
<li>侧栏：sidebar</li>
<li>栏目：column</li>
<li>页面外围控制整体佈局宽度：wrapper</li>
<li>左右中：left right center</li>
<li>登录条：loginbar</li>
<li>标志：logo</li>
<li>广告：banner</li>
<li>页面主体：main</li>
<li>热点：hot</li>
<li>新闻：news</li>
<li>下载：download</li>
<li>子导航：subnav</li>
<li>菜单：menu</li>
<li>子菜单：submenu</li>
<li>搜索：search</li>
<li>友情链接：friendlink</li>
<li>页脚：footer</li>
<li>版权：copyright</li>
<li>滚动：scroll</li>
<li>内容：content</li>
<li>标签：tags</li>
<li>文章列表：list</li>
<li>提示信息：msg–message</li>
<li>小技巧：tips</li>
<li>栏目标题：title</li>
<li>加入：joinus</li>
<li>指南：guide</li>
<li>服务：service</li>
<li>注册：regsiter</li>
<li>状态：status</li>
<li>投票：vote</li>
<li>合作伙伴：partner</li>
</ul>
<h1 id="id的命名"><a href="#id的命名" class="headerlink" title="id的命名"></a>id的命名</h1><h2 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h2><ul>
<li>容器: container</li>
<li>页头：header</li>
<li>内容：content/container</li>
<li>页面主体：main</li>
<li>页尾：footer</li>
<li>导航：nav</li>
<li>侧栏：sidebar</li>
<li>栏目：column</li>
<li>页面外围控制整体佈局宽度：wrapper</li>
<li>左右中：left right center</li>
</ul>
<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><ul>
<li>导航：nav</li>
<li>主导航：mainnav</li>
<li>子导航：subnav</li>
<li>顶导航：topnav</li>
<li>边导航：sidebar</li>
<li>左导航：leftsidebar</li>
<li>右导航：rightsidebar</li>
<li>菜单：menu</li>
<li>子菜单：submenu</li>
<li>标题: title</li>
<li>摘要: summary</li>
</ul>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>标志：logo</li>
<li>广告：banner</li>
<li>登陆：login</li>
<li>登录条：loginbar</li>
<li>注册：register</li>
<li>搜索：search</li>
<li>功能区：shop</li>
<li>标题：title</li>
<li>加入：joinus</li>
<li>状态：status</li>
<li>按钮：btn</li>
<li>滚动：scroll</li>
<li>标籤页：tab</li>
<li>文章列表：list</li>
<li>提示信息：msg</li>
<li>当前的: current</li>
<li>小技巧：tips</li>
<li>图标: icon</li>
<li>注释：note</li>
<li>指南：guild</li>
<li>服务：service</li>
<li>热点：hot</li>
<li>新闻：news</li>
<li>下载：download</li>
<li>投票：vote</li>
<li>合作伙伴：partner</li>
<li>友情链接：link</li>
<li>版权：copyright</li>
</ul>
]]></content>
      <categories>
        <category>层叠样式表CSS</category>
      </categories>
      <tags>
        <tag>命名规范</tag>
      </tags>
  </entry>
</search>
